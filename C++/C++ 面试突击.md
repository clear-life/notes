# C++ 面试突击

编译:

1. 编译预处理: 处理 # 指令, include 导入头文件, define 代码替换

2. 编译: 高级语言 .cpp -> 汇编语言 .s

3. 汇编: 汇编语言 -> 机器语言 .o

4. 链接: 将各个文件连接成一个整体 .exe

   1. 静态链接: 将代码从静态链接库中拷贝到 .exe 中
   2. 动态链接: 记录动态链接库的信息, 执行时动态映射到进程的虚拟地址空间

   * 优缺点: 一个浪费空间但快, 一个节省内存但慢

   

内存管理:

.text 段 -> .data 段 -> .bss 段 -> 堆 -> 未使用 -> 栈

代码区 -> 常量区和静态区 -> 全局区 -> 堆 -> 未使用 -> 栈



栈和堆的区别:

栈: 系统分配, 顺序存储, 效率高, 存储函数内的数据

堆: 程序员申请, 链式存储, 效率低, 程序员的数据



全局变量, 局部变量, 静态全局变量, 静态局部变量区别: 

作用域:

全局变量: 全局作用域, 所有文件都能用, 全局生命周期

静态全局变量: 文件作用域, 本文件能用

局部变量: 局部作用域, 生命周期: 局部的开始到第一次结束

静态局部变量: 局部作用域, 只被初始化一次, 声明周期: 第一次初始化到程序结束



内存空间: 

静态区/全局区: 全局变量和静态变量

栈: 局部变量



全局变量定义在头文件中时, 被多个文件 include 时会重复定义



内存对齐:

编译器将 "数据单元" 存放在字的整数倍内存地址

原因: 硬件设备能很好处理对齐的数据存取, 提高内存访问效率

优点: 方便在不同平台移植, 提高内存访问效率

>内存对齐规则:
>
>对齐系数大小: words
>
>成员类型大小: type
>
>有效对齐值: align = min{words, max type}
>
> 结构体总大小: 有效对齐值的整数倍
>
>每个成员的偏移量: min{type, align} 的整数倍



内存泄漏:

没有释放不再使用的内存

解释: 失去了对内存的控制, 造成内存浪费, 常指堆内存泄露, malloc 和 new 分配的内存

场景:

指向某块内存的指针被覆盖掉, 不能找到原来的内存



防止内存泄漏:

1. 封装: 内存的分配和释放封装到类中, 构造时申请, 析构时释放

   > 对象复制后, 两个对象销毁后, 会释放两次统一内存空间

2. 智能指针
   * 共享指针: 一个资源多人共享
     * 问题：循环引用，类似死锁，两个共享指针相互引用
   * 独占指针: 一个资源一人独占
   * 弱指针: 解决共享指针循环引用问题



一个 `unique_ptr` 通过 `std::move()` 赋值给另一个 `unique_ptr` 对象



C++ 11 新特性

`auto` 类型推导

`decltype` 类型推导

`lambda` 表达式

范围 `for` 语句

右值引用 `&&`

`std::move()` 函数

智能指针

`delete`  `default` 函数
