# 类设计者的工具

## 第 13 章 拷贝控制

### 13.1 拷贝, 赋值与销毁

#### 13.1.1 拷贝构造函数

拷贝构造函数: **构造函数**的**第一个参数是自身类型的引用**, 且**其余参数都有默认值**

```C++
class Class
{
public:
	Class();				// 默认构造函数
	Class(const Class&);	// 拷贝构造函数
};
```

> 拷贝构造函数会被隐式使用, 所以不能是 explicit

**合成拷贝构造函数**

如果未定义拷贝构造函数, 编译器会自动定义一个合成拷贝构造函数

合成拷贝构造函数拷贝每个非 static 成员

```C++
class Class
{
public:
	Class(const Class&);
private:
    string s;
    int a;
    double b;
}
// 与合成拷贝构造函数等价的自定义的拷贝构造函数
Class::Class(const Class& that):
	s(that.s), 				// string 类的拷贝调用 string 的拷贝构造函数
	a(that.a), b(that.b)	// 内置类型直接拷贝
    {	}
```

**拷贝初始化**

```C++
string s(5, 'c');			// 直接初始化, 调用构造函数
string s(s2);				// 直接初始化, 调用构造函数
string s = s2;				// 拷贝初始化, 通常调用拷贝构造函数
string s = "hello";			// 拷贝初始化, 通常调用拷贝构造函数
string s = string(5, 'c');	// 拷贝初始化, 通常调用拷贝构造函数
```

> 直接初始化用构造函数初始化, 相当于 emplace_back
>
> 拷贝初始化

拷贝初始化发生情况

* 用 `=` 定义变量
* 传递参数时值传递
* 返回结果时值返回
* 用花括号列表初始化数组元素或聚合类成员

> insert 或 push 	拷贝初始化
>
> emplace 		     直接初始化

**拷贝初始化的限制**

如果拷贝构造函数是 `explicit` 的, 则不能隐式转换

```C++
vector<int> v(1);		// 直接初始化, 正确
vector<int> v = 1;		// 拷贝初始化, 错误, 因为是 explicit 的

void fun(vector<int>);	// 接受 vector<int> 类型的参数
fun(1);					// 错误, 1 是 int 类型, 不能通过 explicit 拷贝构造函数进行隐式转换
fun(vector<int>(10));	// 正确, 从 int 构造 vector<int>
```

#### 13.1.2 拷贝赋值运算符

**重载赋值运算符**

重载运算符是一个函数

* 函数名是 `operator` 关键字后面加上运算符的符号

  如 `operator=`

* 运算符函数也有**返回类型**和**参数列表**

  如**二元运算符**, **左侧运算对象**绑定到 **this 隐式参数**, **右侧运算对象**作为**显式参数**传递, 返回**左侧运算对象的引用**

```C++
class Class
{
public:
    Class operator=(const Class&);		// 赋值运算符
};
```

**合成拷贝赋值运算符**

编译器自动生成(未定义拷贝赋值运算符时)

合成拷贝复制运算符将右侧的非 static 成员赋值给左边(调用**成员的拷贝赋值运算符**), 返回左侧运算对象的引用

```C++
// 与合成拷贝赋值运算符等价的赋值运算符函数
Class& Class::operator=(const Class &c)
{
    // 使用 a,b,s 的拷贝赋值运算符赋值
    a = c.a;		
    b = c.b;
    s = c.s;
    return *this;
}
```

#### 13.1.3 析构函数

构造函数**初始化**对象的非 static 数据成员

析构函数**释放并销毁**对象的非 static 数据成员

析构函数名: `~` 加上类名, 无参数和返回值

> 析构函数无参数, 因此不能被重载, 一个类只有一个析构函数

```C++
class Class
{
public:
    ~Class();	// 析构函数
};
```

**析构函数作用**

先执行函数体, 执行自定义的操作, 然后按**初始化顺序的逆序**销毁(隐式销毁)数据成员

> 析构函数用来释放对象分配的资源

数据成员销毁时

* 类类型成员执行析构函数
* 内置类型没有析构函数, 什么也不需要做

> 隐式销毁内置指针不会 delete 指针指向的对象

**调用析构函数的时刻**

对象被销毁时, 都会自动调用析构函数

* 变量离开作用域时
* 对象被销毁时, 成员被销毁
* 容器被销毁时, 元素被销毁
* 动态分配对象 delete 时
* 临时对象的表达式结束时

> 对象的引用或指针被销毁时, 对象的析构函数不会执行

**合成析构函数**

```C++
// 与合成析构函数等价的析构函数
class Class
{
public:
	~Class() { }	// 成员被自动销毁    
};
```

> 析构函数的函数体不会销毁数据成员
>
> 成员在析构函数体之后**隐式的析构阶段**被销毁

#### 13.1.4 三/五法则

* 需要**析构函数**一般也需要**拷贝**和**赋值**操作
* 需要**拷贝**操作一般也需要**赋值**操作
* 需要**赋值**操作一般也需要**拷贝**操作

#### 13.1.5 =default

可以将拷贝控制成员定义为 `=default` 显式告诉编译器**生成合成的拷贝控制成员**

> 拷贝控制成员
>
> * 构造函数
> * 拷贝构造函数
> * 拷贝赋值运算符
> * 移动构造函数
> * 移动赋值运算符
> * 析构函数

```C++
class Class
{
public:
    Class() = default;					// 合成默认构造函数, 内联
    Class(const Class&) = default;		// 合成拷贝构造函数, 内联
    Class& operator=(const Class &);	// 合成拷贝赋值运算符, 函数外定义
    ~Class () = default;				// 合成析构函数, 内联
};
Class& Class::operator=(const Class &) = default;	// 函数外使用 default
```

> 只能对具有合成版本的成员函数使用 =default

#### 13.1.6 阻止拷贝

**定义删除的函数**

将拷贝构造函数和拷贝赋值运算符定义为**删除的函数**来阻止拷贝操作

通过在参数列表后面加上 `=delete` 来声明一个函数是删除的函数(不希望定义的函数)

```C++
class Class
{
    Class() = default;				// 合成默认构造函数
    Class(const Class&) = delete;	// 阻止拷贝构造
    Class& operator=(const Class&) = delete;	// 阻止拷贝赋值
    ~Class() = default;				// 合成析构函数
};
```

* `=default` 必须出现在第一次声明的时候
* 可以对任何函数指定为 `=delete`

**析构函数不能是删除的函数**

**合成的拷贝控制成员可以是删除的**

因为赋值后, 引用成员并不改变引用的对象

所以对于有引用成员的类, 合成拷贝赋值运算符是删除的

 

### 13.2 拷贝控制和资源管理

定义拷贝操作, 可以使类的行为像一个值或像一个指针

#### 13.2.1 行为像值的类

每个对象都有一份独自的类管理的资源

```C++
class Class
{
public:
    Class(const string &s = string()):	// 构造函数
    	p(new string(s)), a(0) { }		// 分配新的资源
    
    Class(const Class &c):				// 拷贝构造函数
    	p(new string(*c.p)), a(c.a) { }	// 也分配新的资源
    
    Class& operator=(const Class &); 	// 拷贝赋值运算符
    
    ~Class() { delete p; }				// 析构函数
private:
    string *p;
    int a;
};
```

**拷贝赋值运算符**

赋值运算符通常**组合**了**构造函数**和**析构函数**的功能

1. **先拷贝右侧**运算对象, 因而可以**处理自赋值**的情况
2. **再释放左侧**运算对象的资源
3. **最后更新左侧**运算对象的值

```C++
Class& Class::operator=(const Class &c)
{
    string *np = new string(*c.p);	// 1. 拷贝右侧运算对象, 分配新的资源		拷贝函数的功能
    
    delete p;						// 2. 释放左侧运算对象的资源			  析构函数的功能
    
    p = np;							// 3. 更新左侧运算对象的值
    a = c.a;
    
    return *this;					// 返回左侧运算对象的引用
}
```

#### 13.2.2 行为像指针的类

* 行为像指针的类, 需要自定义**拷贝构造函数**和**拷贝赋值运算符**, 因为需要定义**析构函数**

* 但析构函数不能直接 delete 指针, 必须**最后一个管理同一份资源的指针销毁后**, **才能释放资源(内存)**
* 可以使用引用计数**统计指向同一份资源的指针数**

**引用计数**

* 构造函数**创建引用计数**, 初始化为 1
* 拷贝构造函数**递增引用计数**
* 拷贝赋值运算符**递增右侧**运算对象的引用计数, **递减左侧**运算对象的引用计数
* 析构函数**递减引用计数**, 如果为 0 , 则释放资源

> 引用计数也作为资源的一部分保存在动态内存中, 由各个对象共享状态

**使用引用计数的类**

```C++
class Class
{
public:
    Class(const string &s = string()):		// 构造函数
    	p(new string(s)), a(0), num(new size_t(1)) { }	// 创建资源, 分配初值, 初始化计数器
    
    Class(const Class &c):					// 拷贝构造函数
    	p(c.p), a(c.a), num(c.num) { ++*num; }	// 拷贝值, 递增计数器
    
    Class& operator=(const Class &);		// 拷贝赋值运算符
    ~Class();								// 析构函数
    
private:
    string *p;		// 指向 string 的指针
    int a;			
    size_t *num;	// 指向计数器的指针
};
```

**拷贝赋值运算符与析构函数**

拷贝赋值运算符必须能处理**自赋值**, 因此**先递增右侧**的计数器, **再递减左侧**的计数器

```C++
Class& Class::operator=(const Class &c)
{
    ++*c.num;			// 1. 先递增右侧
    if(--*num == 0)		// 2. 再递减左侧
    {
        delete p;		// 如果左侧计数器为 0 就释放左侧资源
        delete num;		// 相当于析构函数
    }
    
    p = c.p;			// 拷贝相应值, 相当于拷贝构造函数 
    a = c.a;
    num = c.num;
    
    return *this;		// 返回左侧运算对象的引用
}
```

析构函数必须计数器为 0 时才能释放资源

```C++
Class::~Class()
{
    if(--*num == 0)		// 递减计数器
    {
        delete p;		// 如果计数器为 0 就释放资源
        delete num;
	}
}
```

### 13.3 交换操作

通常会为管理资源的类定义一个 swap 函数来交换两个类对象的值

```C++
// swap 函数的过程大概如下
Class c1, c2;
Class tmp = c1;
c1 = c2;
c2 = tmp;
```

> 这种 swap 操作会拷贝新的副本, 效率较低
>
> 通过交换指针可以不拷贝副本来交换对象的值, 效率高

```C++
// 举例
string s1, s2;
int *p = s1;	// 交换指针的值来交换资源效率更高
s1 = s2;	
s2 = p;
```

**自定义 swap 函数**

```C++
class Class
{
public:
    friend void swap(Class &, Class &);	// 自定义 swap 函数
    
    Class(const string &s = string()):	// 构造函数
    	p(new string(s)), a(0) { }		// 分配新的资源
    
    Class(const Class &c):				// 拷贝构造函数
    	p(new string(*c.p)), a(c.a) { }	// 也分配新的资源
    
    Class& operator=(const Class &); 	// 拷贝赋值运算符
    
    ~Class() { delete p; }				// 析构函数
private:
    string *p;
    int a;
};

inline void swap(Class &a, Class &b)
{
    using std::swap;
    swap(a.p, b.p);		// 交换 string 指针成员	
    swap(a.a, b.a);		// 交换 int 成员
}
```

> 自定义 swap 函数不是必要的, 但是一种重要的优化手段

**swap 函数应该调用成员自定义的 swap 函数, 而不是 std::swap**

```C++
class Class2
{
  	...  
};

class Class1
{
    Class2 c;
};

void swap(Class1 &a, Class1 &b)
{
    using std::swap;
    swap(a.c, b.c);		// 此处调用 Class2 的 swap 函数, 而不是 std::swap 函数
}
```

> 对 swap(a.c, b.c) 来说, swap(Class2 &, Class2 &) 的匹配程度比 std::swap 的匹配程度高, 所以优先调用 Class2 的 swap 函数

**在赋值运算符中使用 swap 函数**

定义 swap 函数的类通常用 swap 函数来定义赋值运算符

* 拷贝并交换技术: 将左侧运算对象与右侧运算对象的一个副本交换

```C++
Class& Class::operator=(Class c)	// 先拷贝右侧运算对象, 保证了自赋值的正确性
{
    swap(*this, c);		// 交换左侧运算对和局部变量 c 的值
    
    return *this;		// 局部变量 c 被销毁, 释放原来左侧运算对象(现在是局部变量)的资源, 返回左侧运算对象的引用
}
```

### 13.5 动态内存管理类

实现一个运行时分配可变大小内存的类

**StrVec 类的设计**

* 元素类型是 string
* 内存相关的 allocator 的成员
  * 用 allocator 获取原始内存
  * 用 allocator 的 construct 成员在原始内存中创建元素对象
  * 用 allocator 的 destory 成员来销毁元素对象
* 用三个指针成员表示位置
  * elements 表示首元素位置
  * first_free 表示元素尾后位置
  * cap 已分配内存的尾后位置
* 静态成员 alloc 分配内存, alloc 类型为 allocator<string\>
* 内存相关的成员函数
  * alloc_n_copy 分配内存并拷贝给定元素
  * free 销毁所有元素并释放所有内存
  * chk_n_alloc 保存 StrVec 一定有空余内存, 如果没有就分配, 如果有就不分配
  * reallocate 在内存用完时重新分配双倍的内存

**StrVec 类的定义**

```C++
class StrVec
{
public:
    // 操作接口
    StrVec(): elements(nullptr), first_free(nullptr), cap(nullptr) { }
    StrVec(const StrVec&);
    StrVec& operator=(const StrVec&);
    ~StrVec();
    void push_back(const string&);
    
    // 查询接口
    size_t size() { return first_free - elements; }
    size_t capacity() { return cap - elements; }
    string* begin() const { return elements; }
    string* end() const { return first_free; }
    
private:
    static allocator<string> alloc;
	
    // 隐藏接口
    void chk_n_alloc() { if (size() == capacity()) reallocate(); }	// 保证有未使用内存
    pair<string*, string*> allo_n_copy(string*, string*);	// 从输入范围拷贝分配内存
    void free();		// 释放所有内存
    void reallocate();	// 重新分配双倍的内存
    
    // 私有成员
    string* elements;
    string* first_free;
    string* cap;
};
```

> 默认构造函数显式初始化三个指针成员为 nullptr, 隐式默认初始化 alloc

**使用 construct 构造元素对象**

```C++
void StrVec::push_back(string& s)
{
    chk_n_alloc();
    alloc.construct(first_free++, s);	// 调用 string 的拷贝构造函数构造元素对象
}
```

**alloc_n_copy 成员**

先分配内存, 再从输入范围拷贝元素到分配的内存里

```C++
pair<string*, string*> StrVec::alloc_n_copy(const string *b, const string *e)
{
    auto data = alloc.allocate(e - b);				// 分配 e - b 大小的内存
    return {data, uninitialized_copy(b, e, dada)};	// 将输入范围 [b, e) 的数据拷贝到分配的内存里, 然后返回分配内存的范围
}
```

**free 成员**

先逆序挨个 destory 元素, 即销毁元素, 再释放分配的内存

```C++
void StrVec::free()
{
    // 先检查指针, 指针不能为空
    if (elements)
    {
        for (auto p = first_free; p != elements;  )	// 逆序销毁
        	alloc.destory(--p);
        alloc.deallocate(elements, cap - elements);	// 释放内存
    }
}
```

>  destory 会执行 string 的析构函数, 析构函数会释放 string 自己分配的内存空间

 **拷贝控制成员**

拷贝构造函数调用 alloc_n_copy 实现

```C++
StrVec::StrVec(const StrVec& s)
{
    auto newdata = alloc_n_copy(s.begin(), s.end());
    elements = newdata.first;
    first_free = cap = newdata.second;
}
```

析构函数调用 free 实现

```C++
StrVec::~StrVec() { free(); }
```

拷贝赋值运算符调用 alloc_n_copy 拷贝副本

```C++
StrVec& StrVec::operator=(const StrVec& s)
{
    auto data = alloc_n_copy(s.begin(), s.end());	// 拷贝右侧运算对象的副本
    	
    free();							// 释放左侧运算对象的内存
    
    elements = data.first;			// 将右侧运算对象副本的控制权赋给三个指针
    first_free = cap = data.second;
    
    return *this;					// 返回左侧运算对象的引用
}
```

**重新分配内存时移动元素而不是拷贝元素**

重新分配内存时, 如果能省去释放和重新分配 string 的开销, 性能会提高很多

可以通过移动构造函数实现元素的 "移动"

**移动构造函数和 std::move**

将资源从源对象移动到目的对象, 减少开销

使用标准库函数 std::move 来使用 string 的移动构造函数

**reallocate 成员**

先分配两倍的内存空间, 然后把旧内存的数据移动过来

```C++
void StrVec::reallocate()
{
    auto newcapacity = size() ? 2 * size() : 1;		// 分配新内存
    auto newdata = alloc.allocate(newcapacity);
    
    auto newindex = newdata;						
    auto oldelem = elements;	
	for(size_t i = 0; i != size(); ++i)				// 将旧内存的数据移动到新内存
    	alloc.construct(newindex++, std::move(*oldelem++));		// 使用 string 的移动构造函数移动构造元素对象
    
    free();						// 释放旧内存
    
    elements = newdata;			// 将新内存的控制权赋给三个指针
    first_free = newindex;
    cap = elements + newcapacity;
}
```

### 13.6 对象移动

新标准的特性是可以移动对象

新标准的容器可以保存不可拷贝的类型, 只需要能被移动即可

#### 13.6.1 右值引用

绑定到右值的引用

* 绑定到一个将要销毁的对象

* && 运算符

```cpp
int &&a = 1;		// 右值引用, int && 绑定到一个右值上
const int &a = 1;	// 可以将 const int & 绑定到一个右值上
```

**左值持久, 右值短暂**

左值有持久的状态

右值要么是字面常量, 要么是临时对象

右值只能绑定到临时对象

* 右值所引用的对象将要被销毁
* 右值引用的对象没有其他用户

> 使用右值引用的代码可以自由地接管右值引用对象的资源

**右值引用的变量是左值**

```cpp
int &&a = 1;	// a 是右值引用的变量
int &&b = a;	// 错误, a 是左值, 不能右值引用
```

**标准库 move 函数**

不能将右值引用绑定到左值上, 但可以显式将左值转化为对应的右值引用类型

头文件: <utility\>

函数: `std::move`

```cpp
int a = 1;
int &&b = a;	// 错误, a 是左值
int &&b = std::move(a);	// 正确, move 返回左值 a 的右值引用
```

> 对 a 调用 move 意味着 a 的值不能被使用, 但变量 a 还能正常使用(可以被赋值和销毁)

#### 13.6.2 移动构造函数和移动赋值运算符

移动构造函数必须保证

* 移后的源对象处于一个可销毁状态
* 移后的源对象不再指向被移动的资源

```cpp
StrVec::StrVec(StrVec &&s) noexcept
: elements(s.elements), first_free(s.first_free), cap(s.cap)
{
    s.elements = s.first_free = s.cap = nullptr;	// 令 s 进入一个可销毁状态
}
```

> noexcept 通知标准库该函数不会抛出异常, 可以放心使用

**移动操作, 标准库容器和异常**

移动操作通常不会抛出异常, 因为只是移动资源而不分配任何资源

noexcept 通知标准库移动操作不会抛出异常, 否则标准库为了处理可能存在的异常而做一些额外的工作

必须在声明和定义中都指定 noexcept

```cpp
class Class
{
public:
    StrVec(StrVec &&) noexcept;
};
StrVec::StrVec(StrVec &&s) noexcept : ...
{ ... }
```

**移动赋值运算符**

移动赋值运算符必须能正确处理自赋值

```cpp
StrVec& StrVec::operator=(StrVec &&s) noexcept
{
    if(this != &s)	// 检查是否为自赋值
    {
        free();		// 释放左侧运算对象的内存

        // 接管右侧运算对象的资源
        elements = s.elements;
        first_free = s.first_free;
        cap = s.cap;
        
        // 将右侧运算对象设为可销毁的状态
        s.elements = s.first_free = s.cap = nullptr;
	}
    
    return *this;
}
```

**移后源对象必须可析构**

移动操作必须保证

* 移后源对象可析构
* 移后源对象仍然有效
* 移后源对象的值不能被使用
