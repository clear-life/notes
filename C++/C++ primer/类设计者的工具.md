# 类设计者的工具

## 第 13 章 拷贝控制

### 13.1 拷贝, 赋值与销毁

#### 13.1.1 拷贝构造函数

拷贝构造函数: **构造函数**的**第一个参数是自身类型的引用**, 且**其余参数都有默认值**

```C++
class Class
{
public:
	Class();				// 默认构造函数
	Class(const Class&);	// 拷贝构造函数
};
```

> 拷贝构造函数会被隐式使用, 所以不能是 explicit

**合成拷贝构造函数**

如果未定义拷贝构造函数, 编译器会自动定义一个合成拷贝构造函数

合成拷贝构造函数拷贝每个非 static 成员

```C++
class Class
{
public:
	Class(const Class&);
private:
    string s;
    int a;
    double b;
}
// 与合成拷贝构造函数等价的自定义的拷贝构造函数
Class::Class(const Class& that):
	s(that.s), 				// string 类的拷贝调用 string 的拷贝构造函数
	a(that.a), b(that.b)	// 内置类型直接拷贝
    {	}
```

**拷贝初始化**

```C++
string s(5, 'c');			// 直接初始化, 调用构造函数
string s(s2);				// 直接初始化, 调用构造函数
string s = s2;				// 拷贝初始化, 通常调用拷贝构造函数
string s = "hello";			// 拷贝初始化, 通常调用拷贝构造函数
string s = string(5, 'c');	// 拷贝初始化, 通常调用拷贝构造函数
```

> 直接初始化用构造函数初始化, 相当于 emplace_back
>
> 拷贝初始化

拷贝初始化发生情况

* 用 `=` 定义变量
* 传递参数时值传递
* 返回结果时值返回
* 用花括号列表初始化数组元素或聚合类成员

> insert 或 push 	拷贝初始化
>
> emplace 		     直接初始化

**拷贝初始化的限制**

如果拷贝构造函数是 `explicit` 的, 则不能隐式转换

```C++
vector<int> v(1);		// 直接初始化, 正确
vector<int> v = 1;		// 拷贝初始化, 错误, 因为是 explicit 的

void fun(vector<int>);	// 接受 vector<int> 类型的参数
fun(1);					// 错误, 1 是 int 类型, 不能通过 explicit 拷贝构造函数进行隐式转换
fun(vector<int>(10));	// 正确, 从 int 构造 vector<int>
```

#### 13.1.2 拷贝赋值运算符

**重载赋值运算符**

重载运算符是一个函数

* 函数名是 `operator` 关键字后面加上运算符的符号

  如 `operator=`

* 运算符函数也有**返回类型**和**参数列表**

  如**二元运算符**, **左侧运算对象**绑定到 **this 隐式参数**, **右侧运算对象**作为**显式参数**传递, 返回**左侧运算对象的引用**

```C++
class Class
{
public:
    Class operator=(const Class&);		// 赋值运算符
};
```

**合成拷贝赋值运算符**

编译器自动生成(未定义拷贝赋值运算符时)

合成拷贝复制运算符将右侧的非 static 成员赋值给左边(调用**成员的拷贝赋值运算符**), 返回左侧运算对象的引用

```C++
// 与合成拷贝赋值运算符等价的赋值运算符函数
Class& Class::operator=(const Class &c)
{
    // 使用 a,b,s 的拷贝赋值运算符赋值
    a = c.a;		
    b = c.b;
    s = c.s;
    return *this;
}
```

#### 13.1.3 析构函数

构造函数**初始化**对象的非 static 数据成员

析构函数**释放并销毁**对象的非 static 数据成员

析构函数名: `~` 加上类名, 无参数和返回值

> 析构函数无参数, 因此不能被重载, 一个类只有一个析构函数

```C++
class Class
{
public:
    ~Class();	// 析构函数
};
```

**析构函数作用**

先执行函数体, 执行自定义的操作, 然后按**初始化顺序的逆序**销毁(隐式销毁)数据成员

> 析构函数用来释放对象分配的资源

数据成员销毁时

* 类类型成员执行析构函数
* 内置类型没有析构函数, 什么也不需要做

> 隐式销毁内置指针不会 delete 指针指向的对象

**调用析构函数的时刻**

对象被销毁时, 都会自动调用析构函数

* 变量离开作用域时
* 对象被销毁时, 成员被销毁
* 容器被销毁时, 元素被销毁
* 动态分配对象 delete 时
* 临时对象的表达式结束时

> 对象的引用或指针被销毁时, 对象的析构函数不会执行

**合成析构函数**

```C++
// 与合成析构函数等价的析构函数
class Class
{
public:
	~Class() { }	// 成员被自动销毁    
};
```

> 析构函数的函数体不会销毁数据成员
>
> 成员在析构函数体之后**隐式的析构阶段**被销毁

#### 13.1.4 三/五法则

* 需要**析构函数**一般也需要**拷贝**和**赋值**操作
* 需要**拷贝**操作一般也需要**赋值**操作
* 需要**赋值**操作一般也需要**拷贝**操作

#### 13.1.5 =default

可以将拷贝控制成员定义为 `=default` 显式告诉编译器**生成合成的拷贝控制成员**

> 拷贝控制成员
>
> * 构造函数
> * 拷贝构造函数
> * 拷贝赋值运算符
> * 移动构造函数
> * 移动赋值运算符
> * 析构函数

```C++
class Class
{
public:
    Class() = default;					// 合成默认构造函数, 内联
    Class(const Class&) = default;		// 合成拷贝构造函数, 内联
    Class& operator=(const Class &);	// 合成拷贝赋值运算符, 函数外定义
    ~Class () = default;				// 合成析构函数, 内联
};
Class& Class::operator=(const Class &) = default;	// 函数外使用 default
```

> 只能对具有合成版本的成员函数使用 =default

#### 13.1.6 阻止拷贝

**定义删除的函数**

将拷贝构造函数和拷贝赋值运算符定义为**删除的函数**来阻止拷贝操作

通过在参数列表后面加上 `=delete` 来声明一个函数是删除的函数(不希望定义的函数)

```C++
class Class
{
    Class() = default;				// 合成默认构造函数
    Class(const Class&) = delete;	// 阻止拷贝构造
    Class& operator=(const Class&) = delete;	// 阻止拷贝赋值
    ~Class() = default;				// 合成析构函数
};
```

* `=default` 必须出现在第一次声明的时候
* 可以对任何函数指定为 `=delete`

**析构函数不能是删除的函数**

**合成的拷贝控制成员可以是删除的**

因为赋值后, 引用成员并不改变引用的对象

所以对于有引用成员的类, 合成拷贝赋值运算符是删除的

 

### 13.2 拷贝控制和资源管理

定义拷贝操作, 可以使类的行为像一个值或像一个指针

#### 13.2.1 行为像值的类

每个对象都有一份独自的类管理的资源

```C++
class Class
{
public:
    Class(const string &s = string()):	// 构造函数
    	p(new string(s)), a(0) { }		// 分配新的资源
    
    Class(const Class &c):				// 拷贝构造函数
    	p(new string(*c.p)), a(c.a) { }	// 也分配新的资源
    
    Class& operator=(const Class &); 	// 拷贝赋值运算符
    
    ~Class() { delete p; }				// 析构函数
private:
    string *p;
    int a;
};
```

**拷贝赋值运算符**

赋值运算符通常**组合**了**构造函数**和**析构函数**的功能

1. **先拷贝右侧**运算对象, 因而可以**处理自赋值**的情况
2. **再释放左侧**运算对象的资源
3. **最后更新左侧**运算对象的值

```C++
Class& Class::operator=(const Class &c)
{
    string *np = new string(*c.p);	// 1. 拷贝右侧运算对象, 分配新的资源		拷贝函数的功能
    
    delete p;						// 2. 释放左侧运算对象的资源			  析构函数的功能
    
    p = np;							// 3. 更新左侧运算对象的值
    a = c.a;
    
    return *this;					// 返回左侧运算对象的引用
}
```

#### 13.2.2 行为像指针的类

* 行为像指针的类, 需要自定义**拷贝构造函数**和**拷贝赋值运算符**, 因为需要定义**析构函数**

* 但析构函数不能直接 delete 指针, 必须**最后一个管理同一份资源的指针销毁后**, **才能释放资源(内存)**
* 可以使用引用计数**统计指向同一份资源的指针数**

**引用计数**

* 构造函数**创建引用计数**, 初始化为 1
* 拷贝构造函数**递增引用计数**
* 拷贝赋值运算符**递增右侧**运算对象的引用计数, **递减左侧**运算对象的引用计数
* 析构函数**递减引用计数**, 如果为 0 , 则释放资源

> 引用计数也作为资源的一部分保存在动态内存中, 由各个对象共享状态

**使用引用计数的类**

```C++
class Class
{
public:
    Class(const string &s = string()):		// 构造函数
    	p(new string(s)), a(0), num(new size_t(1)) { }	// 创建资源, 分配初值, 初始化计数器
    
    Class(const Class &c):					// 拷贝构造函数
    	p(c.p), a(c.a), num(c.num) { ++*num; }	// 拷贝值, 递增计数器
    
    Class& operator=(const Class &);		// 拷贝赋值运算符
    ~Class();								// 析构函数
    
private:
    string *p;		// 指向 string 的指针
    int a;			
    size_t *num;	// 指向计数器的指针
};
```

**拷贝赋值运算符与析构函数**

拷贝赋值运算符必须能处理**自赋值**, 因此**先递增右侧**的计数器, **再递减左侧**的计数器

```C++
Class& Class::operator=(const Class &c)
{
    ++*c.num;			// 1. 先递增右侧
    if(--*num == 0)		// 2. 再递减左侧
    {
        delete p;		// 如果左侧计数器为 0 就释放左侧资源
        delete num;		// 相当于析构函数
    }
    
    p = c.p;			// 拷贝相应值, 相当于拷贝构造函数 
    a = c.a;
    num = c.num;
    
    return *this;		// 返回左侧运算对象的引用
}
```

析构函数必须计数器为 0 时才能释放资源

```C++
Class::~Class()
{
    if(--*num == 0)		// 递减计数器
    {
        delete p;		// 如果计数器为 0 就释放资源
        delete num;
	}
}
```

