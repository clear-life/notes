# 类设计者的工具

## 第 13 章 拷贝控制

### 13.1 拷贝, 赋值与销毁

#### 13.1.1 拷贝构造函数

拷贝构造函数: **构造函数**的**第一个参数是自身类型的引用**, 且**其余参数都有默认值**

```C++
class Class
{
public:
	Class();				// 默认构造函数
	Class(const Class&);	// 拷贝构造函数
};
```

> 拷贝构造函数会被隐式使用, 所以不能是 explicit

**合成拷贝构造函数**

如果未定义拷贝构造函数, 编译器会自动定义一个合成拷贝构造函数

合成拷贝构造函数拷贝每个非 static 成员

```C++
class Class
{
public:
	Class(const Class&);
private:
    string s;
    int a;
    double b;
}
// 与合成拷贝构造函数等价的自定义的拷贝构造函数
Class::Class(const Class& that):
	s(that.s), 				// string 类的拷贝调用 string 的拷贝构造函数
	a(that.a), b(that.b)	// 内置类型直接拷贝
    {	}
```

**拷贝初始化**

```C++
string s(5, 'c');			// 直接初始化, 调用构造函数
string s(s2);				// 直接初始化, 调用构造函数
string s = s2;				// 拷贝初始化, 通常调用拷贝构造函数
string s = "hello";			// 拷贝初始化, 通常调用拷贝构造函数
string s = string(5, 'c');	// 拷贝初始化, 通常调用拷贝构造函数
```

> 直接初始化用构造函数初始化, 相当于 emplace_back
>
> 拷贝初始化

拷贝初始化发生情况

* 用 `=` 定义变量
* 传递参数时值传递
* 返回结果时值返回
* 用花括号列表初始化数组元素或聚合类成员

> insert 或 push 	拷贝初始化
>
> emplace 		     直接初始化

**拷贝初始化的限制**

如果拷贝构造函数是 `explicit` 的, 则不能隐式转换

```C++
vector<int> v(1);		// 直接初始化, 正确
vector<int> v = 1;		// 拷贝初始化, 错误, 因为是 explicit 的

void fun(vector<int>);	// 接受 vector<int> 类型的参数
fun(1);					// 错误, 1 是 int 类型, 不能通过 explicit 拷贝构造函数进行隐式转换
fun(vector<int>(10));	// 正确, 从 int 构造 vector<int>
```

#### 13.1.2 拷贝赋值运算符

**重载赋值运算符**

重载运算符是一个函数

* 函数名是 `operator` 关键字后面加上运算符的符号

  如 `operator=`

* 运算符函数也有**返回类型**和**参数列表**

  如**二元运算符**, **左侧运算对象**绑定到 **this 隐式参数**, **右侧运算对象**作为**显式参数**传递, 返回**左侧运算对象的引用**

```C++
class Class
{
public:
    Class operator=(const Class&);		// 赋值运算符
};
```

**合成拷贝赋值运算符**

编译器自动生成(未定义拷贝赋值运算符时)

合成拷贝复制运算符将右侧的非 static 成员赋值给左边(调用**成员的拷贝赋值运算符**), 返回左侧运算对象的引用

```C++
// 与合成拷贝赋值运算符等价的赋值运算符函数
Class& Class::operator=(const Class &c)
{
    // 使用 a,b,s 的拷贝赋值运算符赋值
    a = c.a;		
    b = c.b;
    s = c.s;
    return *this;
}
```

#### 13.1.3 析构函数

构造函数**初始化**对象的非 static 数据成员

析构函数**释放并销毁**对象的非 static 数据成员

析构函数名: `~` 加上类名, 无参数和返回值

> 析构函数无参数, 因此不能被重载, 一个类只有一个析构函数

```C++
class Class
{
public:
    ~Class();	// 析构函数
};
```

**析构函数作用**

先执行函数体, 执行自定义的操作, 然后按**初始化顺序的逆序**销毁(隐式销毁)数据成员

> 析构函数用来释放对象分配的资源

数据成员销毁时

* 类类型成员执行析构函数
* 内置类型没有析构函数, 什么也不需要做

> 隐式销毁内置指针不会 delete 指针指向的对象

**调用析构函数的时刻**

对象被销毁时, 都会自动调用析构函数

* 变量离开作用域时
* 对象被销毁时, 成员被销毁
* 容器被销毁时, 元素被销毁
* 动态分配对象 delete 时
* 临时对象的表达式结束时

> 对象的引用或指针被销毁时, 对象的析构函数不会执行

**合成析构函数**

```C++
// 与合成析构函数等价的析构函数
class Class
{
public:
	~Class() { }	// 成员被自动销毁    
};
```

> 析构函数的函数体不会销毁数据成员
>
> 成员在析构函数体之后**隐式的析构阶段**被销毁

#### 13.1.4 三/五法则

* 需要**析构函数**一般也需要**拷贝**和**赋值**操作
* 需要**拷贝**操作一般也需要**赋值**操作
* 需要**赋值**操作一般也需要**拷贝**操作

#### 13.1.5 =default

可以将拷贝控制成员定义为 `=default` 显式告诉编译器**生成合成的拷贝控制成员**

> 拷贝控制成员
>
> * 构造函数
> * 拷贝构造函数
> * 拷贝赋值运算符
> * 移动构造函数
> * 移动赋值运算符
> * 析构函数

```C++
class Class
{
public:
    Class() = default;					// 合成默认构造函数, 内联
    Class(const Class&) = default;		// 合成拷贝构造函数, 内联
    Class& operator=(const Class &);	// 合成拷贝赋值运算符, 函数外定义
    ~Class () = default;				// 合成析构函数, 内联
};
Class& Class::operator=(const Class &) = default;	// 函数外使用 default
```

> 只能对具有合成版本的成员函数使用 =default

#### 13.1.6 阻止拷贝

**定义删除的函数**

将拷贝构造函数和拷贝赋值运算符定义为**删除的函数**来阻止拷贝操作

通过在参数列表后面加上 `=delete` 来声明一个函数是删除的函数(不希望定义的函数)

```C++
class Class
{
    Class() = default;				// 合成默认构造函数
    Class(const Class&) = delete;	// 阻止拷贝构造
    Class& operator=(const Class&) = delete;	// 阻止拷贝赋值
    ~Class() = default;				// 合成析构函数
};
```

* `=default` 必须出现在第一次声明的时候
* 可以对任何函数指定为 `=delete`

**析构函数不能是删除的函数**

**合成的拷贝控制成员可以是删除的**

因为赋值后, 引用成员并不改变引用的对象

所以对于有引用成员的类, 合成拷贝赋值运算符是删除的

