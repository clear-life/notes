# 类设计者的工具

## 第 13 章 拷贝控制

### 13.1 拷贝, 赋值与销毁

#### 13.1.1 拷贝构造函数

拷贝构造函数: **构造函数**的**第一个参数是自身类型的引用**, 且**其余参数都有默认值**

```C++
class Class
{
public:
	Class();				// 默认构造函数
	Class(const Class&);	// 拷贝构造函数
};
```

> 拷贝构造函数会被隐式使用, 所以不能是 explicit

**合成拷贝构造函数**

如果未定义拷贝构造函数, 编译器会自动定义一个合成拷贝构造函数

合成拷贝构造函数拷贝每个非 static 成员

```C++
class Class
{
public:
	Class(const Class&);
private:
    string s;
    int a;
    double b;
}
// 与合成拷贝构造函数等价的自定义的拷贝构造函数
Class::Class(const Class& that):
	s(that.s), 				// string 类的拷贝调用 string 的拷贝构造函数
	a(that.a), b(that.b)	// 内置类型直接拷贝
    {	}
```

**拷贝初始化**

```C++
string s(5, 'c');			// 直接初始化, 调用构造函数
string s(s2);				// 直接初始化, 调用构造函数
string s = s2;				// 拷贝初始化, 通常调用拷贝构造函数
string s = "hello";			// 拷贝初始化, 通常调用拷贝构造函数
string s = string(5, 'c');	// 拷贝初始化, 通常调用拷贝构造函数
```

> 直接初始化用构造函数初始化, 相当于 emplace_back
>
> 拷贝初始化

拷贝初始化发生情况

* 用 `=` 定义变量
* 传递参数时值传递
* 返回结果时值返回
* 用花括号列表初始化数组元素或聚合类成员

> insert 或 push 	拷贝初始化
>
> emplace 		     直接初始化

**拷贝初始化的限制**

如果拷贝构造函数是 `explicit` 的, 则不能隐式转换

```C++
vector<int> v(1);		// 直接初始化, 正确
vector<int> v = 1;		// 拷贝初始化, 错误, 因为是 explicit 的

void fun(vector<int>);	// 接受 vector<int> 类型的参数
fun(1);					// 错误, 1 是 int 类型, 不能通过 explicit 拷贝构造函数进行隐式转换
fun(vector<int>(10));	// 正确, 从 int 构造 vector<int>
```

#### 13.1.2 拷贝赋值运算符

**重载赋值运算符**

重载运算符是一个函数

* 函数名是 `operator` 关键字后面加上运算符的符号

  如 `operator=`

* 运算符函数也有**返回类型**和**参数列表**

  如**二元运算符**, **左侧运算对象**绑定到 **this 隐式参数**, **右侧运算对象**作为**显式参数**传递, 返回**左侧运算对象的引用**

```C++
class Class
{
public:
    Class operator=(const Class&);		// 赋值运算符
};
```

**合成拷贝赋值运算符**

编译器自动生成(未定义拷贝赋值运算符时)

合成拷贝复制运算符将右侧的非 static 成员赋值给左边(调用**成员的拷贝赋值运算符**), 返回左侧运算对象的引用

```C++
// 与合成拷贝赋值运算符等价的赋值运算符函数
Class& Class::operator=(const Class &c)
{
    // 使用 a,b,s 的拷贝赋值运算符赋值
    a = c.a;		
    b = c.b;
    s = c.s;
    return *this;
}
```

#### 13.1.3 析构函数

构造函数**初始化**对象的非 static 数据成员

析构函数**释放并销毁**对象的非 static 数据成员

析构函数名: `~` 加上类名, 无参数和返回值

> 析构函数无参数, 因此不能被重载, 一个类只有一个析构函数

```C++
class Class
{
public:
    ~Class();	// 析构函数
};
```

**析构函数作用**

先执行函数体, 执行自定义的操作, 然后按**初始化顺序的逆序**销毁(隐式销毁)数据成员

> 析构函数用来释放对象分配的资源

数据成员销毁时

* 类类型成员执行析构函数
* 内置类型没有析构函数, 什么也不需要做

> 隐式销毁内置指针不会 delete 指针指向的对象

**调用析构函数的时刻**

对象被销毁时, 都会自动调用析构函数

* 变量离开作用域时
* 对象被销毁时, 成员被销毁
* 容器被销毁时, 元素被销毁
* 动态分配对象 delete 时
* 临时对象的表达式结束时

> 对象的引用或指针被销毁时, 对象的析构函数不会执行

**合成析构函数**

```C++
// 与合成析构函数等价的析构函数
class Class
{
public:
	~Class() { }	// 成员被自动销毁    
};
```

> 析构函数的函数体不会销毁数据成员
>
> 成员在析构函数体之后**隐式的析构阶段**被销毁

#### 13.1.4 三/五法则

* 需要**析构函数**一般也需要**拷贝**和**赋值**操作
* 需要**拷贝**操作一般也需要**赋值**操作
* 需要**赋值**操作一般也需要**拷贝**操作

#### 13.1.5 =default

可以将拷贝控制成员定义为 `=default` 显式告诉编译器**生成合成的拷贝控制成员**

> 拷贝控制成员
>
> * 构造函数
> * 拷贝构造函数
> * 拷贝赋值运算符
> * 移动构造函数
> * 移动赋值运算符
> * 析构函数

```C++
class Class
{
public:
    Class() = default;					// 合成默认构造函数, 内联
    Class(const Class&) = default;		// 合成拷贝构造函数, 内联
    Class& operator=(const Class &);	// 合成拷贝赋值运算符, 函数外定义
    ~Class () = default;				// 合成析构函数, 内联
};
Class& Class::operator=(const Class &) = default;	// 函数外使用 default
```

> 只能对具有合成版本的成员函数使用 =default

#### 13.1.6 阻止拷贝

**定义删除的函数**

将拷贝构造函数和拷贝赋值运算符定义为**删除的函数**来阻止拷贝操作

通过在参数列表后面加上 `=delete` 来声明一个函数是删除的函数(不希望定义的函数)

```C++
class Class
{
    Class() = default;				// 合成默认构造函数
    Class(const Class&) = delete;	// 阻止拷贝构造
    Class& operator=(const Class&) = delete;	// 阻止拷贝赋值
    ~Class() = default;				// 合成析构函数
};
```

* `=default` 必须出现在第一次声明的时候
* 可以对任何函数指定为 `=delete`

**析构函数不能是删除的函数**

**合成的拷贝控制成员可以是删除的**

因为赋值后, 引用成员并不改变引用的对象

所以对于有引用成员的类, 合成拷贝赋值运算符是删除的

 

### 13.2 拷贝控制和资源管理

定义拷贝操作, 可以使类的行为像一个值或像一个指针

#### 13.2.1 行为像值的类

每个对象都有一份独自的类管理的资源

```C++
class Class
{
public:
    Class(const string &s = string()):	// 构造函数
    	p(new string(s)), a(0) { }		// 分配新的资源
    
    Class(const Class &c):				// 拷贝构造函数
    	p(new string(*c.p)), a(c.a) { }	// 也分配新的资源
    
    Class& operator=(const Class &); 	// 拷贝赋值运算符
    
    ~Class() { delete p; }				// 析构函数
private:
    string *p;
    int a;
};
```

**拷贝赋值运算符**

赋值运算符通常**组合**了**构造函数**和**析构函数**的功能

1. **先拷贝右侧**运算对象, 因而可以**处理自赋值**的情况
2. **再释放左侧**运算对象的资源
3. **最后更新左侧**运算对象的值

```C++
Class& Class::operator=(const Class &c)
{
    string *np = new string(*c.p);	// 1. 拷贝右侧运算对象, 分配新的资源		拷贝函数的功能
    
    delete p;						// 2. 释放左侧运算对象的资源			  析构函数的功能
    
    p = np;							// 3. 更新左侧运算对象的值
    a = c.a;
    
    return *this;					// 返回左侧运算对象的引用
}
```

#### 13.2.2 行为像指针的类

* 行为像指针的类, 需要自定义**拷贝构造函数**和**拷贝赋值运算符**, 因为需要定义**析构函数**

* 但析构函数不能直接 delete 指针, 必须**最后一个管理同一份资源的指针销毁后**, **才能释放资源(内存)**
* 可以使用引用计数**统计指向同一份资源的指针数**

**引用计数**

* 构造函数**创建引用计数**, 初始化为 1
* 拷贝构造函数**递增引用计数**
* 拷贝赋值运算符**递增右侧**运算对象的引用计数, **递减左侧**运算对象的引用计数
* 析构函数**递减引用计数**, 如果为 0 , 则释放资源

> 引用计数也作为资源的一部分保存在动态内存中, 由各个对象共享状态

**使用引用计数的类**

```C++
class Class
{
public:
    Class(const string &s = string()):		// 构造函数
    	p(new string(s)), a(0), num(new size_t(1)) { }	// 创建资源, 分配初值, 初始化计数器
    
    Class(const Class &c):					// 拷贝构造函数
    	p(c.p), a(c.a), num(c.num) { ++*num; }	// 拷贝值, 递增计数器
    
    Class& operator=(const Class &);		// 拷贝赋值运算符
    ~Class();								// 析构函数
    
private:
    string *p;		// 指向 string 的指针
    int a;			
    size_t *num;	// 指向计数器的指针
};
```

**拷贝赋值运算符与析构函数**

拷贝赋值运算符必须能处理**自赋值**, 因此**先递增右侧**的计数器, **再递减左侧**的计数器

```C++
Class& Class::operator=(const Class &c)
{
    ++*c.num;			// 1. 先递增右侧
    if(--*num == 0)		// 2. 再递减左侧
    {
        delete p;		// 如果左侧计数器为 0 就释放左侧资源
        delete num;		// 相当于析构函数
    }
    
    p = c.p;			// 拷贝相应值, 相当于拷贝构造函数 
    a = c.a;
    num = c.num;
    
    return *this;		// 返回左侧运算对象的引用
}
```

析构函数必须计数器为 0 时才能释放资源

```C++
Class::~Class()
{
    if(--*num == 0)		// 递减计数器
    {
        delete p;		// 如果计数器为 0 就释放资源
        delete num;
	}
}
```

### 13.3 交换操作

通常会为管理资源的类定义一个 swap 函数来交换两个类对象的值

```C++
// swap 函数的过程大概如下
Class c1, c2;
Class tmp = c1;
c1 = c2;
c2 = tmp;
```

> 这种 swap 操作会拷贝新的副本, 效率较低
>
> 通过交换指针可以不拷贝副本来交换对象的值, 效率高

```C++
// 举例
string s1, s2;
int *p = s1;	// 交换指针的值来交换资源效率更高
s1 = s2;	
s2 = p;
```

**自定义 swap 函数**

```C++
class Class
{
public:
    friend void swap(Class &, Class &);	// 自定义 swap 函数
    
    Class(const string &s = string()):	// 构造函数
    	p(new string(s)), a(0) { }		// 分配新的资源
    
    Class(const Class &c):				// 拷贝构造函数
    	p(new string(*c.p)), a(c.a) { }	// 也分配新的资源
    
    Class& operator=(const Class &); 	// 拷贝赋值运算符
    
    ~Class() { delete p; }				// 析构函数
private:
    string *p;
    int a;
};

inline void swap(Class &a, Class &b)
{
    using std::swap;
    swap(a.p, b.p);		// 交换 string 指针成员	
    swap(a.a, b.a);		// 交换 int 成员
}
```

> 自定义 swap 函数不是必要的, 但是一种重要的优化手段

**swap 函数应该调用成员自定义的 swap 函数, 而不是 std::swap**

```C++
class Class2
{
  	...  
};

class Class1
{
    Class2 c;
};

void swap(Class1 &a, Class1 &b)
{
    using std::swap;
    swap(a.c, b.c);		// 此处调用 Class2 的 swap 函数, 而不是 std::swap 函数
}
```

> 对 swap(a.c, b.c) 来说, swap(Class2 &, Class2 &) 的匹配程度比 std::swap 的匹配程度高, 所以优先调用 Class2 的 swap 函数

**在赋值运算符中使用 swap 函数**

定义 swap 函数的类通常用 swap 函数来定义赋值运算符

* 拷贝并交换技术: 将左侧运算对象与右侧运算对象的一个副本交换

```C++
Class& Class::operator=(Class c)	// 先拷贝右侧运算对象, 保证了自赋值的正确性
{
    swap(*this, c);		// 交换左侧运算对和局部变量 c 的值
    
    return *this;		// 局部变量 c 被销毁, 释放原来左侧运算对象(现在是局部变量)的资源, 返回左侧运算对象的引用
}
```

### 13.5 动态内存管理类

实现一个运行时分配可变大小内存的类

**StrVec 类的设计**

* 元素类型是 string
* 内存相关的 allocator 的成员
  * 用 allocator 获取原始内存
  * 用 allocator 的 construct 成员在原始内存中创建元素对象
  * 用 allocator 的 destory 成员来销毁元素对象
* 用三个指针成员表示位置
  * elements 表示首元素位置
  * first_free 表示元素尾后位置
  * cap 已分配内存的尾后位置
* 静态成员 alloc 分配内存, alloc 类型为 allocator<string\>
* 内存相关的成员函数
  * alloc_n_copy 分配内存并拷贝给定元素
  * free 销毁所有元素并释放所有内存
  * chk_n_alloc 保存 StrVec 一定有空余内存, 如果没有就分配, 如果有就不分配
  * reallocate 在内存用完时重新分配双倍的内存

**StrVec 类的定义**

```C++
class StrVec
{
public:
    // 操作接口
    StrVec(): elements(nullptr), first_free(nullptr), cap(nullptr) { }
    StrVec(const StrVec&);
    StrVec& operator=(const StrVec&);
    ~StrVec();
    void push_back(const string&);
    
    // 查询接口
    size_t size() { return first_free - elements; }
    size_t capacity() { return cap - elements; }
    string* begin() const { return elements; }
    string* end() const { return first_free; }
    
private:
    static allocator<string> alloc;
	
    // 隐藏接口
    void chk_n_alloc() { if (size() == capacity()) reallocate(); }	// 保证有未使用内存
    pair<string*, string*> allo_n_copy(string*, string*);	// 从输入范围拷贝分配内存
    void free();		// 释放所有内存
    void reallocate();	// 重新分配双倍的内存
    
    // 私有成员
    string* elements;
    string* first_free;
    string* cap;
};
```

> 默认构造函数显式初始化三个指针成员为 nullptr, 隐式默认初始化 alloc

**使用 construct 构造元素对象**

```C++
void StrVec::push_back(string& s)
{
    chk_n_alloc();
    alloc.construct(first_free++, s);	// 调用 string 的拷贝构造函数构造元素对象
}
```

**alloc_n_copy 成员**

先分配内存, 再从输入范围拷贝元素到分配的内存里

```C++
pair<string*, string*> StrVec::alloc_n_copy(const string *b, const string *e)
{
    auto data = alloc.allocate(e - b);				// 分配 e - b 大小的内存
    return {data, uninitialized_copy(b, e, dada)};	// 将输入范围 [b, e) 的数据拷贝到分配的内存里, 然后返回分配内存的范围
}
```

**free 成员**

先逆序挨个 destory 元素, 即销毁元素, 再释放分配的内存

```C++
void StrVec::free()
{
    // 先检查指针, 指针不能为空
    if (elements)
    {
        for (auto p = first_free; p != elements;  )	// 逆序销毁
        	alloc.destory(--p);
        alloc.deallocate(elements, cap - elements);	// 释放内存
    }
}
```

>  destory 会执行 string 的析构函数, 析构函数会释放 string 自己分配的内存空间

 **拷贝控制成员**

拷贝构造函数调用 alloc_n_copy 实现

```C++
StrVec::StrVec(const StrVec& s)
{
    auto newdata = alloc_n_copy(s.begin(), s.end());
    elements = newdata.first;
    first_free = cap = newdata.second;
}
```

析构函数调用 free 实现

```C++
StrVec::~StrVec() { free(); }
```

拷贝赋值运算符调用 alloc_n_copy 拷贝副本

```C++
StrVec& StrVec::operator=(const StrVec& s)
{
    auto data = alloc_n_copy(s.begin(), s.end());	// 拷贝右侧运算对象的副本
    	
    free();							// 释放左侧运算对象的内存
    
    elements = data.first;			// 将右侧运算对象副本的控制权赋给三个指针
    first_free = cap = data.second;
    
    return *this;					// 返回左侧运算对象的引用
}
```

**重新分配内存时移动元素而不是拷贝元素**

重新分配内存时, 如果能省去释放和重新分配 string 的开销, 性能会提高很多

可以通过移动构造函数实现元素的 "移动"

**移动构造函数和 std::move**

将资源从源对象移动到目的对象, 减少开销

使用标准库函数 std::move 来使用 string 的移动构造函数

**reallocate 成员**

先分配两倍的内存空间, 然后把旧内存的数据移动过来

```C++
void StrVec::reallocate()
{
    auto newcapacity = size() ? 2 * size() : 1;		// 分配新内存
    auto newdata = alloc.allocate(newcapacity);
    
    auto newindex = newdata;						
    auto oldelem = elements;	
	for(size_t i = 0; i != size(); ++i)				// 将旧内存的数据移动到新内存
    	alloc.construct(newindex++, std::move(*oldelem++));		// 使用 string 的移动构造函数移动构造元素对象
    
    free();						// 释放旧内存
    
    elements = newdata;			// 将新内存的控制权赋给三个指针
    first_free = newindex;
    cap = elements + newcapacity;
}
```

### 13.6 对象移动

新标准的特性是可以移动对象

新标准的容器可以保存不可拷贝的类型, 只需要能被移动即可

#### 13.6.1 右值引用

绑定到右值的引用

* 绑定到一个将要销毁的对象

* && 运算符

```cpp
int &&a = 1;		// 右值引用, int && 绑定到一个右值上
const int &a = 1;	// 可以将 const int & 绑定到一个右值上
```

**左值持久, 右值短暂**

左值有持久的状态

右值要么是字面常量, 要么是临时对象

右值只能绑定到临时对象

* 右值所引用的对象将要被销毁
* 右值引用的对象没有其他用户

> 使用右值引用的代码可以自由地接管右值引用对象的资源

**右值引用的变量是左值**

```cpp
int &&a = 1;	// a 是右值引用的变量
int &&b = a;	// 错误, a 是左值, 不能右值引用
```

**标准库 move 函数**

不能将右值引用绑定到左值上, 但可以显式将左值转化为对应的右值引用类型

头文件: <utility\>

函数: `std::move`

```cpp
int a = 1;
int &&b = a;	// 错误, a 是左值
int &&b = std::move(a);	// 正确, move 返回左值 a 的右值引用
```

> 对 a 调用 move 意味着 a 的值不能被使用, 但变量 a 还能正常使用(可以被赋值和销毁)

#### 13.6.2 移动构造函数和移动赋值运算符

移动构造函数必须保证

* 移后的源对象处于一个可销毁状态
* 移后的源对象不再指向被移动的资源

```cpp
StrVec::StrVec(StrVec &&s) noexcept
: elements(s.elements), first_free(s.first_free), cap(s.cap)
{
    s.elements = s.first_free = s.cap = nullptr;	// 令 s 进入一个可销毁状态
}
```

> noexcept 通知标准库该函数不会抛出异常, 可以放心使用

**移动操作, 标准库容器和异常**

移动操作通常不会抛出异常, 因为只是移动资源而不分配任何资源

noexcept 通知标准库移动操作不会抛出异常, 否则标准库为了处理可能存在的异常而做一些额外的工作

必须在声明和定义中都指定 noexcept

```cpp
class Class
{
public:
    StrVec(StrVec &&) noexcept;
};
StrVec::StrVec(StrVec &&s) noexcept : ...
{ ... }
```

**移动赋值运算符**

移动赋值运算符必须能正确处理自赋值

```cpp
StrVec& StrVec::operator=(StrVec &&s) noexcept
{
    if(this != &s)	// 检查是否为自赋值
    {
        free();		// 释放左侧运算对象的内存

        // 接管右侧运算对象的资源
        elements = s.elements;
        first_free = s.first_free;
        cap = s.cap;
        
        // 将右侧运算对象设为可销毁的状态
        s.elements = s.first_free = s.cap = nullptr;
	}
    
    return *this;
}
```

**移后源对象必须可析构**

移动操作必须保证

* 移后源对象可析构
* 移后源对象仍然有效
* 移后源对象的值不能被使用

**合成的移动操作**

如果类定义了**拷贝构造函数**, **拷贝赋值运算符**或**析构函数**, 编译器就不会合成**移动构造函数**和**移动赋值运算符** 

只有当类**没有定义任何拷贝控制成员**, 且类的**非 static 数据成员都可以移动**时, 编译器才会合成移动构造函数和移动赋值运算符

* 内置类型的成员可以直接移动, 类类型成员需要有对应的移动操作

```cpp
struct X
{
    int a;		// 内置类型可以移动
    string s;	// string 定义了移动操作
};
// 编译器会为 X 合成移动操作

struct Y
{
    X x;	// X 有合成的移动操作
};

X x;
X x2 = std::move(x)		// 使用合成的移动构造函数
    
Y y;
Y y2 = std::move(y)		// 使用合成的移动构造函数
```

移动操作不会隐式定义为删除的函数

如果显式要求编译器生成 =default 移动操作, 且编译器不能移动左右成员, 编译器就会将移动操作定义为删除的函数

如果移动操作可能被定义为删除的函数, 编译器就不会合成移动操作

如果类定义了一个移动操作, 则拷贝操作就会被定义为删除的

**移动右值, 拷贝左值**

编译器使用**函数匹配规则**确定使用拷贝构造函数函数移动构造函数

```cpp
StrVec v1, v2;
v1 = v2;			// v2 是左值, 调用拷贝赋值运算符
v2 = getVec(cin);	// getVec 返回右值, 调用移动赋值运算符
```

**如果没有移动构造函数, 右值也被拷贝**

如果类没有移动构造函数, 函数匹配规则保证会调用拷贝构造函数, 即使试图通过调用 move 来移动他们

```cpp
class Class { ... }; 	// 假定 Class 类没有移动构造函数
Class c1;
Class c2(c1);			// c1 是左值, 调用拷贝构造函数
Class c2(std::move(c1));// std::move 返回绑定到 c1 的 Class &&, 是一个右值, 但依然调用拷贝构造函数, 因为 Class 没有移动构造函数
```

**拷贝并交换赋值运算符和移动操作**

```cpp
class Class
{
public:
    Class(Class &&c) noexcept : p(c.p), a(c.a) { c.p = 0; }	// 移动构造函数, c.p = 0 使得 c 处于一个可销毁的状态
    // 赋值运算符即使移动赋值运算符, 也是拷贝赋值运算符
    Class& operator=(Class c)	// 拷贝右侧运算对象的副本为 c, 调用拷贝构造函数
    {
        swap(*this, c);			// 交换左侧运算对象和 c 的资源
        return *this;			// 返回左侧运算对象的引用
    }							// 销毁临时对象 c
};


Class c1, c2;
c1 = c2;			// c2 是左值, 调用赋值运算符, 传入参数时调用拷贝构造函数构造副本
c1 = std::move(c2);	// std::move 返回左值, 调用赋值运算符, 传入参数时调用移动构造函数构造副本
```

**移动迭代器**

移动迭代器解引用后返回一个右值引用

make_move_iterator 函数将普通迭代器转换为移动迭代器

```cpp
auto p2 = uninitialized_copy(make_move_iterator(begin()), make_move_iterator(end()), p1);
begin() end() // 返回首元素和尾后元素迭代器
make_move_iterator(begin()) // 返回首元素迭代器对应的移动迭代器
make_move_iterator(end()) 	// 返回尾后迭代器对应的移动迭代器
uninitialized_copy()		// 将移动迭代器输入范围内的元素"拷贝"到 p1 指针指向的内存, 调用元素的 construct 函数, construct 调用元素的移动构造函数来构造元素
```

#### 13.6.3 右值引用和成员函数

成员函数同时提供拷贝和移动版本

```cpp
void push_back(const X&);	// 拷贝, 绑定到任意的 X 类型
void push_back(X&&);		// 移动, 只能绑定到 X 的右值引用类型, 即非 const 的右值
```

```cpp
alloc.construct(p++, s);			// 可传入任何 string 类型, 调用 string 的拷贝构造函数
alloc.construct(p++, std::move(s));	// 传入可修改的右值, 调用 string 的移动构造函数
```

**右值和左值引用函数**

无论对象是左值还是右值, 都能调用成员函数

```cpp
string s1 = "Hello", s2 = "world!";
auto n = s1.find('a');			// string 左值调用 find 成员函数
auto n = (s1 + s2).find('a');	// string 右值调用 find 成员函数
```

可以限定成员函数的调用对象的类型是左值还是右值

```cpp
class Class
{
public:
    Class& operator=(const Class&) &;	// 引用限定符 & 限定只有左值对象才能调用该函数
};

Class& Class::operator=(const Class& c) &
{
    ...
    return *this;
}
```

```cpp
class Class
{
public:
    Class& operator=(const Class&) &&;	// 引用限定符 && 限定只有右值对象才能调用该函数
};

Class& Class::operator=(const Class& c) &&
{
    ...
    return *this;
}
```

* 引用限定符 & 和 && 只能用于非 static 成员函数

* 引用限定符 & 和 && 必须同时出现在函数的声明和定义中

* 同时使用 const 限定符和引用限定符时, 必须先用 const 限定符, 再用引用限定符

  ```cpp
  class Class
  {
  public;
      Class fun() const &;	// 正确, const 在 & 前面
  };
  Class Class::fun() const &
  {
      ...
  }
  ```

**重载和引用函数**

* 引用限定符可以区分重载函数

* 可以综合 const 限定符和引用限定符来区分重载函数
* 要么所有重载函数不加引用限定符, 要么所有重载函数都加引用限定符

```cpp
class Class
{
public:
    Class sorted() &&;		// 用于任何可修改的右值
    Class sorted() const &;	// 用于任何类型的 Class
};
```



## 第 14 章 重载运算与类型转换

### 14.1 基本概念

* 如果运算符函数是成员函数, 则第一个运算对象绑定到隐式的 this 指针

* 运算符函数要么是**类的成员**, 要么**至少含有一个类类型的参数**

* 只能重载已有的运算符

**直接调用运算符函数**

```cpp
int operator+(int, class) { ... }	// 非成员运算符函数

// 两种等价的调用方式
data1 + data2;				// 表达式
operator+(data1, data2);	// 函数调用
```

**某些运算符不应该被重载**

重载运算符本质上是函数调用, 无法保留**求值顺序**和**短路求值**属性, 不应该重载该类运算符

**使用与内置类型一致的含义**

**选择作为成员或非成员**

### 14.2 输入和输出运算符

#### 14.2.1 重载输出运算符 <<

```cpp
ostream &operator<<(ostream &os, type &v);
os: 非常量 ostream 对象的引用, 非常量: 因为需要写入内容改变状态, 引用: 因为无法赋值 ostream 对象
```

**输入输出运算符必须是非成员函数**

如果输入输出运算符是类的成员, 则也必须是 `istream` 和 `ostream` 的成员

但 `istream` 和 `ostream` 是标准库类, 无法修改

#### 14.2.2 重载输入运算符 >>

```cpp
istream &operator>>(istream &is, type &v)
{
    is >> v;
    
    if(is)		// 检查是否输入成功
        ...
    else
        ...		// 输入失败后将对象置为合法状态
        
    return is;
}
```

> 输入时的错误:
>
> * 类型错误
> * 到达文件末尾
> * 其他错误

### 14.2 算数和关系运算符

通常用复合运算符定义简单运算符

```cpp
type operator+(const typeA &a, const typeB &b)
{
    type sum = a;
    sum += b;
    return sum;
}
```

#### 14.3.1 相等运算符

* 相等运算符应有传递性
* 如果定义 `operator==`, 也应定义 `operator!=`
* 相等和不等运算符的一个应该调用另一个来实现

#### 14.3.2 关系运算符

* 定义顺序关系
* 如果定义 == 运算符, 应与 == 保持一致

### 14.4 赋值运算符

赋值运算符必须定义为成员函数

```cpp
class Class
{
public:
	Class &operator=(std::initializer_list<std::string>);  
};
```

### 14.5 下标运算符

* 下标运算符必须是成员函数, 返回元素的引用
* 类的下标运算符通常定义两个版本
  * 一个返回普通引用
  * 一个是常量成员并返回常量引用

```cpp
class Class
{
public:
    string& operator[](int n) { return a[n]; }				// 返回普通引用
    
    const string& operator[](int n) const { return a[n]; }	// 返回常量引用
};
```

### 14.6 递增和递减运算符

应定义为成员函数

**定义前置递增/递减运算符**

```cpp
class Class
{
public:
    // 前置运算符
    Class& operator++();	// 返回引用
    Class& operator--();
};

// 调用前置运算符
Class c;
c++;
c--;
```

**区分前置和后置运算符**

```cpp
class Class
{
public:
    // 后置运算符
    Class operator++(int);		// 返回值
    Class operator--(int);
};

Class Class::operator++(int)
{
    Class res = *this;
    ++*this;
    return res;
}

Class Class::operator--(int)
{
    Class res = *this;
    --*this;
    return res;
}
```

**显式调用后置运算符**

```cpp
Class c;
c.operator++(0);	// 调用后置版本
c.operator--();		// 调用前置版本
```

### 14.7 成员访问运算符

* 解引用运算符 `*` 和箭头运算符 `->`
* 成员函数

```cpp
class Class
{
public:
    type& operator*() const { return ...; }
    type* operator->() const { return & this->operator*(); }
}
```

**对箭头运算符返回值的限定**

```cpp
point -> mem 的含义

// 若 point 是内置的指针, 含义为
(*point).mem			// *point 为 point 指向的对象, 总的含义为该对象的 mem 成员
// 调用内置 -> 运算符
    
// 若 point 是类的对象, 且重载了 operator-> 运算符, 则含义为
point.operator() -> mem	// 调用 point.operator->() 的结果来获取 mem, 如果结果是一个指针, 就调用内置 -> 运算符	
			
```

