# 数据分析

## 架构

### 前端, 后端, 数据库

前端发请求给后端, 后端对数据库操作并处理数据, 后端返回前端数据

### 框架

`tornado`



## 关键概念

### 路由

由 `URL` 到函数的**映射**

```
/users        ->  getAllUsers()
/users/count  ->  getUsersCount()
```

#### router 与 route

**router**

1. **映射函数**, 负责把一个 URL 映射为一个函数

2. 管理所有的 `route`, 即接收到一个 URL 后, 从**路由映射表**中查找对应的函数

**route**

**一个具体的映射**, URL 和 函数都是确定的

```
/users        ->  getAllUsers()		// 一条路由
```

**服务器端路由**

1. 服务器接收到客户端的 **HTTP 请求**
2. 根据请求里的 URL, 找到**对应的函数**
3. **执行**该函数
4. 将函数的**返回值发送给客户端**



### 前后端处理流程

**关键概念**

**路由: 由 URL 到函数的映射**

```python
class GetKGPVNeW(ReguestHandler, ABC):
    #对应该路由下的get请求
    def post(self):
    table = self.get_query_argument("table")				# 根据 key 得到 value
    tf_property = self.get_query_argument("tf_property")	
    
    page_num = int(seLf.get_body_argument("page"))			# 获取前端发送的信息
    page_size = int(self.get_body_argument("rows"))			# 根据 key 得到 value
    
    # 调试信息
    # print("get获取的参数: page_num", page_ num,";page_size: "，page_size)
    
    # 数据库操作, 根据前面得到的信息和请求的功能, 对数据库进行操作, 并得到返回值
    data_total,data_fileds = pgsql.load_pv_new(table, tf_property, page_num, page_size)
    
    # 组织发送给前端的数据的结构
    value_json = {"total": data total, "rows": data_fileds}
    
    #解决跨域问题
    seLf.set_header("Access-Control-Allow-0rigin", "*") # 允许所有源访问
    seLf.set_header("Cache-ControL", "no-cache”)
    seLf.set_header("Access-Control-Allow-Method", "GET") # 允许访问的方式
                    
   	# 将数据发送给前端
	seLf.write(json.dumps(value_json))		
```

**总结**

1. **获取**前端信息中需要的**数据**, 一般是通过 `key` 获取 `value`
2. 根据前端请求的功能, 对**数据库**进行**操作**, 参数为第一步的数据, 得到数据库返回的数据
3. 对数据库返回的**数据**进行**操作**
4. 组织好数据后**发送给前端**

**问题**

1. `get_query_argument` 与 `get_body_argument`
2. `pgsql.load_pv_new`



#### 数据库操作

```python
```

### URL

```
protocol + hostname + port + path + parameters
协议 + 主机名 + 端口号 + 路径/路由 + 参数
用 / 来划分
例:
https://www.baidu.com:8080/a/test.html?ie=utf-8&f=8
协议:		https://
主机名:	www.baidu.com
端口号:	8080
路径/路由:	/a/test.html
参数: 	?ie=utf-8&f=8
	形参: ie 		f
	实参: utf-8	8

```

### 路由的函数接口

前端访问相应路由(路径), 后端查找**路由表**找到映射的函数

#### 路由接口

由一对对的**路由到函数的映射关系**组成

```python
(r'/datacube/editDataCubeMeta', kgn.EditDataCubeMeta),
```

1.  `python` 字符串前面的 `r` 表示不转义字符串, `f` 表示格式
2.  `/datacube/editDataCubeMeta` 是 主机名:端口号 后面的路由, 表示访问哪个功能
3.  `kgn.EditDataCubeMeta` 表示路由映射的函数

#### 函数接口

收到前端的请求后, **后端具体应该处理**是在**函数接口**里实现的

```python
class EditDataCubeMeta(ReguestHandLer, ABC):	# 继承基类

# post 方法处理前端的 post 请求, 默认参数为 self, 可以带其他参数
def post(seLf):
    
    # 获取 body 里的参数信息
    id = int(self.get_body_argument("tf_dcm_id"))	# 获取的是字符串, 转化为 int 类型
    name = self.get_body_argument("tf_dcm_name ”)	# name 和 description 都是 string 类型
    description = self.get_body_argument("tf_dcm_description" )

    # 调用数据库接口, 填入相应参数, 得到返回结果               
    code, msg = pgsqL.edit_datacube_meta(id, name, description)

    # 设置前端的访问方式
    self.set_header(" Access-ControL-Allow-0rigin", "*")#允许所有的源访问
    self.set_header ("Cache-ControL", "no-cache")
    self.set_header(" Access-ControL-ALlow-Method", "GET") # 允许访问的方式

    # 拼接返回值, 向前端返回结果                 
    value_json = {"code": code, "msg": msg}		# 结果是字典类型
    seLf.write(json.dumps(valLue_json))			# 将结果转化为 json 格式返回给前端
```

#### 数据库接口

数据库接口负责根据相应参数**对数据库进行操作并返回结果**

```python
def edi_datacube_meta(tf_dcm_id, tf_dcm_namem, tf_dcm_description):
   
    code = 1
    msg = ""
    
    #拼接sqL语句
    update_dcm_sqL = f"""
    UPDATE tb_datacube_meta
    SET tf_dcm_name = '{tf dcm_ name}',
    tf_dcm_description = '{tf_dcm_description}',
    tf_dcm_last_modified = now() 
    WHERE tf_dcm_id = {tf_dcm_id}"""
    
    print("update_dcm_sqL:", update_dcm_sql)	# 打印 sql 语句, 方便调试
    
    #执行sqL语句
    try:
        # 连接数据库并执行 sql 语句
        cursor = conn_pgsql.cursor() 
        cursor.execute(update_dcm_sqL)
        code = 0
        msg = "编辑成功"
    except Exception as e:
        # 异常处理
        msg = "编辑失败"
        code = 1
        print (msg)		# 调试信息
    finally:
        # 关闭数据库连接
        cursor.close()
        conn_pgsql.commit( )
    return code, msg	# 返回结果
```

