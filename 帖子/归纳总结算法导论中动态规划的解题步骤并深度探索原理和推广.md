# 归纳总结算法导论中动态规划的解题步骤并深度探索原理和推广

[TOC]

## 1. 背景 

### 理论依据

算法导论动态规划章节的知识点和个人归纳总结与推广

### 例题描述(可跳过)

**01背包问题**

输入: $N$​ 个物品, 背包容量为 $V$​ , 物品 $i$​ 有体积 $v_i$​ , 价值 $w_i$​ , 每个物品可选 1 个或 0 个​

输出: 最大价值



### 动态规划概念理解   

 **面向的问题**: 通常都是**最优化问题**

> 最优化问题: 求一个问题的最值, 通常会有一些约束条件
>
> 如: 
>
>  $\max x^2$
>
>  $\text{ s.t. }  x\in[-1,1]$​​​   



对比部分可最后看

**与贪心算法对比**

1. 贪心算法也面向最优化问题
2. 贪心算法与动态规划都有**最优子结构性质**
3. 动态规划多了一个**重叠子问题性质**

**与分治法对比**

1. 分治法与动态规划都用到了**递归的思想**

   > 这里的递归我更愿意用数学上的递推来描述, 即用递推式表述分治法与动态规划中都有的**"用子问题的解组合为原问题的解/原问题的解分解为子问题的解"思想**
   >
   > 递推式即高中数列通项中 $a_n$​​​ 与 $a_{n-1}$​​, $a_{n-2}$​​​... 的递推公式, 如 $a_n = a_{n-1} + 1$​, $a_1 = 0$​
   >
   > 本文也将不会使用**状态转移方程**的说法

2. 分治法的划分会产生很多**新的子问题**, 动态规划的选择会产生很多**重复的子问题**, 即重叠子问题性质

## 2. 动态规划总览

### 数学模型

 $\max/\min f_总$​​​​​​​

$\text{ s.t. }  x\in D$​​​​​   

> 其实 $f_总$ 本身已经含有问题的最优解(最大值, 最小值)这一概念了

### 递归式

$f_原 = g(f_子), f_基 = init$

1. $f_原$ 表示原问题的最优解, 默认为一个值
2. $f_子$ 表示子问题的最优解, 默认为一到多个值, 即由多个子问题的最优解组成一个原问题的最优解

3. $g$​ 是子问题与原问题的函数关系, 一般为 $\max/\min\{分类讨论的所有情况/选择产生的所有情况\}$​ 

4. $f_基$​ 表示基础问题, 相当于递归的 base case 或数学归纳法的 base case, 由初始化给定值
5. 此递归式就是所谓的状态转移方程

### 设计动态规划算法的步骤

1. 刻画最优解的**结构特征**

   > 确定最优子结构

2. **递归定义**最优解

   > 写递推式

3. **自底向上计算**最优解

   > 或自顶向下备忘录计算最优解

4. **构造**最优解

   > 重建最优解的**解法**, 不单单是输出一个最大值/最小值, 而是输出通过哪些选择得到最值的, 一般的问题不要求输出构造最优解的过程

## 3. 解题步骤

**01背包问题**

输入: $n$​​ 个物品, 背包容量为 $v$​​ , 物品 $i$​​ 有体积 $v_i$​​ , 价值 $w_i$​​ , 每个物品可选 1 个或 0 个​

输出: 最大价值

### 步骤一 刻画最优解的结构特征(最最重要,唯一难点)

#### 1.1 先用递归方法暴力穷举所有情况

先用递归/贪心/分治的思想处理问题, 看看有哪些情况

这个过程不考虑约束条件, 或者说: 这个过程只是**粗略看一下递归的所有情况**, **不考虑细枝末节**

> 其实本质都是递归的思想, 只不过有时候是像贪心那样的**线性递归**, 有时候是像分治那样的**二分递归**

##### 1.1.1 计算所有情况个数

n 个物品, 每个物品可选 1 个或 0 个, 即每个物品有两种选择

显然, 总共有 $2^n$ 种情况

##### 1.1.2.尝试用递归的思想来描述问题间的关系

定义:

$f_i$​​ 表示仅考虑前 $i$​ 个物品时的最大价值

$f_{i-1}$​​ 表示仅考虑前 $i-1$​​ 个物品时的最大价值

$a_i$​ 表示仅考虑前 $i$​ 个物品时的情况个数

$a_{i-1}$ 表示仅考虑前 $i-1$ 个物品时的情况个数

> 假定背包容量无限大, 反正只是粗略看一下问题间的关系, 不考虑细枝末节

递归:

显然, 对每个物品来说有两种情况: 选 1 个或选 0 个

当问题规模为前 $i$​ 个物品的最大价值时, 只考虑第 $i$ 个物品的话有两种选择: 选 1 个或选 0 个

做出选择之后, 就要考虑剩下的 $i-1$ 个物品的最大价值问题了

即, $f_i = \max\{选1个后的 f_{i-1}, 选 0 个后的 f_{i-1}\}, f_0 = 0$​​ 

同样的, $a_n = 2a_{n-1}, a_0 = 1$​

> $f_0 = 0 表示前 0 个物品最大价值为 0$
>
> $a_0 = 1 表示前 0 个物品只有选 0 个这一种情况$

#### 1.2 寻找最优子结构

**最优子结构**:

​	**某问题**的最优解包含**其子问题**的最优解

**含义解释**:

1. 子问题的最优解**映射(构造/组成/得到)**为其原问题的最优解
2. **子问题**的最优解包含了**子子问题**的最优解, 直到遇到**基础解**
3. 子问题之间是**独立**的, 互不影响(**子问题无关性**)

**寻找最优子结构步骤**

##### 1.2.1 证明问题的最优解要通过做出一个选择来得到

对于前 $i$ 个物品的最大价值问题 $f_i$ ,

考虑到 $f_i$​ 为前 $i-1$ 个物品的最大价值,

我们可以对第 $i$​​ 个物品选择装入 $1$ 个或 $0$​ 个来得到两个不同的子问题 $f_{i-1}$​  

> 此时不考虑背包容量的影响, 因为背包容量是约束条件, 相当于是剪枝, 对于最优子结构无影响

对于任何一个规模的问题都可以做出这样的选择来得到其子问题,

即, 01背包问题的最优解**可以通过选择装入 $1$ 个或 $0$ 个当前物品来得到**, 两个选择会产生两个不同的子问题

##### 1.2.2 假定已知做出哪种选择会得到问题的最优解

假定 01 背包问题选择**装入 $k$​ 件**当前物品会得到最优解, $k\in\{0, 1\}$​

##### 1.2.3 得到最优选择后, 确定该选择会产生哪些子问题, 以及如何刻画合适的子问题空间

这一步的目的其实是**一般化展示**做出选择后**问题与子问题的通用关系式**

>  如果不太好确定通用的关系式, 可以把所有的选择和关系式都列出来

对于前 $i$ 个物品, 背包空间为 $j$ 的最大价值问题, 最优选择为选 $k$ 件第 $i$ 个物品, $k\in\{0, 1\}$

产生的子问题为前 $i-1$​​ 个物品, 背包容量为 $j - k\cdot v_i$​​​ 的最大价值

> 若第一时间想不出通用的关系式, 可以列出所有的选择的关系式
>
> 做出选 $1$ 件的选择: 
>
> ​	子问题为: 前 $i-1$ 个物品, 背包容量为 $j-v_i$​
>
> 做出选 0 件的选择:
>
> ​	 子问题为: 前 $i-1$ 个物品, 背包容量为 $j$

由于物品个数 $i$ 和背包容量 $j$ 都是在变化的, $i$ 变为 $i-1$, $j$ 变为 $j - k\cdot v_i$

所以**子问题空间要有两个维度**, 一个用来表示**物品个数的变化**, 一个用来表示**背包容量的变化**

即, **定义 $f(i, j)$​ 表示问题为前 $i$ 个物品, 背包容量为 $j$​​​ 的最大价值**

则在**最优选择**为 **选 $k$​​ 件** 的条件下, $f(i,j) = f(i-1,j-k\cdot v_i) + k \cdot w_i$

> 在 1.2.4 证明之后, 才能说 $f(i-1,j-k\cdot v_i)$​​ 的含义是
>
> 子问题前 $i-1$​​ 个物品, 背包容量为 $j - k\cdot v_i$​​​ 的最优解
>
> 此处 $f(i,j)$​ 的含义是问题的最优解, $f(i-1,j-k\cdot v_i)$​ 的含义是子问题的解

##### 1.2.4 反证法证明原问题的最优选择产生的子问题的解是子问题的最优解

> 所谓的剪切法本质上就是反证法

**反证法套路**: **假设**子问题的解**不是其最优解**, 则将子问题的**最优解带入**原问题的最优选择后会**产生**一个**更优**的解,

这与"**原问题做出最优选择后得到原问题的最优解**"的假设矛盾, **故子问题的解是最优解**

假设 $f(i-1,j-k\cdot v_i)$ 不是子问题 $(i-1,j-k\cdot v_i)$​ 的最优解

则将其最优解带入 $f(i,j) = f(i-1,j-k\cdot v_i) + k \cdot w_i$ 后, $f(i, j)$ 会变得更优, 产生矛盾

所以 $f(i-1,j-k\cdot v_i)$ 是子问题 $(i-1,j-k\cdot v_i)$ 的最优解

即问题$(i, j)$ 做出最优选择后的子问题 $(i-1,j-k\cdot v_i)$​ 的解是其最优解

公式 $f(i,j) = f(i-1,j-k\cdot v_i) + k \cdot w_i$ 里面都是对应问题的最优解​

