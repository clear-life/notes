# 广度优先搜索算法的数学证明

[TOC]

> 说明
>
> 1. 本文主要使用算法导论上的证明
> 2. 不过并没有完全照搬算法导论的证明, 因为算法导论的证明书面话较多
> 3. 而且有些关键地方可能是故意没写(估计是嫌麻烦), 不太严谨
> 4. 本文尝试用严谨的数学方法对算法导论的证明进行重构

## 一. 准备工作

**邻接链表**

对于任意图 G = (V, E) 的某个节点 u

Adj[u] 表示节点 u 的邻接节点组成的一个链表

**图的属性**

对于任意图 G = (V, E) 的某个节点 u

u.d 表示从源节点 s 到节点 u 的距离

**最短路径**

对于任意图 G = (V, E) 的某两个节点 u, v

u 到 v 的最短路径为 u 到 v 的路径中边数最短的路径

**最短路径距离**为 
$$
δ(u, v) = \mathop{\min}_{边数} \{u \rightarrow \cdots \rightarrow v\}
$$

> 若 u 到 v 没有路径, 则 $δ(u, v) = \infty$



## 二. 证明思路

**大体思路**

算法以源节点 s 为中心, 以广度优先的策略向四周探索节点, 直到探索完所有节点为止

**广度优先搜索算法的详细思路**

算法将节点分为三类

* 未探索的节点, 用白色表示
* 已探索的节点, 用黑色表示
* 边界节点(其实就是加入到队列里的节点), 用灰色表示

算法的核心代码依次重复执行下列操作

1. 从队列中取出节点 u
2. 扫描 Adj[u]
   * 对于扫描到的白色节点 v, v 设为灰色, v.d = u.d + 1 后加入队列
   * 扫描到灰色或黑色节点就跳过, 不进行任何操作
3. u 设为黑色

**伪代码**

```C++
BFS(G, s)
    初始化
    s.color = 灰色
    s.d = 无穷大
    s.π = NIL
    
    for u in G.V - {s}
		u.color = 白色
        u.d = 无穷大
        u.π = NIL		// 一般用不到, 构建广度优先搜索树的时候会用到, 需要构建从 s 到某一结点的最短路径时也会用到
    
    Q = ф
    s 入队
            
    while Q != ф
        u = Q 出队元素
        
        for v in G.Adj[u]
            if v.color == 白色
                v.color = 灰色
                v.d = u.d + 1
                v.π = u
                v 入队
        
        u.color = 黑色
```

**证明思路**

证明的方法主要是**数学归纳法**和**反证法**

* 引理 1 证明所有图都有的一个性质: 图的三角不等式

* 引理 2 证明 BFS 中结点的 v.d 是 δ(s, v) 的上界(其实这个显而易见, 但还是需要证明)

* 引理 3 证明队列 Q 中的元素的 d 属性差小于等于 1 且不降排序(即小于等于排序), 即 Q 中的元素的距离差小于等于 1, 且距离不降排序

* 推论 4 使用了引理 3 做了一点显而易见的扩展

* 定理 5 使用前面的结论真正证明 BFS 算法能够计算出所有结点到源节点 s 的最短距离

## 三. 证明

**终极目标**

BFS 算法能够正确计算最短路径的距离

即算法结束时, 对所有结点, v.d = δ(s, v)

