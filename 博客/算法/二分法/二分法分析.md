# 二分法分析

## 引入

### 分析

**问题**: 有一根导线, 某处有一断点, 快速找出断点所在区域.

**二分法**: 从导线中点向两端测试能否通电, 不能导通的区域为新的**"导线"**, 循环往复直至满足要求

**二分性质: true or false**

导线被断点分为两个不同部分, 用 true 和 false 表示, **函数`bool check(点)`**返回点所在区域

**check函数**

true/false 含义与 check 函数设计有关

`{ 1, 2, 3, 4, 5 }`  

`check(x) = { return x >= 3; }` 则 false 表 `{1, 2}`  true 表 `{3, 4, 5}`

`check(x) = { return x < 3; }` 则 true 表 `{1, 2}`  false 表 `{3, 4, 5}`

### 实数二分模板

```C++
double l, r;

while(abs(r - l) > ε)
{
	double mid = (l + r) / 2;
    if (check(mid)) r = mid;	// 右侧 true	
    else l = mid;
}

while(abs(r - l) > ε)
{
	double mid = (l + r) / 2;
    if (check(mid)) l = mid;	// 左侧 true
    else r = mid;
}
```

## 整数二分

### **模板**

**右分界点 右 true**

```C++
int l, r;
while(l < r)
{
	int mid = l + r >> 1;
    if(check(mid)) r = mid;
    else l = mid + 1;
}
```

**左分界点 左 true**

```C++
int l, r;
while(l < r)
{
	int mid = l + r + 1 >> 1;
    if(check(mid)) l = mid;
    else r = mid - 1;
}
```

整数二分要注意**分界点和取整**两个问题

### 分界点

 `{ 1, 2, 3, 4, 5, 6}` 若被二分性质分为两个区域 `{1, 2, 3}` 和 `{4, 5, 6}`

则 3 和 4 都是分界点, 称为**左右分界点**, 分界点所在区域定为 `true` 能简化模板, 有利于记忆

**左分界点 3  则 {1, 2, 3} 为  `true`**

**右分界点 4  则 {4, 5, 6} 为  `true`**

**二分结果左右分界点都  `true` 二分结果会尽可能向 `true` 分界点靠拢**

### 更新

`{1, 2, ..., x } { x + 1, ..., n}`

**左分界点 左 true**

`check(mid) = true` 则左分界点在 `[mid, r]` 极限情况 `mid = x`

`check(mid) = false` 则左分界点在 `[l, mid)` 极限情况 `mid = x + 1`

更新:

```C++
if check(mid)
    l = mid
else
    r = mid - 1
```

**右分界点 右 yes**

`check(mid) = true` 则右分界点在 `[l, mid]` 极限情况 `mid = x + 1`

`check(mid) = false` 则右分界点在 `(mid, r]` 极限情况 `mid = x`

更新:

```C++
if check(mid)
    r = mid
else
    l = mid + 1
```

### 取整

更新公式确定后, 为避免死循环, `mid` 的取整情况也随之确定

极限情况 `{1} {2}`

**左分界点 左 true**

由于分支 `l = mid`, 则 `mid` 需向上取整, 否则陷入死循环 `l = 1, r = 2`

**右分界点 右 true**

由于分支 `r = mid`, 则 `mid` 需向下取整, 否则陷入死循环 `l = 1, r = 2`

