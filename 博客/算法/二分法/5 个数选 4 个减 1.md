# 5 个数选 4 个减 1

给定 5 个自然数, 每次操作选 4 个数减 1, 求最大操作次数

## 思路 

### 1. 暴力思路

每次选最大的 4 个数减 1

**算法:**

每一轮循环的操作是这样的:

1. 对 5 个数排序
2. 选最大的 4 的数减 1

直到有至少 2 个数为 0 时才停止循环

**分析:**

暴力做法, 时间复杂度为$O(n)$, 大的数据会超时

### 2. 数学思路

设 5 个数从小到大为 $a, b, c, d, e$

先把最小的数减到 0, 然后加上剩余 4 个数的最小值

最小的数减到 0 需要让剩余 4 个数的最小值达到最大才能使操作次数最大

> 为什么先把最小的数减到 0 ?
>
> 因为最小的数一定会减到 0, 假定经过最大操作次数后, 最小的数不为 0, 说明还能操作, 产生矛盾

-----

问题变成了对 $b, c, d, e$ 四个数操作 $a$ 次后使最小的数最大, 即 **$\max \limits_{操作 a 次} \min \{b,c,d,e\}$**

> a 加上剩余四个数的最小值就是答案

先证明一个结论: **$b$ 永远是 4 个数中的最小值**

**情况一:** 有 0 个数和 b 相等

那么对最大的三个数 $c,d,e$ 减 1 后, b 依然是最小的数

**情况二:** 有 1 个数和 b 相等

假定 4 个数为 $b, b, x, y$, 其中 $x,y$ 大于 $b$, 则选择 $b,x,y$ 减 1 后, b 依然是最小的数

同理, 可以说明当有 2 个或 3 个数和 b 相等时, b 依然是最小的数

$\therefore$ 以最大化最小值的思路对 $b,c,d,e$ 4 个数操作时, **$b$ 永远是 4 个数中的最小值**

----

**具体如何操作, 才能经过 a 次操作后, 最大化 4 个数的最小值 ?**

**思路:**

先把操作的对象都对准 $c,d,e$, 此操作可能使得 $c,d,e$ 小于 b, 然后用 b 填补这三个数, 使得这三个数的值不小于 b(减去填补值后的 b)

例:

$b$ = 5, $c,d,e$ 为 $2,2,4$

b 拿出 1 来补偿最小的 c, 4 个数变为: b = 4, c,d,e 为 3, 2, 4, 不满足条件

b 拿出 2 来补偿最小的 c, d, 4 个数变为: b = 3, c, d, e 为 3, 3, 4, 刚好满足条件

$\therefore$ b = 5, c, d, e 为 2, 2, 4 的情况下, b 最大为 3

**填补的方法**

查找 b 的最大值的方法是**二分查找**

假定 b 的最大值为 k, 则 k + 1 一定不满足条件, k - 1 情况下 b 一定能填补剩余三个数, 使得这三个数不小于 b

> b 需要拿出 b - k 的大小来填补剩余三个数, 所以 k 越大, b 的损失越小, 最终最小值 b 一定会最大

**代码实现**

```C++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e9 + 10;

int a[5];

int res = 0;

bool check(int k)
{
    int n = a[1] - k;

    for(int i = 2; i <= 4; i++)
    {
        if(a[i] >= k) return true;
        n -= (k - a[i]);
        if(n < 0) return false;
    }
    
    return true;
}

int main()
{
    for(int i = 0; i < 5; i++) cin >> a[i];
    
    sort(a, a + 5);
    
    res += a[0];
    
    for(int i = 2; i <= 4; i++) a[i] -= a[0];
    
    
    int l = a[1] - a[0], r = a[1];

    while(l < r)
    {
        int mid = l + r + 1 >> 1;

        if(check(mid)) l = mid;
        else r = mid - 1;
    }

    res += l;
    
    cout << res << endl;
    
    return 0;
}

```

