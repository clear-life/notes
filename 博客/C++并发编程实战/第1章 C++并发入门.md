# 第1章 C++并发入门

## 本章内容

-   什么是**并发**和**多线程**
-   为什么要用**并发**和**多线程**
-   **C++ 与并发**

## 1. 什么是并发

### 概念

并发: 多个任务**同时且独立运行**
* **任务并发**: 用任务切换实现，实质上同一时刻只能运行一个任务

  > 上下文切换: 保存当前 CPU 状态和程序计数器 PC，加载新任务的 CPU 状态和 PC
* **硬件并发**: 多个 CPU / 多核 CPU

  > 硬件并发真正并行运行多个任务
  > CPU = 控制单元 + 运算单元 ALU + 存储单元
  > 1个核(core) = 1个控制单元 + 1个运算单元 ALU

### 并发方式

多进程与多线程

**进程**

资源分配的基本单位

**线程**

调度的基本单位

**协程**

**轻量级线程**, 相当于线程中的某个函数

**进程与线程**

内存空间

* 进程间独立内存空间

* 线程**共享进程堆空间, 独占线程栈空间**

资源

* 进程间资源独立, 有利于资源管理和保护
* 线程**共享进程的资源如内存, IO, CPU**, **不利于资源管理和保护**

并发

* 进程并发程度低
* 线程并发程度高

通信

* 进程间**通信复杂, 速度慢**
* 线程间通信简单, 速度快

开销

* 进程启动慢, 耗费资源多, 进程切换开销大, 操作系统保护措施开销大
* 线程**启动快, 耗费资源少, 线程切换开销小**, 操作系统保护措施开销小

**线程与协程**

切换

* 线程切换由操作系统调度
* 协程切换由程序员调度

开销

* 线程开销大, 由操作系统创建并管理, 需要在内核态进行上下文切换

* 协程开销小, 由程序员创建并管理, 在用户态进行上下文切换

  > 协程被称作用户态线程, 不涉及系统调用, 不需要来自操作系统的支持

### 并发与并行

本质一样

> 通常来说, 并发指**时间段**, 并行指**时间点**, 但可以都看作并发

-   并发侧重**性能提升**
-   并行侧重**关注点分离**或**响应能力**

## 2. 为什么用并发

**分离关注点**与**性能提升**

### 分离关注点

归类相关代码, 隔离无关代码

> 不需要将两个不同部分的代码混杂在一起

例: 游戏程序中, 一个线程只负责**界面管理**, 一个线程只负责 **`gameplay`**

### 性能提升

**任务并行**

任务分解为多个部分, 并行执行

```C++
任务:
{
    a
    b
    c
}
a b c 并行执行
```

**数据并行**

同一算法处理多份数据, 并行处理

```C++
数据 a b c
同一算法并行处理数据 a b c
```

### 并发的代价

-   编写和维护难, 开发周期长

-   消耗系统资源如内存, IO, CPU

-   线程切换开销

## 3. C++ 与并发

### 新标准

- 规定内存模型

  > 处理器硬件架构对性能的影响, 不同平台下编辑器的行为
- 线程管理
- 锁
- 线程同步
- 原子操作
- 并行算法函数

### STD 线程库效率

* 抽象损失小
* 提供内存模型和原子操作库, 可**跨平台深入底层**
* 提供成员函数 `native_handle()`, 允许运行平台专属 API

## 4. C++ 并发入门

`std::thread t(fun);` 启动并管理线程, 线程执行 `fun` 函数

```
#include <iostream>
#include <thread>

void fun()
{
    std::cout << "Hello Concurrent World!" << std::endl;
}

int main()
{
    std::thread t(fun);
    t.join();	// t.join() 等待线程执行完
}
```
