# 第3章 线程共享数据

## 本章内容

* 线程间访问共享数据的问题
* 利用互斥保护共享数据
* 其他方法保护共享数据

## 1. 线程间共享数据的问题

### 不变量

**对数据的断言**

> 类似于循环不变式, 数列通项

**问题**

当**代码段 A** 对**共享数据 D** 以**不变量 V** 为**假设**处理时

* 若不变量 V 满足, 就正确处理
* 若不变量 V 并未满足, 就出问题

```C++
// A:
{
    process(D);		// 以不变量 V 满足为前提处理
}
```

**例:**

不变量: 双向链表中, 若 $A \rightarrow B$, 则 $B \rightarrow A$

操作: 删除双向链表的一个结点

```C++
void delete(Node n)
{
    						// 不变量满足
    n->pre->next = n->next;	// 不变量不满足, 若以不变量满足为前提访问该双向链表, 会出问题 
    n->next->pre = n->pre; 	// 不变量再次满足
}
```

### 条件竞争

多个线程, 各自的操作序列混杂为一个操作序列, 若结果取决于相对次序, 称为**条件竞争**

**场景**

线程 A 有操作序列: a1  a2

线程 B 有操作序列: b1  b2

混杂为一个操作序列有 6 种情况:

* a1  a2  b1  b2
* a1  b1  a2  b2
* a1  b1  b2  a2
* b1  a1  a2  b2
* b1  a1  b2  a2
* b1  b2  a1  a2

**问题**

线程 A 的 a1 执行之后, a2 开始之前, 不变量 V 被破坏

线程 B 的 b1  b2 都以不变量 V 满足为前提

则第 2, 3, 5 三种情况都在 V 不满足时访问 V

第 1, 4, 6 三种情况在 V 满足时访问 V

> 1, 4, 6, 相当于加了锁

有 50% 的情况出问题, 50% 的情况不出问题

> 2  a1  b1  a2  b2
>
> 3  a1  b1  b2  a2
>
> 5  b1  a1  b2  a2

### 防止恶性条件竞争

> 恶性条件竞争: 出问题时的条件竞争

* 用互斥保护共享数据: 有锁编程
* 修改数据结构的设计: 无锁编程
* 用事物来处理: 操作序列视为原子操作

