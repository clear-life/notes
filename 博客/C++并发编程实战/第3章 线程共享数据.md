# 第3章 线程共享数据

## 本章内容

* 线程间访问共享数据的问题
* 利用互斥保护共享数据
* 其他方法保护共享数据

## 线程间共享数据的问题

### 不变量

**对数据的断言**

> 类似于循环不变式, 数列通项

**问题**

当**代码段 A** 对**共享数据 D** 以**不变量 V** 为**假设**处理时

* 若不变量 V 满足, 就正确处理
* 若不变量 V 并未满足, 就出问题

```C++
// A:
{
    process(D);		// 以不变量 V 满足为前提处理
}
```

**例:**

不变量: 双向链表中, 若 $A \rightarrow B$, 则 $B \rightarrow A$

操作: 删除双向链表的一个结点

```C++
void delete(Node n)
{
    						// 不变量满足
    n->pre->next = n->next;	// 不变量不满足, 若以不变量满足为前提访问该双向链表, 会出问题 
    n->next->pre = n->pre; 	// 不变量再次满足
}
```

### 条件竞争

多个线程, 各自的操作序列混杂为一个操作序列, 若结果取决于相对次序, 称为**条件竞争**

**场景**

线程 A 有操作序列: a1  a2

线程 B 有操作序列: b1  b2

混杂为一个操作序列有 6 种情况:

* a1  a2  b1  b2
* a1  b1  a2  b2
* a1  b1  b2  a2
* b1  a1  a2  b2
* b1  a1  b2  a2
* b1  b2  a1  a2

**问题**

线程 A 的 a1 执行之后, a2 开始之前, 不变量 V 被破坏

线程 B 的 b1  b2 都以不变量 V 满足为前提

则第 2, 3, 5 三种情况都在 V 不满足时访问 V

第 1, 4, 6 三种情况在 V 满足时访问 V

> 1, 4, 6, 相当于加了锁

有 50% 的情况出问题, 50% 的情况不出问题

> 2  a1  b1  a2  b2
>
> 3  a1  b1  b2  a2
>
> 5  b1  a1  b2  a2

### 防止恶性条件竞争

> 恶性条件竞争: 出问题时的条件竞争

* 用互斥保护共享数据: 有锁编程
* 修改数据结构的设计: 无锁编程
* 用事物来处理: 操作序列视为原子操作

# 互斥保护共享数据

## mutex 源码

```C++
class mutex : public _Mutex_base 
{ 
public:
    mutex(): _Mutex_base() {}

    mutex(const mutex&) = delete;
    mutex& operator=(const mutex&) = delete;
};

class mutex_base 
{ // base class for all mutex types
public:
    mutex_base(int flag = 0)  
    {
        _Mtx_init_in_situ(mymtx(), flag | mtx_try);
    }

    ~mutex_base()  
    {
        _Mtx_destroy_in_situ(mymtx());
    }

    mutex_base(const mutex_base&) = delete;
    mutex_base& operator=(const mutex_base&) = delete;

    void lock() 
    {
        _Check_C_return(_Mtx_lock(mymtx()));
    }

    bool try_lock() 
    {
        const auto res = _Mtx_trylock(mymtx());
        
        switch (res) 
        {
        case _Thrd_success:
            return true;
        case _Thrd_busy:
            return false;
        default:
            _Throw_C_error(res);
        }
    }

    void unlock() 
    {
        _Mtx_unlock(mymtx());
    }

private:
    struct mtx_storage;

    void* mymtx()  
    {
        return reinterpret_cast<void*>(&mtx_storage);
    }
};
```

## mutex 操作

## 加锁解锁

### 1. mutex

```C++
{
    mutex m;
    
    m.lock();
    ...
    m.unlock();
}
```

### 2. lock_guard<>

```C++
{
    mutex m;
    
    lock_guard<mutex> l(m);
    ...
}
```

**lock_guard 源码**

```C++
template <class mutex>
class lock_guard 
{ 
public:
    lock_guard(mutex& mtx) : m(mtx)   
    {
        m.lock();
    }
    lock_guard(mutex& mtx, adopt_lock_t) : m(mtx) {}

    ~lock_guard() 
    {
        m.unlock();
    }

    lock_guard(const lock_guard&) = delete;
    lock_guard& operator=(const lock_guard&) = delete;

private:
    mutex& m;
};
```

### 3. unique_lock<>

```C++
std::mutex m;

std::unique_lock<std::mutex> l(m);					// lock
std::unique_lock<std::mutex> l(m, std::adopt_lock);	// 假定已 lock
std::unique_lock<std::mutex> l(m, std::defer_lock);	// 不 lock
std::unique_lock<std::mutex> l(m, std::try_to_lock);// try_lock
```

**unique_lock<> 支持移动操作**

```C++
mutex m;
unique_lock<mutex> u1(m);
unique_lock<mutex> u2 = move(u1);
```

**unique_lock<> 源码**

```C++
class unique_lock 
{
public:
    unique_lock(): pmtx(nullptr), own(false) {}

    unique_lock(_Mutex& mtx): pmtx(std::addressof(mtx)), own(false) 
    { 
        pmtx->lock();
        own = true;
    }

    unique_lock(_Mutex& mtx, adopt_lock_t): pmtx(std::addressof(mtx)), own(true) {}

    unique_lock(_Mutex& mtx, defer_lock_t): pmtx(std::addressof(mtx)), own(false) {}

    unique_lock(_Mutex& mtx, try_to_lock_t): pmtx(std::addressof(mtx)), own(pmtx->try_lock()) {}

    // 时间段和时间点
    template <class _Rep, class _Period>
    unique_lock(_Mutex& mtx, const chrono::duration<_Rep, _Period>& rel_time)
        : pmtx(std::addressof(mtx)), own(pmtx->try_lock_for(rel_time)) {}

    template <class _Clock, class _Duration>
    unique_lock(_Mutex& mtx, const chrono::time_point<_Clock, _Duration>& abs_time)
        : pmtx(std::addressof(mtx)), own(pmtx->try_lock_until(abs_time)) {}


    // 移动操作
    unique_lock(unique_lock&& other): pmtx(other.pmtx), own(other.own) 
    {
        other.pmtx = nullptr;
        other.own = false;
    }

    unique_lock& operator=(unique_lock&& other) 
    {
        if (this != std::addressof(other)) 
        {
            if (own) 
            {
                pmtx->unlock();
            }

            pmtx        = other.pmtx;
            own         = other.own;
            other.pmtx  = nullptr;
            other.own   = false;
        }
        return *this;
    }

    ~unique_lock()  
    {
        if (own) 
        {
            pmtx->unlock();
        }
    }

    unique_lock(const unique_lock&) = delete;
    unique_lock& operator=(const unique_lock&) = delete;

    void lock() 
    { 
        check();
        pmtx->lock();
        own = true;
    }

    bool try_lock() 
    {
        check();
        own = pmtx->try_lock();
        return own;
    }

    template <class _Rep, class _Period>
    bool try_lock_for(const chrono::duration<_Rep, _Period>& rel_time) 
    {
        check();
        own = pmtx->try_lock_for(rel_time);
        return own;
    }

    template <class _Clock, class _Duration>
    bool try_lock_until(const chrono::time_point<_Clock, _Duration>& abs_time) 
    {
        check();
        own = pmtx->try_lock_until(abs_time);
        return own;
    }

    void unlock() 
    {
        if (!pmtx || !own) 
        {
            _Throw_system_error(errc::operation_not_permitted);
        }

        pmtx->unlock();
        own = false;
    }

    void swap(unique_lock& other)  
    {
        std::swap(pmtx, other.pmtx);
        std::swap(own, other.own);
    }

    _Mutex* release()  
    {
        _Mutex* res = pmtx;
        pmtx        = nullptr;
        own         = false;
        return res;
    }

    bool owns_lock() const  
    {
        return own;
    }

    operator bool() const  
    {
        return own;
    }

    _Mutex* mutex() const  
    {
        return pmtx;
    }

private:
    _Mutex* pmtx;   // 指向管理的 mutex
    bool own;       // 是否拥有互斥

    void check() const 
    { 	// 检测能否 lock
        if (!pmtx) 
        {
            _Throw_system_error(errc::operation_not_permitted);
        }

        if (own) 
        {
            _Throw_system_error(errc::resource_deadlock_would_occur);
        }
    }
};
```

### 4. lock()

一次性锁住多个互斥, 要么全部加锁, 要么全部未加锁

* 不发生死锁
* 仍需自己解锁

```C++
void fun(T &l, T &r)
{
    lock(l.m, r.m);		// 一次性锁住 l 和 r 的互斥量
    lock_guard<mutex> lock_l(l.m, adopt_lock);
    lock_guard<mutex> lock_r(r.m, adopt_lock);

    ...
}
```

**lock() 源码**

```C++
template <class lock0, class lock1, class... lockN>
void lock(lock0& lk0, lock1& lk1, lockN&... lkN) 
{
    _Lock_nonmember1(lk0, lk1, lkN...);
}
```

### 5. scoped_lock<>

`std::lock()` 与 `std::lock_guard<>` 的结合版

一次性锁住所有互斥量, 并析构时解锁

```C++
void fun(T &l, T &r)
{
    scoped_lock guard(l.m, r.m);

    ...
}
```

**scoped_lock<> 源码**

```C++
template <class... _Mutexes>
class scoped_lock 
{ 
public:
    scoped_lock(_Mutexes&... mtxes) : my_mtxes(mtxes...) 
    { 
        lock(mtxes...);
    }

    scoped_lock(adopt_lock_t, _Mutexes&... mtxes) : my_mtxes(mtxes...) {} 

    ~scoped_lock() 
    {
        apply([](_Mutexes&... mtxes) { (..., (void) mtxes.unlock()); }, my_mtxes);
    }

    scoped_lock(const scoped_lock&) = delete;
    scoped_lock& operator=(const scoped_lock&) = delete;

private:
    tuple<_Mutexes&...> my_mtxes;
};
```

