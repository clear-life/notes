# 第3章 线程共享数据

## 本章内容

* 线程间访问共享数据的问题
* 利用互斥保护共享数据
* 其他方法保护共享数据

## 1. 线程间共享数据的问题

### 不变量

**对数据的断言**

> 类似于循环不变式, 数列通项

**问题**

当**代码段 A** 对**共享数据 D** 以**不变量 V** 为**假设**处理时

* 若不变量 V 满足, 就正确处理
* 若不变量 V 并未满足, 就出问题

```C++
// A:
{
    process(D);		// 以不变量 V 满足为前提处理
}
```

**例:**

不变量: 双向链表中, 若 $A \rightarrow B$, 则 $B \rightarrow A$

操作: 删除双向链表的一个结点

```C++
void delete(Node n)
{
    						// 不变量满足
    n->pre->next = n->next;	// 不变量不满足, 若以不变量满足为前提访问该双向链表, 会出问题 
    n->next->pre = n->pre; 	// 不变量再次满足
}
```

### 条件竞争

多个线程, 各自的操作序列混杂为一个操作序列, 若结果取决于相对次序, 称为**条件竞争**

**场景**

线程 A 有操作序列: a1  a2

线程 B 有操作序列: b1  b2

混杂为一个操作序列有 6 种情况:

* a1  a2  b1  b2
* a1  b1  a2  b2
* a1  b1  b2  a2
* b1  a1  a2  b2
* b1  a1  b2  a2
* b1  b2  a1  a2

**问题**

线程 A 的 a1 执行之后, a2 开始之前, 不变量 V 被破坏

线程 B 的 b1  b2 都以不变量 V 满足为前提

则第 2, 3, 5 三种情况都在 V 不满足时访问 V

第 1, 4, 6 三种情况在 V 满足时访问 V

> 1, 4, 6, 相当于加了锁

有 50% 的情况出问题, 50% 的情况不出问题

> 2  a1  b1  a2  b2
>
> 3  a1  b1  b2  a2
>
> 5  b1  a1  b2  a2

### 防止恶性条件竞争

> 恶性条件竞争: 出问题时的条件竞争

* 用互斥保护共享数据: 有锁编程
* 修改数据结构的设计: 无锁编程
* 用事物来处理: 操作序列视为原子操作

## 2. 互斥保护共享数据

### mutex 源码

```C++
class mutex : public _Mutex_base 
{ 
public:
    mutex(): _Mutex_base() {}

    mutex(const mutex&) = delete;
    mutex& operator=(const mutex&) = delete;
};

class mutex_base 
{ // base class for all mutex types
public:
    mutex_base(int flag = 0)  
    {
        _Mtx_init_in_situ(mymtx(), flag | mtx_try);
    }

    ~mutex_base()  
    {
        _Mtx_destroy_in_situ(mymtx());
    }

    mutex_base(const mutex_base&) = delete;
    mutex_base& operator=(const mutex_base&) = delete;

    void lock() 
    {
        _Check_C_return(_Mtx_lock(mymtx()));
    }

    bool try_lock() 
    {
        const auto res = _Mtx_trylock(mymtx());
        
        switch (res) 
        {
        case _Thrd_success:
            return true;
        case _Thrd_busy:
            return false;
        default:
            _Throw_C_error(res);
        }
    }

    void unlock() 
    {
        _Mtx_unlock(mymtx());
    }

private:
    struct mtx_storage;

    void* mymtx()  
    {
        return reinterpret_cast<void*>(&mtx_storage);
    }
};
```

### mutex 操作

### 加锁解锁

**1. mutex**

```C++
{
    mutex m;
    
    m.lock();
    ...
    m.unlock();
}
```

**2. lock_guard<>**

```C++
{
    mutex m;
    
    lock_guard<mutex> l(m);
    ...
}
```

**lock_guard 源码**

```C++
template <class mutex>
class lock_guard 
{ 
public:
    lock_guard(mutex& mtx) : m(mtx)   
    {
        m.lock();
    }
    lock_guard(mutex& mtx, adopt_lock_t) : m(mtx) {}

    ~lock_guard() 
    {
        m.unlock();
    }

    lock_guard(const lock_guard&) = delete;
    lock_guard& operator=(const lock_guard&) = delete;

private:
    mutex& m;
};
```

**3. unique_lock<>**

```C++
std::mutex m;

std::unique_lock<std::mutex> l(m);					// lock
std::unique_lock<std::mutex> l(m, std::adopt_lock);	// 假定已 lock
std::unique_lock<std::mutex> l(m, std::defer_lock);	// 不 lock
std::unique_lock<std::mutex> l(m, std::try_to_lock);// try_lock
```

**unique_lock 源码**

```C++
```

