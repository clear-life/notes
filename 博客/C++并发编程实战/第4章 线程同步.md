# 第4章 线程同步

## 本章内容

* 条件变量
* future 等待一次性事件的发生
* async()
* promise<>
* package_task<>
* shared_future
* 时间类

## 条件变量

### 概念

条件变量是特殊的信号量, `wait` 相当于 P 操作, `notice` 相当于 V 操作

条件变量有两种:

* **condition_variable** 只与 **mutex** 配合使用
* **condition_variable_any** 可与任何互斥配合使用

### 源码

**condition_variable**

```C++
class condition_variable 
{ 
public:
    condition_variable() 
    {
        _Cnd_init_in_situ(mycnd());
    }

    ~condition_variable() 
    {
        _Cnd_destroy_in_situ(mycnd());
    }

    condition_variable(const condition_variable&) = delete;
    condition_variable& operator=(const condition_variable&) = delete;

    // V 操作
    void notify_one() 
    {   
        _Cnd_signal(mycnd());
    }

    void notify_all() 
    {   
        _Cnd_broadcast(mycnd());
    }

    // P 操作
    void wait(unique_lock<mutex>& lck) 
    {   
        _Cnd_wait(mycnd(), lck.mutex()->mymtx());
    }

    template <class Func>
    void wait(unique_lock<mutex>& lck, Func func) 
    {   // 除了要有 V 操作(signal), 对应的条件也得满足
        while (!func()) 
        {
            wait(lck);
        }
    }


    // 时间段
    template <class _Rep, class _Period>
    int wait_for(unique_lock<mutex>& lck, const chrono::duration<_Rep, _Period>& rel_time) {}

    template <class _Rep, class _Period, class Func>
    bool wait_for(unique_lock<mutex>& lck, const chrono::duration<_Rep, _Period>& rel_time, Func func) {}


    // 时间点
    template <class _Clock, class _Duration>
    int wait_until(unique_lock<mutex>& lck, const chrono::time_point<_Clock, _Duration>& abs_time) {}

    template <class _Clock, class _Duration, class Func>
    bool wait_until(unique_lock<mutex>& lck, const chrono::time_point<_Clock, _Duration>& abs_time, Func func) {}

private:
    struct cnd_storage;

    void* mycnd() 
    {  
        return reinterpret_cast<void*>(&cnd_storage);
    }
};
```

**condition_variable_any**

```C++
class condition_variable_any 
{  
public:
    condition_variable_any() : myptr{make_shared<mutex>()} 
    {
        _Cnd_init_in_situ(mycnd());
    }

    ~condition_variable_any() 
    {
        _Cnd_destroy_in_situ(mycnd());
    }

    condition_variable_any(const condition_variable_any&) = delete;
    condition_variable_any& operator=(const condition_variable_any&) = delete;

    // V 操作
    void notify_one() 
    { 
        lock_guard<mutex> guard{*myptr};
        _Cnd_signal(mycnd());
    }

    void notify_all() 
    { 
        lock_guard<mutex> guard{*myptr};
        _Cnd_broadcast(mycnd());
    }

    // P 操作
    template <class Lock>
    void wait(Lock& lck) 
    { 
        const shared_ptr<mutex> p = myptr; // for immunity to *this destruction

        unique_lock<mutex> guard{*p};
        lck.unlock();
        _Cnd_wait(mycnd(), p->mymtx());		// 真正的 P 操作
        guard.unlock();
        lck.lock();							// 生产者消费者模型, 临界区的互斥访问加锁
    } 

    template <class Lock, class Func>
    void wait(Lock& lck, Func func)
    {
        while (!static_cast<bool>(func())) 
        {
            wait(lck);
        }
    }

    template <class Lock, class _Clock, class _Duration>
    int wait_until(Lock& lck, const chrono::time_point<_Clock, _Duration>& abs_time) {}
    template <class Lock, class _Clock, class _Duration, class Func>
    bool wait_until(Lock& lck, const chrono::time_point<_Clock, _Duration>& abs_time, Func func) {}

    template <class Lock, class _Rep, class _Period>
    int wait_for(Lock& lck, const chrono::duration<_Rep, _Period>& rel_time) {}
    template <class Lock, class _Rep, class _Period, class Func>
    bool wait_for(Lock& lck, const chrono::duration<_Rep, _Period>& rel_time, Func func) {}

private:
    shared_ptr<mutex> myptr;

    struct cnd_storage;

    void* mycnd() 
    { 
        return reinterpret_cast<void*>(&cnd_storage);
    }
};
```

### 成员函数

**wait**

相当于 P 操作

```C++
void wait(unique_lock<mutex>& l)
{
    l.unlock();
    P();
    l.lock();
}

void wait(unique_lock<mutex>& l, Func func)
{
    while(!func())
    {
        wait(l);
    }
}
```

**notify_one 和 notify_all**

相当于 V 操作, 唤醒等待队列的线程

> 如果等待队列为空, 就结束, 有可能导致错过 wait
>
> 即: 
>
> 先进行 notify_one 操作, 发现等待队列为空, 就结束
>
> 再进行 wait 操作把当前线程加入等待队列等待唤醒, 然后永远等不到 notify_one

```C++
void notify_one() 
{ 
    _Cnd_signal(mycnd());	// 唤醒一个
}

void notify_all() 
{ 
    _Cnd_broadcast(mycnd());// 唤醒所有
}
```

### 使用

```C++
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

using namespace std;

mutex m;
condition_variable cnd;

int x;

void A()
{
    x = 1;

    cnd.notify_one();		// V 操作
}

void B()
{
    unique_lock<mutex> l(m);// 加锁
    cnd.wait(l, [] {return x == 1; });			// 先进行 P 操作, 再解锁加锁
    l.unlock();				// 解锁

    cout << x << endl;
}

int main()
{
    thread t2(B);
    thread t1(A);

    t2.join();
    t1.join();
}
```

**类比信号量实现线程同步**

```C++
A:
{
    ...
    V(s);		// cnd.notify_one();
}

B:
{
    P(s);		// cnd.wait(l);
    ...
}
```

### 唤醒丢失

正常顺序: A B

B 等待 A 的信号

* 若 A 先执行, 发出了信号, 但 B 还没开始, 错过了 A 的信号, B 就永远等不到 A 的信号了
* 若 B 先执行, 由于需要等待 A 的信号, 所以加入等待队列, 然后 A 执行, 发出信号, 唤醒 B, 正常执行

```C++
A:
{
    ...
    notify_one();	// 发出信号, 而不是设置状态		
}

B:
{
    wait();			// 等待信号
    ...
}

唤醒丢失: 	
notify_one();		// 发出信号
wait();				// 加入队列后等待信号
```

