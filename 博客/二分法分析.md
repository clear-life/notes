# 二分法分析

## 实数二分

### 分析

**问题**: 有一根导线, 某处有一断点, 快速找出断点所在区域.

**关键一: 判定某区域是否有断点**

对`[l, r]`进行通电, 看能否导通

**关键二: 需要确定断点所在区域的大小**

不妨设所求区域大小为 ε

**关键三: 如何快速找出断点所在区域**

二分法: 对区域 `[l, r]`, 由中点 `mid=(l+r)/2` 分为两块区域, 一块区域能导通, 一块区域不能, 则不能导通的区域即为新的**"导线"**, 循环往复该过程, 直到区域大小满足要求

**关键四: yes or no**

判断区域能否导电的函数命名为 check, 区域能否导通用 yes 和 no 进行表示

**关键五: 区域简化为点**

将**区域的一端固定为左端点**, 则**对区域的判定转化为对点的判定**, 整块区域**被断点分为两部分**, 一部分的点都 `yes`, 另一部分的点都 `no`, 此为**二分算法的二分性质**  

判定函数 `bool check(点);` , `true` 表示 `yes`, `false` 表示 `no`, 

### 模板

**实数二分模板**

常用**右侧 yes 左侧 no**

```C++
double l, r;

while(abs(r - l) < ε)
{
	double mid = (l + r) / 2;
    if (check(mid)) r = mid;	// 右侧 yes, 左侧 no	
    else l = mid;
}

while(abs(r - l) < ε)
{
	double mid = (l + r) / 2;
    if (check(mid)) l = mid;	// 左侧 yes, 右侧 no	
    else r = mid;
}
```

## 整数二分

相比于实数二分, 整数二分由于离散的特点需要注意**分界点和取整**两个问题

### **分界点**

整数"导线" `{ 1, 2, 3, 4, 5, 6}`, 若被二分性质分为两个区域 `{1, 2, 3}` 和 `{4, 5, 6}`

则 3 和 4 都有可能是需要寻找的断点, 不妨称为**左右分界点**

在二分搜索**左分界点**时, 不妨设定左侧区域为 yes

在二分搜索**右分界点**时, 不妨设定右侧区域为 yes

### **更新**

二分区域: `{1, 2, 3, ..., x}` `{x + 1, x + 2, ... , n}`

**左分界点 左 yes**

`check(mid)` 为 `true` , 说明 `mid` 在左侧区域, 极限情况下在 `x` 处 更新: `l = mid` 

`check(mid)` 为 `false` , 说明 `mid` 在右侧区域, 极限情况下在 `x + 1` 处 更新: `r = mid - 1` 

**右分界点 右 yes**

`check(mid)` 为 `true` , 说明 `mid` 在右侧区域, 极限情况下在 `x + 1` 处 更新: `r = mid` 

`check(mid)` 为 `false` , 说明 `mid` 在左侧区域, 极限情况下在 `x` 处 更新: `l = mid + 1` 

### **取整**

当 `l` 和 `r` 的更新公式确定后, 由于需要避免死循环, `mid` 的取整情况也随之确定

极限情况 `{1, 2}`

**左分界点 左 yes**

由于分支 `l = mid`, 则 `mid` 需向上取整, 否则陷入死循环 `l = 1, r = 2`

**右分界点 右 yes**

由于分支 `r = mid`, 则 `mid` 需向下取整, 否则陷入死循环 `l = 1, r = 2`

### **模板**

**右分界点 右yes**

```C++
int l, r;
while(l < r)
{
	int mid = l + r >> 1;
    if(check(mid)) r = mid;
    else l = mid + 1;
}
```

**左分界点 左 yes**

```C++
int l, r;
while(l < r)
{
	int mid = l + r + 1 >> 1;
    if(check(mid)) l = mid;
    else r = mid - 1;
}
```

