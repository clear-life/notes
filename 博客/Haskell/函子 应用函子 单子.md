# 函子 应用函子 单子.md

## Context

### Context

**值的计算环境(容器结构)**

**上下文, 语境**: 通过**类型构造子**为值附加计算环境, 值与计算环境分离, 通过类型系统管理**带 context 的值**

$~$

### 类型类与 Context

#### 类型类约束

类型类的 context 即类型类约束, 要求所属类型满足特定行为

`Num a =>` 为类型 a 的操作提供"数值 context"

#### 组合层次

* Functor 不组合
* Applicative 静态组合
* Monad 动态组合

$~$

#### Functor

**独立映射**

context: **独立映射** context 的值, **保持计算环境(容器结构)不变**

核心方法: `fmap :: (a -> b) -> f a -> f b`

* **函数作用于带 context 值** -> 带 context 值

```haskell
fmap (+2) (Just 1) = Just 3	-- Maybe计算环境(容器分支)不变
```

$~$

#### Applicative

**独立组合**

context: **独立组合** context 的值, **计算环境(容器结构)组合前静态确定**

核心方法 `<*> :: f (a -> b) -> f a -> f b`

* **带 context 函数作用于带 context 值** -> 带 context 值

```haskell
pure (+) <*> Just 1 <*> Just 2 = Just 3 -- Maybe 计算环境(容器分支)静态确定
```

$~$

#### Monad

**依赖组合**

context: **依赖组合** context 的值, **计算环境(容器结构)动态变化**

核心方法: `>>= :: m a -> (a -> m b) -> m b`

* **带 context 值带入 `a -> m b` 函数** -> 带 context 值

```haskell
Just 1 >>= \x -> if x > 0 then Just (x+1) else Nothing -- Maybe计算环境(容器分支)动态变化
```

$~$

### Context 含义

**Maybe: 成功或失败的计算**

**Either: 成功或有失败信息的计算**

**[] 非确定性计算**

**IO 输入输出计算**

**(-> r) 共享隐式环境 r 的计算**

$~$

## Functor

**独立映射**

### Functor

context: **独立映射** context 的值, **保持计算环境(容器结构)不变**

```haskell
Functor :: (* -> *) -> Constraint
class Functor f where
    fmap :: (a -> b) -> f a -> f b
```

#### fmap

**函数作用于带 context 值** -> 带 context 值

```haskell
fmap :: (a -> b) -> f a -> f b
```

* **函数 (a->b) 作用带 context1 值 a, 得到带 context2 值 b**

#### <$>

中缀版 fmap

```haskell
(<$>) :: (Functor f) => (a -> b) -> f a -> f b 
f <$> x = fmap f x
```

* **fmap f x**  $\Leftrightarrow$  **f <\$> x** $\Leftrightarrow$ **pure f <*> x**

### 函子定律

```haskell
fmap id == id
fmap (f . g) == fmap f . fmap g
```



**恒等律**

**fmap id == id**

fmap 恒等函数 = 恒等函数

**组合律**

**fmap (f . g) = fmap f . fmap g**

fmap (组合) = (fmap) 组合

先组合再 fmap = 先 fmap 再组合



### instance

```haskell
instance Functor [] where
    fmap = map
```

```haskell
instance Functor Maybe where
    fmap f (Just x) = Just (f x)
    fmap f Nothing = Nothing
```

```haskell
instance Functor (Either a) where
    fmap f (Right x) = Right (f x)
    fmap f (Left x) = Left x
```

