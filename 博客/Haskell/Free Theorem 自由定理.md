# Free Theorem 自由定理

### 理论

#### 参数多态性

自由定理基于**类型系统**的**参数多态性**(类型变量)自动得出

**参数多态性**: 多态函数的行为对所有类型一致, 不能依赖具体类型信息

#### 自由定理

**自由定理**: 通过函数的类型签名, 可以推导出**函数必须满足的等式或行为约束**

#### Haskell 限制

理想化数学模型中, 自由定理严格成立

但 Haskell 的某些特性会破坏自由定理

* **纯函数假设**

   自由定理基于纯函数假设, 副作用函数将失效

* **Monad**

   纯 Monad (Maybe, Reader) 自由定理完全有效

   副作用 Monad (IO, State) 自由定理部分受限

* **高级类型特性**

   类型类, GADTs(广义代数数据类型)等引入特定类型约束, 部分限制自由定理. `Eq a` 约束赋予类型 `a` 相等性语义

* **seq**

   `seq` 强制求值, 可能使多态函数的行为依赖未定义值 `⊥`

   ```haskell
   f :: a -> a
   f x = x `seq` x  -- 若 x = ⊥，则 f x = ⊥，但这不影响定理的“理想”形式
   ```

* **类型系统扩展**

   某些 GHC 扩展(`Typeable`)允许绕过参数多态性, 破坏自由定理

### 实践

#### `f :: a -> a`

自由定理推导出 **`f = id`**

* `f` 无法构造特定于 `a` 的值, 也不能删除或改变输入值, 只能返回输入值本身

```haskell
f :: a -> a
f = id
```

#### `f :: [a] -> [a]`

自由定理推导出 f 是**列表结构操作**

* `f` 无法构造特定于 `a` 的值, 只能对列表进行**结构操作**

#### ` fmap :: (a->b) -> f a -> f b`

自由定理推导出 **`fmap (f . g) = fmap f . fmap g`**

