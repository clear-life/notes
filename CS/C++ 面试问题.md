# C++ 基础

### C++ 编译过程

**预处理** $\rightarrow$ **编译** $\rightarrow$ **汇编** $\rightarrow$ **链接**

**.ii** $\rightarrow$ **.s** $\rightarrow$ **.o** $\rightarrow$ **.exe**

1. **预处理**

   处理**预编译指令**, **删除注释**, **添加行号和文件标识**

2. **编译**

   词法分析, 语法分析, 语义分析, 中间代码生成, 代码优化, 目标代码生成

3. **汇编**

   根据汇编指令与机器指令**对照表挨个翻译**

4. **链接**

   将**二进制文件**, **动态库**和**静态库**打包生成**可执行文件**

### C++ 内存分区

五大区: 堆, 栈, 静态存储区, 常量存储区, 代码区

**栈(stack)**: 编译器控制

**堆(heap)**: 程序员控制

**静态区(static)**: 全局变量和静态变量, 细分为**初始化区**和**未初始化区**

**常量区(const)**: 常量

**代码区**: 程序二进制代码

### 堆区和栈区的区别

**堆**: 编译器控制, 存放函数参数, 局部变量, 类似与**数据结构中的栈**

| 区别     | 栈(stack)                    | 堆(heap)                 |
| -------- | ---------------------------- | ------------------------ |
| 控制     | 编译器, **系统自动分配释放** | 程序员, **手动申请释放** |
| 内容     | 函数参数, 局部变量           |                          |
| 数据结构 | 栈                           | 链表                     |
| 方向     | 由高到低增长                 | 由低到高增长             |
| 效率     | 高                           | 低                       |

> 操作系统有一个记录空闲内存地址的链表
>
> 堆会遍历链表, 找到第一个大于申请空间的堆节点, 然后将该节点分配给程序

### inline 和 define 区别

**define**

**预处理**时进行**简单替换**, **不进行参数检测和成员访问控制检测**

**inline**

建议编译器进行**展开**, 是**函数**, 进行**参数检测**, 更**安全**, **编译**阶段

不用执行调用函数的过程, **少了入栈出栈**的过程, 用**空间换时间**



### sizeof 和 strlen 区别

|      | sizeof             | strlen                             |
| ---- | ------------------ | ---------------------------------- |
| 类型 | **运算符**         | **函数**                           |
| 作用 | **分配**的内存大小 | 到 '\0' 有几个字符                 |
| 时期 | **编译**时         | **运行**时                         |
| 指针 | 指针的大小         | 从指针开始, 到 '\0' 结束有几个字符 |
| 参数 | 类型或变量         | **char***                          |

### memcpy

一次拷贝一个字节

```C++
void* memcpy(void *des, const void *src, size_t n)
{
    if(des == nullptr || src == nullptr)
        return nullptr;
    if(des == src)
        return des;
    
    char *a = static_cast<char*>(des);
    const char *b = static_cast<const char*>(src);
    
    if(a > b && a < b + n)
        for(size_t i = n - 1; i != -1; i--)
            a[i] = b[i];
    else
        for(size_t i = 0; i < n; i++)
            a[i] = b[i];
}
```

### const

**const:** 修饰的值不能被修改, 只读. 必须在定义时初始化

**底层 const**

修饰复合类型中的基本类型, 不能通过 p 来修改 a

`const int *p = &a` 或 `int const *p = &a`

**顶层 const**

修饰复合类型本身, 不能修改 p 本身

`int * const p = &a`

**为什么要区分顶层 const 与底层 const**

1. **底层 const 指针**必须**由底层 const 指针接收**
2. **const_cast** 只能将**底层 const 指针**改为**普通指针**
3. **底层 const** 可以用来**区分函数重载**, 顶层 const 不能

### volatile

volatile 表明该变量随时有可能被修改, 告诉编译器不要对其优化, 

于是对该变量能够一直通过访问其内存得到值

> 编译器可能会将值放到寄存器中, 这样可以优化速度

使用场景: 多线程中**两个线程都要访问一个变量**, 就有可能一个访问**内存**, 一个访问**寄存器**, 于是**造成错误**

### 四种类型转换符

**static_cast**

良性转换, 风险低, 大多数情况

1. 一般的类型转换

2. void* 与具体指针的转换

3. **转换构造函数**或**类型转换函数**的**类**与其他类型的转换

   > 转换构造函数: **手动制定**其他类型向当前类的**转换规则**, 本身就是**构造函数**, 但传入的参数只有一个
   >
   > 类型转换函数: 将当前类转化为其他类型

**const_case**

去掉**底层 const** 的 const 性质

**reinterpret_cast**

二进制重新解释, 高度危险的转换

**dynamic_cast**

基类子类指针的类型转换

up: 子类指针转基类指针, 无条件, 不检测, 都能成功

down: 基类指针转子类指针, 借助 RTTI 检测是否安全, 部分成功

### C++ 11 新特性

**1. 类型推导(编译)**

auto 推导**变量**类型

* 必须马上**初始化**, 否则推导不出来
* 不能产生**二义性**
* 不能用于**参数**和**非静态成员**

decltype 推导**表达式**类型

decltype(exp)

1. exp 是表达式

   结果是 exp 类型

2. exp 是函数调用

   结果是函数返回类型

3. exp 是左值

   结果是 exp 的引用

**2. 右值引用**

**目的**: 支持**移动**操作

> 左值 loactor value 有存储地址的值
>
> 右值 read value 只读数据, 没有存储地址

**本质**:

左值引用: 内存地址的别名

右值引用: 数据的别名

**解决的问题**:

右值引用只能绑定到**临时对象**, 可以方便地将其**资源移动**到另一对象中

移动构造函数进行深拷贝时, 需要开辟很多空间, 使用右值引用直接移动, 可以避免拷贝

**3. 智能指针**

**4. 范围 for 循环**

**5. nullptr**

解决二义性

null 就是 0, nullptr 表示空指针

```C++
#define NULL ((void *)0)	// NULL 是一个宏, void* 类型的 0

void fun(int x);
void fun(char *x);

fun(NULL);		// 产生二义性, void * 可以隐式转换为 int 和 char * 
```

**6. 列表初始化**

**std::initializer_list**

可以用来初始化类的 const 数据成员

### 深浅拷贝

类含有**动态分配的内存**, **指向某处空间的指针**时, 需要**深拷贝**

这样能保证对象里的**指针指向各自拥有的空间**, 空间相互独立

浅拷贝, 拷贝前后的指针指向同一内存

**默认拷贝构造函数**是**浅拷贝**, 自定义的既可以是**浅拷贝**, 也可以是**深拷贝**

### 写时拷贝

**拖延**版的深拷贝

只有向该处内存进行**写操作后**, 才会**开辟空间**

**引用计数**表示指向该空间的指针数量

当进行写操作后, 引用计数减一, 开辟新的空间, 新空间的引用计数加一

### C 和 C++ 区别

| C        | C++                        |
| -------- | -------------------------- |
| 面向过程 | 面向对象(**封装继承多态**) |
|          | STL                        |
|          | 模板, 泛型编程             |
|          | 元编程                     |

### RTTI 机制

> Run Time Type Identification 运行时类型识别

只适用于**多态机制**, 在**运行时**确定基类指针指向的对象类型

**dynamic_cast**

判断能够将**一个对象**赋给**一个对象指针**

也可用于**引用**

> 只有当二者存在多态机制时才能正常转换, 否则为 0 

**typeid**

判断两个对象**是否类型相同**



# 面向对象

**封装**, **继承**, **多态**

## 封装

广义封装: **把某些东西放到一块**, 每一块只需管自己的部分, 不管别人的部分

> **封装就是 "黑盒子"**, 在别的块看来就是黑盒子, 只有输入输出

1. **函数封装**

   某一过程的封装

2. **类封装**

   某一类事物的封装, 含有**数据成员与函数成员**, 也叫**属性和方法**

3. **协议封装**

   **接收方**和**发送方**要**对接的事物**的封装

4. **分层封装**

   **计算机体系结构**, 每一层只管自己的实现, 不管其他层的实现

## 继承

**好处:**

继承不是必须的, 但有了继承, 可以少些大量代码, **提高代码复用性**

**坏处:**

**耦合性增强, 独立性减弱**, 一个出问题了, 另一个很有可能跟着出问题

**属性级别**

1. **private**

   只有本类能访问

2. **protected**

   本类及子类能访问

3. **public**

   任何类都能访问

**继承级别:**

**private > protected > public**

属性级别**高的不变**, 属性级别**低的变高**

## 多态

**同名函数不同功能**

分类: 

1. **编译时多态**(静态多态): **函数重载**
2. **运行时多态**(动态多态): **虚函数, 继承**

```C++
节点 A -> B -> C, 类看成一个节点, 所有类的继承关系(不考虑多继承)看作一棵树
    
A 有虚函数 a
B 重写虚函数 a 为 a`, 无论加不加 virtual 关键字, a` 都是虚函数
C 重写虚函数 a` 为 a``
    
A *p = new B;
p->a(); 	// 动态绑定 B 的 a` 地址

A *p = new C;
p->a();		// 动态绑定 C 的 a`` 地址
```

### 函数重载

**同名函数, 参数列表不同**

* 顶层 const 不能用来区分函数重载
* 底层 const 可以用来区分函数重载

**重载底层实现**

编译器对函数**重命名**, 保证唯一性

重载函数参数不同, 就会被命名为不同的函数名

* **构造函数可以被重载**: 构造函数可以有多个, 且可以带参数
* **析构函数不可以被重载**: 析构函数只能有一个, 不能带参数

### 多态底层实现

如果类**有虚函数**, **编译器**就会为该类**生成一个虚函数表**, 保存在**进程的只读数据段**

虚表**存储该类所有虚函数的地址**, 相当于**函数指针数组**

**创建类对象**时, 编译器会将**前四个字节置为虚表的地址**, 指向虚表, 虚表属于**类**, 所有类对象共享

|                  | 虚表                                                         |
| ---------------- | ------------------------------------------------------------ |
| 条件             | 有**虚函数**, 编译器生成                                     |
| 保存             | 进程的**只读数据段**                                         |
| 存储             | 该类**所有虚函数的地址**, 相当于**函数指针数组**             |
| 类对象           | 编译器将**类对象的前四个字节**置为虚表的地址                 |
| 继承             | 子类继承基类时会**重新创建一个虚表**, 若虚函数被重写, 则函数指针为**重写后的地址**, 若新增虚函数, 则增加子类**新增的虚函数地址** |
| 虚表地址         | `*(int*)(&a)` 将类对象的地址转化为 `int*` 类型再读对应的值   |
| 第一个虚函数地址 | `*(int*)*(int*)(&a)` 将虚表地址转化为 `int*` 类型再解引用    |

 **虚表与继承**

子类于父类的虚表: 

对子类而言: 没变的继承, 重写的覆盖, 新增的增加

**过程**

1. 子类**拷贝父类虚表**
2. **替换重写后**的函数指针
3. **补上新增**的函数指针

**动态绑定**

**父类指针指向子类对象**时, 调用**子类对象的虚表**, 然后只能调用**父类对象定义过的虚函数**

### 构造函数是否可以调用虚函数

**1. 本质**

**构造函数**作用对象是**本类**, **虚函数**作用对象不仅包含**本类**, 还包含**子类或父类**, 所以**构造函数中的虚函数**必须是**本地版本**

**2. 结论**

**可以**, 但会**屏蔽多态机制**, 将父类的虚函数作为普通函数调用, 不会调用子类被重写的函数

**3. 原因**

因为创建子类对象时, 先调用父类构造函数, 子类的**虚表**还未初始化

为了**避免调用到未初始化的内存**, 规定此时不会发生多态行为, 此时为**静态绑定** 

### 构造函数和析构函数能否被继承

**不能**, 即使继承了, **名字也不一致**, 不能成为子类的构造函数和析构函数

### 构造函数可以是虚函数吗

**不可以**, 虚函数的目的是多态, 但子类并不继承父类的构造函数, 不可能被重写

虚函数与构造函数的**本质冲突**: 虚函数服务于**子类与父类**的多态, 构造函数服务于**本类**

### 静态函数可以是虚函数吗

**本质**: **静态函数**作用于**类**, **虚函数**作用于**类对象**

1. static 成员不属于类对象, 即使加上 virtual 也没有意义, 因为多态机制需要**父类指针指向子类对象**
2. static 成员函数没有 this 指针, 无法访问 vptr, 不支持多态机制

### 析构函数可以是虚函数吗

**父类的析构函数**需要为**虚函数**

析构函数**是虚函数**时:

**基类指针指向子类对象**时, delete 基类指针时, **调用子类析构函数**, 子类析构函数又会调用基类析构函数, 这样就能正常释放子类对象

析构函数**不是虚函数**时:

基类指针指向子类对象, 静态绑定, delete 基类指针时, **只会调用基类析构函数**, **子类对象就会析构不完全**

### 如果析构函数不是虚函数, 一定会出现内存泄漏吗

不一定, 如果**子类没有用指针开辟空间**, 就**不会出现内存泄漏**

如果子类用指针开辟空间,  delete 父类指针时, 如果析构函数不是虚函数, 那么 delete 就不会调用子类析构函数, 就会导致内存泄漏

### 虚函数的安全性

通过虚表, 父类指针可以访问子类的虚函数, **一定程度上破坏了封装特性**, 带来安全问题.

子类对象可以通过直接访问前四个字节(即 vptr) 访问虚表, 进而访问到父类对象的 private 虚函数

从结果上来看, private 虚函数也会被继承

```C++
#include<iostream>

using namespace std;

class Base {
private:
	virtual void f() {
		cout << "Base::f" << endl;
	};
};

class Derive : public Base {

};
typedef void(*Fun)(void);

int main() {

	Derive d;

	Fun pFun = (Fun)*((int*)*(int*)(&d));

	pFun();

    return 0;
}
```

### 析构函数可以是纯虚函数吗

**可以**是纯虚函数, 但**必须定义函数体**, 因为子类不能实现基类析构函数, 而且基类析构函数会在子类析构函数中调用



### override 和 final

**override**

**表明这是重写**, 方便编译器判断是否正确重写

**final**

**不希望类被继承**, 或**不希望虚函数被重写**



### struct 和 class 区别

**struct** 属性和继承默认为 **public**

**class** 属性和继承默认为 **private**

**class 可以使用模板, struc 不能用模板**

### 重载, 重写, 隐藏的区别

**重载**

同一类中, 同名函数, 不同参数列表

**重写**

子类重新编写父类的 virtual 函数

> 仅函数体不同

**隐藏**

子类重新编写父类的函数, **函数名相同**, 参数列表可以相同, 可以不同

## 类

### class 类内存分布

**1. 空类**

一个字节, 占位符

**2. 没有虚函数**

数据成员, **内存对齐**

**3. 有虚函数**

多一个四字节的 vptr 指针

**继承中的内存分布**

父类于子类拥有**各自的内存空间**

子类先**继承父类的空间**, 然后**自己定义的变量**放在**父类空间的下面**

如果子类定义了于父类同名的变量, 调用时就会**屏蔽父类变量**, 但**变量本身依然存在**

### 内存对齐

1. 内存顺序于声明**顺序一致**
2. 变量的**偏移**量是 `min(type, c)` **倍数**
3. **类的大小**是 **c** 的倍数

```C++
对齐系数: a
max(type): b
对齐单位: c = min(a, b)
```

### this 指针

非静态成员函数隐含参数, 一般存放在**寄存器**中

**可变参数**时, 存放在**栈**中

> 函数的参数一般存放在栈中

### 成员函数

存放在代码区

**非静态成员函数**

隐含 **this 指针**, 所以只有**类对象才能调用**

**静态成员函数**

没有 this 指针

### 构造函数

构造顺序:

1. 分配内存
2. 构造函数**初始化列表**初始化
3. **构造函数内赋值**

### 拷贝构造函数

自定义拷贝构造函数后, 默认的就不存在了

```C++
class A
{
    A(const A &a)	// 必须加 &, 一般加 const
    {
        
    }
}
```

**使用场景**

1. 初始化

   ```C++
   A a(b);
   A a = b;	// 不是赋值语句, 而是初始化语句
   			// 赋值语句的左边是已经定义好的变量
   ```

2. 参数传递

   ```C++
   fun(A a);
   ```

3. 函数返回

   ```C++
   A fun();
   ```

### 抽象类

含有**纯虚函数**的类, "根节点"

**本质**: 抽象概念的类, 没有实际对象

```C++
virtual fun() = 0;
```

限制: 

* **不能实例化对象**
* **不能作为实际对象的类型**使用

子类:

* 如果子类没有重新定义纯虚函数, 那么还是一个抽象类
* 必须**实现所有纯虚函数**才能实例化对象

多态:

* 可以**定义指向抽象类的指针和引用**, 然后指向子类, 进而实现**多态**

### 空类默认生成哪几个成员函数

对于空类, 编译器只生成 1 个字节的占位符

一般情况下, 编译器会默认生成 6 个成员函数:

**构造**函数, **拷贝构造**函数, **析构**函数

**赋值**运算符, 两个**取址**运算符

**this** 指针

```C++
class A
{
    A();
    A(const A&);
    ~A();
    A& operator=(const A&);
    A* operator&();
    const A* operator&() const;
}
```

### const 成员函数

**本质**: const 修饰的成员函数不能修改数据成员

const 修饰成员函数可以用来**函数重载**

```C++
class A
{
    fun() const;
    fun();
}
```

### 赋值运算符

```C++
class A
{
    A& operator=(const A &b)
    {
        if(this != &b)
        {
            ...
        }
        return *this;
    }
}
```

### 赋值函数于拷贝构造函数的区别

**赋值**函数: 两个类对象已经存在

拷贝**构造**函数: 一个存在, 一个不存在

```C++
class A
{
    int *p;
    
    A(const A &b)
    {
        p = new int(*b.p);
    }
        
    A& operator=(const A &b)	// 赋值函数
    {
        if(this == &b) return *this;

        delete p;	// 表明之前的都清空了
        
        p = new int(*b.p);	// 重新赋值
        
        return *this;
    }
}
```

### 什么时候必须用初始化列表

1. 初始化 **const 数据成员**和**引用数据成员**
2. 类成员**没有无参数构造函数**时
3. 初始化**父类私有成员**, 只能在**初始化列表中调用父类构造函数**

### 多继承

一个节点有多个父节点

**构造函数**

调用**父类构造函数的顺序**与**初始化列表中的顺序无关**, 而与**声明继承关系时的顺序**一致

```C++
class C : public A, public B
{
    C() : B(...), A(...)	// 先调用 A, 再调用 B
    {
        
    }
}
```

**问题**

**命名冲突**, 不知道来自哪个父类, 极易出现**二义性**

需要**显式指明**来自哪个类

## static

### staitc 变量什么时候初始化

C 中, 初始化发生在**代码执行前**的**编译**阶段

C++ 中, 只有在**执行代码**时才会对**静态变量初始化**

因为**构造函数**和**析构函数**不仅分配内存, 还跟程序中的其他部分相**关联**

所以会按**使用顺序构造**, 构造顺序**反方向析构**

### static 成员变量

static 成员属于整个类, 在**类外分配空间**(static 区)

static 成员在**初始化时分配内存**, 声明时加上 static, 初始化时不能加 static

static 成员必须初始化, 且**只能在类外初始化**

**staitc 全局变量**只能作用于本文件, **不能跨文件使用**

### static 成员函数

**目的**: 处理 static 成员变量

static 成员函数**没有 this 指针**, **只能访问 static 成员**(数据成员和函数成员), 无论是否创建对象, 都能调用 static 成员函数

**staitc 成员函数不能设为虚函数**

因为 static 成员函数**没有 this 指针**, 不能访问 vptr, 继而**不能访问虚表**

> vptr 只能通过 this 访问

# 动态内存

### new 和 malloc

**new 过程**

**1. 内置类型**

内置类型**没有构造函数和析构函数**

new : operator new

new[] : 计算大小后, 调用 operator new

delete : operator delete

delete[] : operator delete

**2. 类类型**

**new** 

1. **operator new** 申请内存
2. **构造函数**

new []

1. operator new[] 申请内存
2. 在前四个字节(首地址)写入数组大小 n
3. 调用 **n 次构造函数**

**delete** 

1. **析构函数**
2. **operator delete** 释放内存

delete []

1. 取出前四个字节存储的数组大小 n
2. 调用 **n 次析构函数**
3. operator delete [] 释放内存

```C++
class A
{
public:
    A()
    { 
        cout << "A 的构造函数" << endl; 
    }
    
    ~A()
    { 
        cout << "A 的析构函数" << endl;
    }

    void * operator new(size_t sz)
    {
        A* p = (A*) malloc(sizeof(A));
        cout << "申请内存" << endl;

        return p;
    }

    void operator delete(void * p)
    {
        free(p);
        cout << "释放内存" << endl;
    }
};

A *p = new A;
delete p;
// 申请内存
// A 的构造函数
// A 的析构函数
// 释放内存
```

**malloc**

```C++
void* malloc(size_t size);	// size 以字节为单位

int *p = (int *) malloc(n * sizeof(int));	
free(p);
```

**new 和 malloc 比较**

``` C++
int *p = new int;			// new
void* malloc(size_t sz);	// malloc
```

new 更高级, malloc 更底层

new 做的更全面, malloc 做的更基本

| 比较         | new                                          | malloc                               |
| ------------ | -------------------------------------------- | ------------------------------------ |
| 类型         | **运算符**                                   | **库函数**                           |
| 输入         | **类型**, 自动计算字节数                     | **字节数**                           |
| 输出         | **类型**, 类型安全                           | **void ***, 类型不安全, 需要**强转** |
| 申请内存位置 | **自由存储区** free store (堆/静态存储区/空) | **堆**                               |
| 内存不够     | 可以重新分配(realloc)                        | 不可以重新分配                       |
| 分配失败     | 抛出**异常**                                 | 返回 **NULL**                        |
| 过程         | 先底层调用 malloc 申请内存, 然后调用构造函数 | 向操作系统申请内存                   |

### new operator 和 operator new

**new** 运算符

1. 函数 **operator new** **申请内存**
2. **构造函数**初始化内存

**delete** 运算符

1. **析构函数**释放资源
2. 函数 **operator delete 释放内存**

> operator new 一般用 malloc 实现
>
> operator delete 一般用 free 实现

|        | new 运算符                                               | 函数 operator new                           |
| ------ | -------------------------------------------------------- | ------------------------------------------- |
| 类型   | 内置运算符, 无法改变行为                                 | 函数, 可以重载, 类似于 malloc, 但更高级一点 |
| 编译器 | **改写成两个函数**: 一个 operator new 函数, 一个构造函数 | 一个函数                                    |

### placement new

placement new 是传入可选参数 `placement_params` 的 new, 但并不申请内存, **只调用构造函数**

作用:  申请内存后, 可以**重复构造和析构**该内存, **节省**多次申请和释放**内存的开销**

```C++
class A
{
public:
    A()
    { 
        cout << "A 的构造函数" << endl; 
    }
    
    ~A()
    { 
        cout << "A 的析构函数" << endl;
    }
};

char *mem = new char[n * sizeof(A)];	// 申请内存

A *p = new (mem) A;		// placement new, 调用构造函数

p->~A();				// 显示调用析构函数

delete [] mem;			// 释放内存
```

### delete [] 如何知道 delete 多大的数组

new [] 类类型数组时, 在**前四个字节记录数组大小 n**, delete [] 时**取出数组大小**, **调用 n 次析构函数**, 然后调用 operator delete [] 释放内存

### 内存泄漏

由于种种原因, **没有释放内存**, 造成内存浪费

**原因**

1. 没有 delete

   ```C++
   {
       int *p = new int;
   	p = nullptr;
    	// p 出局部作用域时销毁了    
   }
   ```

2. new [] 时调用 delete

   此时只会释放了第一个对象的内存空间, 正常应该调用 delete []

3. new 时调用 free

   这种方式会**少一步调用析构函数**, 析构函数会释放成员变量

4. 循环引用

**防止**

1. 尽量使用**系统栈**分配内存

2. **正确释放**

   malloc 对应 free

   new 对应 delete

   new [] 对应 delete []

3. **避免使用裸指针**

4. 尽量使用 **STL**

   string 代替 char *

   vector 代替数组

   make_shared 代替 new

5. 尽量使用**智能指针**

**检测是否泄漏**

1. **打印地址**

   分配]和释放内存的时候**打印地址**, 计算**分配的内存大小**是否等于**释放的内存大小**

2. **统计次数**

   统计**分配和释放的次数是否相等**

3. **工具**

### 指针和引用区别

> "引用"默认指"左值引用"
>
> 指针和引用都是**复合类型**

引用的本质就是指针, 编译器**自动将指针封装成引用**

```C++
int &b = a; b = 1;
相当于
int *b = &a; *b = 1;
```

| 区别   | 指针                         | 引用                                      |
| ------ | ---------------------------- | ----------------------------------------- |
| 本质   | **地址变量**                 | **指针实现**                              |
| 定义   | **地址的变量**               | 变量的别名, **某块内存的别名**            |
| 初始化 |                              | **必须初始化**                            |
| 指向   | 随时任意改变                 | **不能改变引用关系**, 不能有 null 引用    |
| 多级   | 可以有多级指针               | **只能有一级引用**                        |
| 安全   | **没有类型检查**, 类型不安全 | 有**类型检查**, **类型安全**              |
| 修饰   | 可以用 const 修饰            | 不能用 const 修饰, 因为引用本身就不可改变 |
| sizeof | 指针变量内存大小             | 引用对象内存大小                          |
| ++, -- | 指针变量的运算               | 引用对象的运算                            |

|      | 值传递               | 指针传递                 | 引用传递             |
| ---- | -------------------- | ------------------------ | -------------------- |
| 过程 | 形参是实参的**拷贝** | 传递的变量是**指针类型** | 形参是实参的**别名** |
| 本质 | 形参是实参的**副本** | **值传递**               | **指针传递**         |

**指针传递**和**引用传递**使用场景

1. **在函数内改变函数外**的变量值
2. 返回多个值
3. 提高传参效率

# STL

泛型编程, 基于**模板**, 主要有**容器**, **迭代器**, **算法**

**容器管理数据**, **算法实现操作**, **迭代器连接二者**

## 容器

**顺序容器:** vector, deque, list, string, array

**关联容器:** set, map, unordered_set, unordered_map

**容器适配器:** stack, queue, priority_queue

| 容器           | 特点                                          |
| -------------- | --------------------------------------------- |
| vector         | 动态数组, 倍增(2 倍), 倍减(1/4 时缩为一半)    |
| deque          | 多段连续空间构成, 通过 map 记录各段的入口地址 |
| list           | 双向链表, 堆内存                              |
| set/map        | 红黑树, 有序                                  |
| stack          | 基于 deque                                    |
| queue          | 基于 deque                                    |
| priority_queue | 基于 vector, 堆数据结构                       |

### vector

vector 有两个重要参数: size 和 capasity

### reserve 与 resize

reverse: 开辟空间, 不创建元素

resize: 有可能重新开辟空间, size 不够就创建元素

**reserve(n)**: **设置 capasity 不少于 n**

**resize(n)**: **设置 size 为 n**, 多的擦去, 少的补上

## 智能指针

### 作用

避免**内存泄漏**

因为智能指针是一个类, 销毁时**自动调用析构函数释放内存**, 不需要手动释放内存

### 原理

**shared_ptr:** 多个指针指向同一对象

**unique_ptr:** 独占对象

**weak_ptr:** 辅助 share_ptr 

**shared_ptr**

每多一个指针, **引用计数就加 1**

每少一个指针, **引用计数就减 1**

引用计数为 0 时就释放内存

**unique_ptr**

引用计数只能为 1

没有拷贝构造函数

**weak_ptr**

只能指向内存空间但**没有所有权**, 不影响引用计数

辅助获取 shared_ptr 的状态信息, 如有几个 shared_ptr, shared_ptr 指向的内存是否释放

**防止出现循环引用**

A 的成员指向 B, B 的成员指向 A

**循环引用**

```C++
class B;

class A
{
public:
    shared_ptr<B> _pb;	// 正确做法 weak_ptr<B>_pb;
}

class B
{
public:
    shared_ptr<A> _pa;	// 正确做法 weak_ptr<A>_pa;
}

shared_ptr<A> pa = make_shared<A>();
shared_ptr<B> pb = make_shared<B>();

cout << pa.use_count() << " " << pb.use_count() << endl;	

pa->_pb = pb;
pb->_pa = pa;

cout << pa.use_count() << " " << pb.use_count() << endl;

/*
1 1
2 2
*/
```

`pa->_pb = pb` 语句会使得有两个指针指向 B 对象

一个是 `pb` 本身, 一个是 `pa->_pb`, 即 `pa` 指向地方的**指向 B 的指针**

于是, B 的引用计数就为 2, 但问题出在: `pa->_pb` 并不会销毁, 因为其依赖于 A 的引用计数

而 A 的引用计数同样依赖于 B 的引用计数, 于是就出现了死锁

最终, 真正销毁的只有 `pa` 和 `pb`, `pa->_pb` 和 `pa->_pb` 都没有被销毁

正确做法, 使用 **weak_ptr**, 因为其**没有所有权**, **引用计数不会加 1**

### 实现

```C++
class Point
{
    int *ptr;
    size_t* p_count;
    
    // 构造, 析构, 拷贝构造
    Point(int *p = nullptr)
    {
        ptr = p;
        if(p != nullptr) *p_count = 1;
        else *p_count = 0;
    }
    
    ~Point()
    {
        if(--*p_count == 0)
            delete ptr;
    }
    
    Point(const Point& b)
    {
        ptr = b.ptr;
        *p_count = b.count();
        *p_count++;
    }
    
    // 重载赋值运算符
    Point& operator=(const Point& b)
    {
        if(ptr == b.ptr) return *this;
        
        if(ptr != nullptr) 
        {
            if(--*p_count == 0) 
                delete ptr;
        }
        
        ptr = b.ptr;
        p_count = b.count;
        *p_count++;
        
        return *this;
    }
    
    T* operator->()
    {
        if(ptr != nullptr)
            return ptr;
    }
    
    T& operator*()
    {
        if(ptr != nullptr)
            return *ptr;
    }
}
```

