# C++ 基础

### 面向对象三大特征

**封装**, **继承**, **多态**

**1. 封装**

广义封装: **把某些东西放到一块**, 每一块只需管自己的部分, 不管别人的部分

> **封装就是 "黑盒子"**, 在别的块看来就是黑盒子, 只有输入输出

1. 函数封装

   某一过程的封装

2. 类封装

   某一类事物的封装, 含有**数据成员与函数成员**, 也叫**属性和方法**

3. 协议封装

   **接收方**和**发送方**要**对接的事物**的封装

4. 分层封装

   **计算机体系结构**, 每一层只管自己的实现, 不管其他层的实现

**2. 继承**

**好处:**

继承不是必须的, 但有了继承, 可以少些大量代码, **提高代码复用性**

**坏处:**

**耦合性增强, 独立性减弱**, 一个出问题了, 另一个很有可能跟着出问题

**3. 多态**

本质: **同名函数不同实现**

分类: 

1. **编译时多态**(静态多态): **函数重载**
2. **运行时多态**(动态多态): **虚函数重写**



### C++ 内存分区

五大区: 堆, 栈, 静态存储区, 常量存储区, 代码区

**栈(stack)**: 编译器控制

**堆(heap)**: 程序员控制

**静态区(static)**: 全局变量和静态变量, 细分为**初始化区**和**未初始化区**

**文字常量区(const)**: 常量字符串

**代码区**: 程序二进制代码

### 堆区和栈区的区别

**堆**: 编译器控制, 存放函数参数, 局部变量, 类似与**数据结构中的栈**

| 区别     | 栈(stack)                    | 堆(heap)                 |
| -------- | ---------------------------- | ------------------------ |
| 控制     | 编译器, **系统自动分配释放** | 程序员, **手动申请释放** |
| 内容     | 函数参数, 局部变量           |                          |
| 数据结构 | 栈                           | 链表                     |
| 方向     | 由高到低增长                 | 由低到高增长             |
| 效率     | 高                           | 低                       |

> 操作系统有一个记录空闲内存地址的链表
>
> 堆会遍历链表, 找到第一个大于申请空间的堆节点, 然后将该节点分配给程序

# C++ 标准库

## 动态内存

### new 和 malloc

**new 语法**

`new type `

`:: new (placement_params) type initializer`

**new 用法**

```C++
// 二维数组
int **p = new int* [n];
for(int i = 0; i < n; i++)
    p[i] = new int [m];

for(int i = 0; i < n; i++)
    delete [] p[i];
delete [] p;
```

**new 过程**

**1. 内置类型**

内置类型**没有构造函数和析构函数**

new : operator new

new[] : 计算大小后, 调用 operator new

delete : operator delete

delete[] : operator delete

**2. 类类型**

**new** 

1. **operator new** 申请内存
2. **构造函数**

new []

1. operator new[] 申请内存
2. 在前四个字节(首地址)写入数组大小 n
3. 调用 **n 次构造函数**

**delete** 

1. **析构函数**
2. **operator delete** 释放内存

delete []

1. 取出前四个字节存储的数组大小 n
2. 调用 **n 次析构函数**
3. operator delete [] 释放内存

```C++
class A
{
public:
    A()
    { 
        cout << "A 的构造函数" << endl; 
    }
    
    ~A()
    { 
        cout << "A 的析构函数" << endl;
    }

    void * operator new(size_t sz)
    {
        A* p = (A*) malloc(sizeof(A));
        cout << "申请内存" << endl;

        return p;
    }

    void operator delete(void * p)
    {
        free(p);
        cout << "释放内存" << endl;
    }
};

A *p = new A;
delete p;
// 申请内存
// A 的构造函数
// A 的析构函数
// 释放内存
```

**malloc**

```C++
void* malloc(size_t size);	// size 以字节为单位

int *p = (int *) malloc(n * sizeof(int));	
free(p);
```

**new 和 malloc 比较**

``` C++
int *p = new int;			// new
void* malloc(size_t sz);	// malloc
```

new 更高级, malloc 更底层

new 做的更全面, malloc 做的更基本

| 比较         | new                                          | malloc                 |
| ------------ | -------------------------------------------- | ---------------------- |
| 类型         | **运算符**                                   | **库函数**             |
| 输入         | **类型**, 自动计算字节数                     | **字节数**             |
| 输出         | **类型**, 类型安全                           | **void ***, 类型不安全 |
| 申请内存位置 | **自由存储区** free store (堆/静态存储区/空) | **堆**                 |
| 分配失败     | 抛出**异常**                                 | 返回 **NULL**          |
| 过程         | 先底层调用 malloc 申请内存, 然后调用构造函数 | 向操作系统申请内存     |

**注意事项**

```C++
// new 和 malloc 申请内存后, 可以访问到未申请的内存区域, 但在 delete 和 free 时会出错
int *p = new int[2];
p[2] = 2;

delete [] p;	// delete 时会出错, 因为访问到了未申请的区域
```

### new operator 和 operator new

**new** 运算符

1. 先调用函数 **operator new** **申请内存**
2. 再调用**构造函数**初始化内存

**delete** 运算符

1. 先调用析构函数释放资源
2. 再调用 **operator delete 释放内存**

> operator new 一般用 malloc 实现
>
> operator delete 一般用 free 实现

|        | new 运算符                                           | 函数 operator new                           |
| ------ | ---------------------------------------------------- | ------------------------------------------- |
| 类型   | 内置运算符, 无法改变行为                             | 函数, 可以重载, 类似于 malloc, 但更高级一点 |
| 编译器 | 改写成两个函数: 一个 operator new 函数, 一个构造函数 | 一个函数                                    |

### placement new

placement new 是传入可选参数 `placement_params` 的 new, 但并不申请内存, **只调用构造函数**

作用:  申请内存后, **可以重复构造和析构该内存**, **节省多次申请和释放内存的开销**

```C++
class A
{
public:
    A()
    { 
        cout << "A 的构造函数" << endl; 
    }
    
    ~A()
    { 
        cout << "A 的析构函数" << endl;
    }
};

char *mem = new char[n * sizeof(A)];	// 申请内存

A *p = new (mem) A;		// placement new, 调用构造函数

p->~A();				// 显示调用析构函数

delete [] mem;			// 释放内存
```

### delete [] 如何知道 delete 多大的数组

new [] 类类型数组时, 在**前四个字节记录数组大小 n**, delete [] 时**取出数组大小**, **调用 n 次析构函数**, 然后调用 operator delete [] 释放内存

### 内存泄漏

由于种种原因, **没有释放内存**, 造成内存浪费

**原因**

1. 没有 delete

   ```C++
   {
       int *p = new int;
   	p = nullptr;
    	// p 出局部作用域时销毁了    
   }
   ```

2. new [] 时调用 delete

   此时只会释放了第一个对象的内存空间, 正常应该调用 delete []

3. new 时调用 free

   这种方式会**少一步调用析构函数**, 析构函数会释放成员变量

4. 循环引用

**防止**

1. 尽量使用**系统栈**分配内存

2. **正确释放**

   malloc 对应 free

   new 对应 delete

   new [] 对应 delete []

3. **避免使用裸指针**

4. 尽量使用 **STL**

   string 代替 char *

   vector 代替数组

   make_shared 代替 new

5. 尽量使用**智能指针**

**检测是否泄漏**

1. **打印地址**

   分配和释放内存的时候**打印地址**, 计算**分配的内存大小**是否等于**释放的内存大小**

2. **统计次数**

   统计**分配和释放的次数是否相等**

3. **工具**

### 指针和引用区别

> "引用"默认指"左值引用"
>
> 指针和引用都是**复合类型**

引用的本质就是指针, 编译器**自动将指针封装成引用**

```C++
int &b = a; b = 1;
相当于
int *b = &a; *b = 1;
```

| 区别   | 指针                         | 引用                                      |
| ------ | ---------------------------- | ----------------------------------------- |
| 本质   | **地址变量**                 | **指针实现**                              |
| 定义   | **地址的变量**               | 变量的别名, **某块内存的别名**            |
| 初始化 |                              | **必须初始化**                            |
| 指向   | 随时任意改变                 | **不能改变引用关系**, 不能有 null 引用    |
| 多级   | 可以有多级指针               | **只能有一级引用**                        |
| 安全   | **没有类型检查**, 类型不安全 | 有**类型检查**, **类型安全**              |
| 修饰   | 可以用 const 修饰            | 不能用 const 修饰, 因为引用本身就不可改变 |
| sizeof | 指针变量内存大小             | 引用对象内存大小                          |
| ++, -- | 指针变量的运算               | 引用对象的运算                            |

|      | 值传递               | 指针传递                 | 引用传递             |
| ---- | -------------------- | ------------------------ | -------------------- |
| 过程 | 形参是实参的**拷贝** | 传递的变量是**指针类型** | 形参是实参的**别名** |
| 本质 | 形参是实参的**副本** | **值传递**               | **指针传递**         |

**指针传递**和**引用传递**使用场景

1. **在函数内改变函数外**的变量值
2. 返回多个值
3. 提高传参效率

```C++
void fun(int a, int *b, int &c)
{
    cout << &a << endl;		// a 副本的地址
    cout << b << endl;		// a 的地址
    cout << &c << endl;		// a 的地址
}

int a = 1;

cout << &a << endl;

fun(a, &a, a);
```

