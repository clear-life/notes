# 基础

## 网络模型

不同主机间的**进程通信**

### 应用层

为用户提供服务: HTTP, FTP, DNS, SMTP

**应用层**位于**用户态**

**传输层及以下**位于**内核态**

### 传输层

TCP: 可靠传输

UDP: 实时性好

发送端将数据包**分块**, 接收端将数据包**组装**

### 网络层

IP, MTU 最大传输单元

**路由与转发**

### 网络接口层

链路级别的传输

## 输入网址到页面显示的过程

### HTTP

**1. 解析 URL**

URL: 应用层协议 + 域名 + 文件路径

**2. 生成 HTTP 请求消息**

### DNS

> 域名层级关系是一个**树**
>
> 根 -> 顶级 -> 权威

1. 发送 **DNS 请求**给**本地域名服务器**, 查询域名对应的 IP 地址
2. 本地域名服务器**缓存**没找到, 就迭代查询
3. 本地域名服务器迭代查询 : **根域名服务器** -> **顶级域名服务器** -> **权威域名服务器**
4. 本地域名服务器将 IP 地址返回给客户端

> 缓存: 浏览器缓存 -> 操作系统缓存 -> hosts 文件 -> 本地域名服务器

### 协议栈

应用层协议调用 socket 库使用协议栈

操作系统的协议栈: TCP/UDP, IP, ICMP, ARP

> ICMP: 差错信息, 控制信息
>
> ARP: IP 翻译为 MAC

#### TCP

**TCP 报文**

1. 源/目标端口

2. 序号

3. 确认号

4. 状态位

   > SYN 建立连接
   >
   > ACK 回复
   >
   > RST 重新连接
   >
   > FIN 断开连接

5. 窗口大小

6. 校验和

**三次握手建立连接**

目的: 保证**双方都有发送和接受的能力**

> 查看 TCP 连接状态:
>
> linux netstat -napt

**分割数据**

将 HTTP 数据分割为 MSS, 加上 TCP 头, 组装好 TCP 报文

#### IP

**确定源/目的 IP**

根据路由表判断将哪个网卡作为源 IP 地址

> route -n 查看路由表
>
> 全零表示默认网关

**拆分组装生成 IP 报文**

### MAC

源/目的 MAC 地址: 路由表 和 ARP 协议(广播)  

> arp -a    ARP 缓存

### 网卡

**网卡驱动程序**, 网卡**缓存**, 开头加**报头**和**帧分界符**, 结尾加**校验序列**

### 交换机

检测是否接收方 MAC 地址是否是自己, 不是就丢弃

### 路由器

路由器端口具有 MAC 地址和 IP 地址, **路由表确定发送端口**, ARP 缓存