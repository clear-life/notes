# 基础

### 网络模型

不同主机间的**进程通信**

**1. 应用层**

为用户提供服务: HTTP, FTP, DNS, SMTP

**应用层**位于**用户态**

**传输层及以下**位于**内核态**

**2. 传输层**

TCP: 可靠传输

UDP: 实时性好

发送端将数据包**分块**, 接收端将数据包**组装**

**3. 网络层**

IP, MTU 最大传输单元

**路由与转发**

**4. 网络接口层**

链路级别的传输

### 输入网址到页面显示的过程

**1. HTTP**

**解析 URL**

URL: 应用层协议 + 域名 + 文件路径

**生成 HTTP 请求消息**

**2. DNS**

> 域名层级关系是一个**树**
>
> 根 -> 顶级 -> 权威

1. 发送 **DNS 请求**给**本地域名服务器**, 查询域名对应的 IP 地址
2. 本地域名服务器**缓存**没找到, 就迭代查询
3. 本地域名服务器迭代查询 : **根域名服务器** -> **顶级域名服务器** -> **权威域名服务器**
4. 本地域名服务器将 IP 地址返回给客户端

> 缓存: 浏览器缓存 -> 操作系统缓存 -> hosts 文件 -> 本地域名服务器

**3. 协议栈**

应用层协议调用 socket 库使用协议栈

操作系统的协议栈: TCP/UDP, IP, ICMP, ARP

> ICMP: 差错信息, 控制信息
>
> ARP: IP 翻译为 MAC

**3.1 TCP**

**TCP 报文**

1. 源/目标端口

2. 序号

3. 确认号

4. 状态位

   > SYN 建立连接
   >
   > ACK 回复
   >
   > RST 重新连接
   >
   > FIN 断开连接

5. 窗口大小

6. 校验和

**三次握手建立连接**

目的: 保证**双方都有发送和接受的能力**

> 查看 TCP 连接状态:
>
> linux netstat -napt

**分割数据**

将 HTTP 数据分割为 MSS, 加上 TCP 头, 组装好 TCP 报文

**3.2 IP**

**确定源/目的 IP**

根据路由表判断将哪个网卡作为源 IP 地址

> route -n 查看路由表
>
> 全零表示默认网关

**拆分组装生成 IP 报文**

**4. MAC**

源/目的 MAC 地址: 路由表 和 ARP 协议(广播)  

> arp -a    ARP 缓存

**5. 网卡**

**网卡驱动程序**, 网卡**缓存**, 开头加**报头**和**帧分界符**, 结尾加**校验序列**

**6. 交换机**

没有 MAC 地址, 直接接收所有包并在 MAC 地址表中查询 MAC 地址并发送到相应端口

**7. 路由器**

路由器端口具有 MAC 地址和 IP 地址, **路由表确定发送端口**, ARP 缓存

**总结:**

报头和起始帧分界符 + MAC + IP + TCP + HTTP + 数据 + FCS

> 最外层由网卡添加, 即报头和起始帧分节符 + FCS 校验序列
>
> 路由器具有最外两层的功能

### ARP 协议

将 IP 地址解析为 MAC 地址

ARP 缓存表: IP 到 MAC 的映射关系

**更新 ARP 缓存表**

广播 ARP 请求: 包含**目标 IP 地址**和**全 1 MAC 地址**

局域网内的**主机或网关**发送 ARP 应答, 告诉 IP 与 MAC 的映射关系

更新 ARP 缓存, 设置 TTL 时间

# TCP

## TCP 基础

### TCP 格式

**seq**: 数据的序号, 每次累加数据的字节数

**ack**: 下次期望的 seq 号

**控制位**:

* ACK : ack 是否有效
* SYN : 建立连接
* FIN : 断开连接
* RST : 强制断开连接

### 为什么需要 TCP

因为 IP 不可靠, TCP 能保证**可靠**

**可靠**

网络包的正常交付, 正常: **不错不乱不多不少**

### TCP 协议

面向**连接**, **可靠**, 基于**字节流**的传输层协议

* 面向连接: 一对一
* 可靠: 不错不乱不多不少
* 字节流: 按字节为最小单位分块转发

### 唯一确定 TCP 连接

四元组: 源 IP, 源端口, 目的 IP, 目的端口

**TCP 最大连接数**

> 服务器 IP 和端口固定

理论 = IP 数 $\times$ 端口数 = $2^{32} \times 2^{16}$ = $2^{48}$

实际: 受**文件描述符**和**内存**限制

> 每个 TCP 连接都是一个文件

### TCP 与 UDP 区别

| TCP                        | UDP                |
| -------------------------- | ------------------ |
| 面向连接                   | 无连接             |
| 一对一                     | 多对多             |
| 可靠                       | 不可靠             |
| 拥塞控制, 流量控制         | 无                 |
| 字节流, MSS 分片, MTU 分片 | 整个报文, MTU 分片 |

> TCP 首部可变长度, UDP 首部长度固定
>
> TCP 数据 = IP - IP 首部 - TCP 首部

**应用场景**

**TCP**

文件传输 FTP, HTTP, 邮件 SMTP 

**UDP**

DNS, 网络管理 SNMP, 多媒体通信

## TCP 建立连接

### TCP 三次握手

![tcp 连接](D:\workspace\repositories\studynotes\CS\image\tcp 连接.png)

**第一次**

客户端 $\rightarrow$ 服务端 

SYN

seq = a

**第二次**

服务端 $\rightarrow$ 客户端

SYN + ACK

ack = a + 1

seq = b

**第三次**

客户端 $\rightarrow$ 服务端

ACK

ack = b + 1

seq = a + len

> 第三次可携带数据

### 为什么是三次, 而不是两次, 四次

三次握手才能**保证双方都有收发数据的能力**

**到达时间**: 

* case1: 包丢了
* case2: 到达时间在**发送时间往后的任一时间点**  

**1. 避免历史连接**

场景:

两个**第一次握手**同时到达服务器, 或**旧的先到达**

服务器发送两个**第二次握手**

**如果是三次握手:**

客户端把 ack 对应不上的那个连接给断开, 发送 rst 中止连接

**如果是两次握手:**

服务端在**旧的第一次握手**到达时就进入 `established` 状态, 然后给客户端发送数据, 客户端发现 ack 对应不上, 于是发送 rst 中止连接
结果: **服务器浪费了资源**, 建立连接后没有任何作用就断开了

结论: 三次握手不会浪费服务器资源

**2. 同步双方初始 seq**

双方初始的 seq 是随机的, 为了告知对方, 只有**第三次握手才会同步好双方的初始 seq**

如果是两次握手, 那么第二次握手时, 客户端不知道服务端的初始 seq

**3. 避免资源浪费**

两次握手时, 对于客户端的每个 SYN 报文, 服务端都要建立一个连接, 造成资源的浪费

> 由于网络原因, 客户端可能会发送多个 SYN 报文

### 初始 seq 为什么随机

**1. 避免接收到历史报文**

如果初始 seq 都是从 0 开始, 可能会出现下述情况:

**上一次连接的报文**被阻塞, 在**当前连接到达服务端**

**恰好 seq 在服务端接收窗口内**, 就会被服务端接收, 发生数据错乱

**2. 防止接收黑客伪造的 TCP 报文**

