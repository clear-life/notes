# 基础

### 网络模型

不同主机间的**进程通信**

**1. 应用层**

为用户提供服务: HTTP, FTP, DNS, SMTP

**应用层**位于**用户态**

**传输层及以下**位于**内核态**

**2. 传输层**

TCP: 可靠传输

UDP: 实时性好

发送端将数据包**分块**, 接收端将数据包**组装**

**3. 网络层**

IP, MTU 最大传输单元

**路由与转发**

**4. 网络接口层**

链路级别的传输

### 输入网址到页面显示的过程

**1. HTTP**

**解析 URL**

URL: 应用层协议 + 域名 + 文件路径

**生成 HTTP 请求消息**

**2. DNS**

> 域名层级关系是一个**树**
>
> 根 -> 顶级 -> 权威

1. 发送 **DNS 请求**给**本地域名服务器**, 查询域名对应的 IP 地址
2. 本地域名服务器**缓存**没找到, 就迭代查询
3. 本地域名服务器迭代查询 : **根域名服务器** -> **顶级域名服务器** -> **权威域名服务器**
4. 本地域名服务器将 IP 地址返回给客户端

> 缓存: 浏览器缓存 -> 操作系统缓存 -> hosts 文件 -> 本地域名服务器

**3. 协议栈**

应用层协议调用 socket 库使用协议栈

操作系统的协议栈: TCP/UDP, IP, ICMP, ARP

> ICMP: 差错信息, 控制信息
>
> ARP: IP 翻译为 MAC

**3.1 TCP**

**TCP 报文**

1. 源/目标端口

2. 序号

3. 确认号

4. 状态位

   > SYN 建立连接
   >
   > ACK 确认
   >
   > RST 重新连接
   >
   > FIN 断开连接

5. 窗口大小

6. 校验和

**三次握手建立连接**

目的: 保证**双方都有发送和接受的能力**

> 查看 TCP 连接状态:
>
> linux netstat -napt

**分割数据**

将 HTTP 数据分割为 MSS, 加上 TCP 头, 组装好 TCP 报文

**3.2 IP**

**确定源/目的 IP**

根据路由表判断将哪个网卡作为源 IP 地址

> route -n 查看路由表
>
> 全零表示默认网关

**拆分组装生成 IP 报文**

**4. MAC**

源/目的 MAC 地址: 路由表 和 ARP 协议(广播)  

> arp -a    ARP 缓存

**5. 网卡**

**网卡驱动程序**, 网卡**缓存**, 开头加**报头**和**帧分界符**, 结尾加**校验序列**

**6. 交换机**

没有 MAC 地址, 直接接收所有包并在 MAC 地址表中查询 MAC 地址并发送到相应端口

**7. 路由器**

路由器端口具有 MAC 地址和 IP 地址, **路由表确定发送端口**, ARP 缓存

**总结:**

报头和起始帧分界符 + MAC + IP + TCP + HTTP + 数据 + FCS

> 最外层由网卡添加, 即报头和起始帧分节符 + FCS 校验序列
>
> 路由器具有最外两层的功能

### ARP 协议

将 IP 地址解析为 MAC 地址

ARP 缓存表: IP 到 MAC 的映射关系

**更新 ARP 缓存表**

广播 ARP 请求: 包含**目标 IP 地址**和**全 1 MAC 地址**

局域网内的**主机或网关**发送 ARP 应答, 告诉 IP 与 MAC 的映射关系

更新 ARP 缓存, 设置 TTL 时间

# TCP

## TCP 基础

### TCP 格式

**seq**: 数据的序号, 每次累加数据的字节数

**ack**: 下次期望的 seq 号

**控制位**:

* ACK : ack 是否有效
* SYN : 建立连接
* FIN : 断开连接
* RST : 强制断开连接

### 为什么需要 TCP

因为 IP 不可靠, TCP 能保证**可靠**

**可靠**

网络包的正常交付, 正常: **不错不乱不多不少**

### TCP 协议

面向**连接**, **可靠**, 基于**字节流**的传输层协议

* 面向连接: 一对一
* 可靠: 不错不乱不多不少
* 字节流: 按字节为最小单位分块转发

### 唯一确定 TCP 连接

四元组: 源 IP, 源端口, 目的 IP, 目的端口

**TCP 最大连接数**

> 服务器 IP 和端口固定

理论 = IP 数 $\times$ 端口数 = $2^{32} \times 2^{16}$ = $2^{48}$

实际: 受**文件描述符**和**内存**限制

> 每个 TCP 连接都是一个文件

### TCP 与 UDP 区别

| TCP                        | UDP                |
| -------------------------- | ------------------ |
| 面向连接                   | 无连接             |
| 一对一                     | 多对多             |
| 可靠                       | 不可靠             |
| 拥塞控制, 流量控制         | 无                 |
| 字节流, MSS 分片, MTU 分片 | 整个报文, MTU 分片 |

> TCP 首部可变长度, UDP 首部长度固定
>
> TCP 数据 = IP - IP 首部 - TCP 首部

**应用场景**

**TCP**

文件传输 FTP, HTTP, 邮件 SMTP 

**UDP**

DNS, 网络管理 SNMP, 多媒体通信

## TCP 建立连接

### TCP 三次握手

![三次握手](.\image\三次握手.png)

**第一次**

客户端 $\rightarrow$ 服务端 

SYN

seq = a

**第二次**

服务端 $\rightarrow$ 客户端

SYN + ACK

ack = a + 1

seq = b

**第三次**

客户端 $\rightarrow$ 服务端

ACK

ack = b + 1

seq = a + len

> 第三次可携带数据

### 为什么不是两次, 四次

三次握手才能**保证双方都有收发数据的能力**

**到达时间**: 

* case1: 包丢了
* case2: 到达时间在**发送时间往后的任一时间点**  

**1. 避免历史连接**

场景:

两个**第一次握手**同时到达服务器, 或**旧的先到达**

服务器发送两个**第二次握手**

**如果是三次握手:**

客户端把 ack 对应不上的那个连接给断开, 发送 rst 中止连接

**如果是两次握手:**

服务端在**旧的第一次握手**到达时就进入 `established` 状态, 然后给客户端发送数据, 客户端发现 ack 对应不上, 于是发送 rst 中止连接
结果: **服务器浪费了资源**, 建立连接后没有任何作用就断开了

结论: 三次握手不会浪费服务器资源

**2. 同步双方初始 seq**

双方初始的 seq 是随机的, 为了告知对方, 只有**第三次握手才会同步好双方的初始 seq**

如果是两次握手, 那么第二次握手时, 客户端不知道服务端的初始 seq

**3. 避免资源浪费**

两次握手时, 对于客户端的每个 SYN 报文, 服务端都要建立一个连接, 造成资源的浪费

> 由于网络原因, 客户端可能会发送多个 SYN 报文

### 初始 seq 为什么随机

**1. 避免接收到历史报文**

如果初始 seq 都是从 0 开始, 可能会出现下述情况:

**上一次连接的报文**被阻塞, 在**当前连接到达服务端**

**恰好 seq 在服务端接收窗口内**, 就会被服务端接收, 发生数据错乱

**2. 防止接收黑客伪造的 TCP 报文**

### 初始 seq 生成

```C++
ISN = M + hash(四元组)		// M 每 4 微秒递增一次
```

### 第一次握手(SYN)丢失

超时重传: 一般重发 5 次, 初始 seq 不变

1s 重传, 2s 重传, 4s 重传, 8s 重传, 16s 重传, 等待 32s 断开连接

> 总耗时 = 1 + 2 + 4 + 8 + 16 + 32 = 63

### 第二次握手(SYN-ACK)丢失

客户端认为第一次握手丢失, 触发超时重传, 重传 SYN

> 重传次数 `tcp_syn_retries`

服务端认为第二次握手丢失, 触发超时重传, 重传 SYN-ACK

> 重传次数  `tcp_synack_retries`

### 第三次握手(ACK)丢失

只有服务端超时重传

> ACK 不会有超时重传

服务端认为第二次握手丢失, 触发超时重传, 重传 SYN-ACK

### 服务端 SYN 队列和 Accept 队列

**1. 第一次握手**

服务端接收 **SYN 报文**时, 会创建一个**半连接对象**, 加入到内核的 **SYN 队列**

**2. 第二次握手**

发送 **SYN-ACK** 报文

**3. 第三次握手**

接收到 **ACK** 报文后, 从 SYN 队列**取出一个半连接对象**, **创建一个连接对象**到 **Accept 队列**中

**4. 通信**

进程通过调用 `accept()` socket 接口, 从 Accept 队列取出连接对象

**注:**

SYN 和 Accept 队列都有长度限制, 超出限制后, 默认丢弃

### SYN 攻击

攻击者短时间伪造并发送不同 IP 地址的 SYN 报文, 并且不回应 服务器的 SYN-ACK 报文

于是服务端的 SYN 队列就会被占满, 正常用户的 SYN 报文就会被丢弃

**避免 SYN 攻击**

* 增大缓冲队列大小

* 增大 SYN 队列大小

* 减少 SYN-ACK 重传次数

* 开启 syncookies 功能

  收到 SYN 报文后, 计算 **cookie** 放在 **SYN-ACK** 报文中发送出去, 收到 ACK 报文后, 检查 ACK 报文合法性, 如果合法, 直接将连接对象放到 Accept 队列中

## TCP 断开连接

### TCP 四次挥手

双方都可以主动断开连接

![四次挥手](.\image\四次挥手.png)

**第一次挥手**

客户端发送 **FIN 报文**

**第二次挥手**

服务端发送 **ACK 报文**

**第三次挥手**

服务端处理完后, 发送 **FIN 报文**

**第四次挥手**

客户端发送 **ACK 报文**, 进入 `time_wait` 状态

服务端收到 ACK 报文后, 进入 `close` 状态, 关闭连接

客户端经过 `2MSL` 后, 进入 `close` 状态, 关闭连接

> 主动关闭连接的才有 time_wait 状态

### 为什么需要四次挥手

第一次握手: 客户端发送 FIN, 表示**不再发送数据但能接收数据**

第二次握手: 服务单发送 ACK, 但可能还有数需要处理发送

第三次握手: 处理完后, 发送 FIN, 表示同意关闭连接

由于**服务端需要等待数据处理完毕后发送 FIN**, 所以服务端的 ACK 和 FIN 一般是分开发送, 所以需要四次挥手

### 为什么 time_wait 时间是 2MSL

MSL: 报文最大生存时间

因为第四次握手 ACK 可能丢失, 服务端会超时重发第三次握手 FIN, 2MSL 至少允许 ACK 报文丢失一次

> 每发送一次第四次握手 ACK time_wait 就会重新计时

### 为什么需要 time_wait 状态

主动关闭连接的一方, 才有 `time_wait` 状态

**1. 防止接收到历史连接中的数据**

历史连接中的报文如果在下一次 TCP 连接中正好在接收窗口内, 就很有可能被接收, 造成数据错乱

**2MSL 的时间足以让两个方向上的数据包都被丢弃, 再出现的数据包一定是新连接产生的**

**2. 保证对方能够正确关闭**

如果第四次握手 ACK 丢失, 对方会超时重传第三次握手 FIN, 2MSL 时间足够用来等待, 第四次握手 ACK 送达

如果 `time_wait` **时间很短**, 收到超时重传的 FIN, 就会发送 **RST 强制断开连接**, 服务端就会认为**出错**了

### time_wait 过大的危害

* 占用系统资源
* 占用端口资源

### 第一次挥手丢失

过程: 调用 `close` 函数后, 发送 FIN

结果: 超时重传 FIN, 最后直接进入 `close` 状态

### 第二次挥手丢失

过程: 服务端发送 ACK

> ACK 不会超时重传

结果: 客户端超时重传 FIN

### 第三次挥手丢失

过程: 调用 `close` 函数, 发送 FIN

结果: 服务端超时重传 FIN, 客户端不需要超时重传, 而是等待一定时间后直接 close

### 第四次挥手丢失

过程: 客户端发送 ACK, 进入 `time_wait` 状态

结果: 服务端超时重传 FIN, 客户端收到后进入 time_wait 状态, 2MSL 后直接 close

## 重传, 滑动窗口, 流量控制, 拥塞控制

### 重传机制

**超时重传**

发送报文后, 超过一定时间没有收到 ACK, 就会重传报文

* 数据丢失
* ACK 丢失

> RTT 往返时延

超时重传时间不应太大或太小, 应略大于 RTT

**快速重传**

收到三个相同 ACK 时, 重传丢失的报文

两种策略: 重传一个报文, 重传后面的所有报文

### 滑动窗口

窗口内的数据可以连续发送

**累计确认**: ACK X 意味着 X 之前的所有报文都收到了

tcp 字段 window 表示**自己缓冲区还能够接收数据的窗口大小**

### 流量控制

