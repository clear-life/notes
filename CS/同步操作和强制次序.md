## 相关概念

### 术语说明

evaluation 表示 operation

## expression

### expression

**表达式是运算符及其操作数的序列**, 完成一个计算

C++ 表达式有两个独立的属性: **type** 和 **value category**

**value category**: 根据表达式的 value 进行分类

> 左值 (lvalue)、右值 (rvalue)、泛左值 (glvalue)、纯右值 (prvalue)、亡值 (xvalue) 

**运算符**: 

任何**感觉能作为表达式**的**都算运算符**

> 可以假定一切都是表达式

* 函数调用: a(...)
* 逗号: a, b
* 算术, 逻辑, 赋值...

### primary expression

**初等表达式**: 表达式的**"原子"**单位, 优先被计算

注: C++ 将**括号表达式**作为原子单位看待, 尽管括号表达式里面也含有初等表达式

```C++
(variable + 10) 是初等表达式
variable 是初等表达式
10 是初等表达式
```

### constituent expression

**成分表达式**是表达式的组成部分的表达式

```C++
x += 1;			x += 1 的成分表达式是 x += 1
x = {1, 2};		{1, 2} 的成分表达式是 1 和 2
    			= {1, 2} 的成分表达式是 {1, 2} 的成分表达式(即 1 和 2)
```

### subexpression

**完整表达式中的任何表达式都是其子表达式**, 除了完整表达式本身

```C++
y = (x + 1) + x;	

y = (x + 1) + x	完整表达式
(x + 1) + x		子表达式
(x + 1)			子表达式
x + 1			子表达式
x				子表达式
```

### full-expression

完整表达式: **完整的表达式**, 不是子表达式也不是成分表达式

### order of evaluation

**order of evaluation**: 指定了中间结果的获取顺序

**compiler** 能以任意顺序计算**操作数** **operand** 和**子表达式** **subexpression**, 即**同级求值顺序未规定**

> 即使同一表达式再次计算也一样

C++ 中没有按从左到右或从右到左顺序求值的概念, 不要与**运算符的结合性**搞混:

expression `a() + b() + c()` 被解析为 `(a() + b()) + c()` 是因为 **operator+** 从左到右的结合性

但是 `a()` `b()` `c()` 三者的求值顺序却是任意的

```C++
int a()
{
    return puts("a");
}

int b()
{
    return puts("a");
}

int c()
{
    return puts("a");
}

void z(int, int, int) {}

int main()
{
    z(a(), b(), c());
}
```

### evaluation of expression

表达式的计算包括:

* **produce result** : 计算表达式的 **value** 是多少
* **side-effect** 的启动: 任何其他能保留下来的结果, 如 read 或 write **volatile glvalue 对象**,  **write 对象**, 调用 I/O 函数, 或其他调用上述操作的函数

### sequence before

**sequence before** 是同一线程内两个 **evaluation** 间的**非对称, 可传递**关系:

> A 和 B 的 sequence before 关系有三种:
>
> * **A sequence before B**
> * **B sequence before A**
> * **A 非 sequence before B** 且 **B 非 sequence before A**
>   * A 和 B unsequenced
>   * A 和 B indeterminately sequenced

* 若 A sequence before B, 则 A 的 **evaluation 结束**早于 B 的 **evaluation 开始**

* 若 A 非 sequence before B 且 B 非 sequence before A, 则有两种可能:

  * A 和 B 的 evaluation **unsequenced**: 可以按任何顺序且重叠地执行(A 和 B 的 CPU 指令混杂乱序)

  * A 和 B 的 evaluation **indeterminately sequenced**: 要么 A 的 **evaluation 结束**早于 B 的 **evaluation 开始**, 要么 B 的 **evaluation 结束**早于 A 的 **evaluation 开始**, 但不会出现**重叠**

    > 下一次执行时的顺序也不确定, 有可能和这次相同, 也可能相反 

**规则**:

1. 完整表达式的子表达式都 **sequence before** 下一完整表达式的所有表达式(包括自身)
2. 运算符**操作数**的 **值计算** 都 **sequence before** 运算符结果的 **值计算**
3. 函数调用时, **参数 sequence before 函数体**
4. 内置 x++ 和 x-- 中, 运算符的 **值计算** **sequence before** 自身的 **side-effect**
5. 内置 ++x 和 --x 中, 运算符的 **side-effect** **sequence before** 自身的 **值计算**
6. 内置 && 和 || 中, 左操作数 **sequence before** 右操作数
7. `?:` 运算符的第一个表达式 **sequence before** 后两个表达式
8. 内置赋值运算符的 **side-effect** (修改左参数), **sequence before** 赋值表达式的**值计算**(该值计算早于返回引用), **sequence after** 左右参数的值计算
9. 内置逗号运算符, 左参数 **sequence before** 右参数
10. 初始化列表中, 逗号左边的初始化子句 **sequence before** 逗号右边的初始化子句
11. 函数调用 A 和函数外另一表达式求值 B, 若 A 既不 **sequence before** B, 也不 **sequence after** B, 则 A 和 B 是 **indeterminately sequenced**
12. **operator new** 的调用 **sequence before**  new 表达式中构造函数的参数
13. 函数返回时, 返回结果(临时对象)的**拷贝初始化 ** **sequence before** return 语句临时变量的销毁, 然后 return 语句临时变量的销毁 **sequence before** 函数局部变量的销毁
14. 函数调用中, 给函数命名的表达式 **sequence before** 所有的参数表达式
15. 函数调用中, 参数表达式的关系是 **indeterminately sequenced**
16. 重载运算符遵从其重载的内置运算符的规则
17. 下标表达式 `E1[E2]` 中, E1 **sequence before** E2
18. 成员指针表达式 `E1.*E2` 和 `E1->*E2` 中, E1 **sequence before** E2
19. 移位运算符表达式 `E1 << E2` 和 `E1 >> E2`, E1 **sequence before** E2
20. 简单赋值运算符 `E1 = E2` 和复合赋值运算符表达式 `E1@ = E2` 中, E2 **sequence before** E1
21. **括号初始化器中** **以逗号为分隔的表达式列表**中的表达式看作**函数调用**(**indeterminately-sequenced**)

**示例**:

`i = ++i;` **well-defined**

```C++
i = ++i;

++i 值计算				a
++i side-effect		  b	
i = ++i 值计算			c
i = ++i side-effect	  d
    
由于 ++i 的side-effect sequence before 值计算, 即 b sequence before a
i = ++i 中的 side-effect sequence after ++i 的值计算, 即 d sequence after a
且 i = ++i 中的 side-effect sequence before 值计算, 即 d sequence before c
所以 b < a < d < c
```

### undefined behavior

未定义行为:

* 若一个 memory location 上的两个 **side-effect** 是 **unsequenced** 的, 则是未定义行为

  ```C++
  i = ++i + 1;	// well-defined
  
  ++i 的 side-effect  sequence before  ++i 的值计算
  ++i 的值计算  sequence before  i 的 side-effect
  所以 ++i 的 side-effect  sequence before  i 的 side-effect
      
      
  i = i++ + 1;	// undefined behavior
  i 的 side-effect  sequence before  i++ 的值计算
  i++ 的 side-effect  sequence before  i++ 的值计算
  但 i 和 i++ 的 side-effect 是 unsequenced, 所以行为未定义
  ```

* 若一个 memory location 上的 **side effect** 与**使用了该 memory location 上值的值计算**是 **unsequenced**, 则是未定义行为

  ```C++
  i = 0;
  n = ++i + i; 	// undefined behavior
  
  对 ++i 和 i 来说:
  
  ++i 值计算			a
  ++i side-effect	  b	
  i 使用			 c
      
  b sequence before a
  c 和 b 的关系是 unsequenced, c 可能读到 b 之前和之后的i, 即 0 或 1
  最终结果为 n == 1 或 n == 2
  ```
  
  

### carriy dependency

携带依赖

同一线程内, 若 evaluation A **sequenced-before** evaluation B, 则 **A carry dependency into B**:

* A 的 value 用作 B 的操作数

  > 除非 A 是内置 `&&` `||` `?:` `,` 的**左操作数**
  >
  > 除非 B 是 kill_dependency()

* A 向标量对象 M **write**, B 从 M **read** 
* **A carry dependency into evaluation X** 且 **X carry dependency into B**

### release sequence

对原子对象 M 执行 **release** 操作 A 后, M 上 **modification order** 的**最长连续子序列**包含:

* A 所在线程的执行的 **write**
* 任何线程在 M 上的 **atomic read-modify-write**

被称为 **A 开头的 release sequence**

### synchronize with

若线程 A 中的 **atomic store** 是 **release** 操作, 线程 B 中在同一变量上的 **atomic load** 是 **acquire** 操作

且 B 中的 **load** 读到的值来自于 A 中的 **store**, 则 A 中的 **store synchronize-with** B 中的 load

### dependency-ordered before

线程间, evaluation A **dependency-ordered before** evaluation B:

* A 在原子对象 M 执行一个 **release** 操作, 在另一线程中 B 对 M 执行一个 **consume** 操作

  并且 B 读到的值来自 **A 开头的 release sequence**

*  **A dependency-ordered before X** 且 **X carry dependency into B**

#### inter-thread happen-before

线程间, evaluation A **inter-thread happen before** evaluation B:

* A **synchronize with** B
* A **synchronize with** X 且 X **sequence before** B
* A **dependency-ordered before** B
* A **sequence before** X 且 X **inter-thread happen-before** B
* A **inter-thread happen-before** X 且 X **inter-thread happen-before** B

### happen-before

无论是线程内还是线程间, evaluation A **happen before** evaluation B:

* A **sequence before** B
* A **sequence before** B

如果某个 evaluation 修改了 memory location, 另一 evaluation 访问了该 memory location

且至少有一个不是原子操作, 则会产生**未定义行为**, 除非两者有 **happen-before** 关系

# 同步操作和强制次序

**synchronizing operation** 和 **enforcing order**

### 非原子操作问题

在同一 memory location 上进行**非原子读写操作**会造成**未定义行为**

* 一方面有指令级的并发
* 一方面非原子操作会被**编译器或处理器**进行**指令重排**, 可能造成预期之外的结果
  * 编译器会将 **atomic load** 和 **atomic store** 视为 **memory fence** 内存栅栏, 并且**进行指令重排时不会越过这个内存栅栏**

```C++
#include <iostream>
#include <thread>
#include <atomic>

using namespace std;

//atomic<int> x{ 0 };
int x = 0;

void func()
{
    for (int i = 0; i < 100000; i++)
    {
        x++;
    }
}

int main()
{
    thread t1(func);
    thread t2(func);
    t1.join();
    t2.join();

    cout << x << endl;

    return 0;
}
```

最终的结果一般在 100000 ~ 200000 之间, 原因是**指令级的并发**

```C++
x++ 一般分为三个指令
    
memory x -> register r
r++
register r -> memory x
```

### 场景

两个线程, 一个生产数据, 一个读数据

为了避免条件竞争, 使用 **flag** 表示数据已准备好, 读线程等 `flag == true` 成立才读取数据

```C++
vector<int> arr;
atomic<bool> flag(false);

void write()
{
    arr.push_back(1);		a1
    flag = true;			a2
}

void read()
{
    while(!flag.load())		b1
        sleep();
    cout << arr[0] << endl;	b2
}
```

这段代码中: 

非原子的读写操作所需的**强制排序** **enforcing order** 来自 `atomic<bool> flag` 上的操作

因子这些原子操作提供了 **happen-before** 和 **synchronize-with** 内存模型关系(**memory model relation**)

> 具体来说, 原子对象 flag 上的操作作为内存栅栏/内存屏障, 使得编译器或处理器进行指令重排时不会越过该内存栅栏

数据的 write 操作 a1 **happen-before** flag 的 write 操作 a2

> 即 a1 永远在 a2 前面执行 	a1 < a2

flag 的 read 操作 b1 **happen-before** 数据的 read 操作

> 即 b1 永远在 b2 前面执行 	b1 < b2

当 flag 变为 true 时, 数据的 write 操作就 **synchronize-with** 数据的 read 操作, 构成了 **happen-before** 关系

$~$

write **happen-before** read 推导过程如下: 

当 write synchronize-with read 时, 构成了 happen-before 关系

即 write 永远在 read 前面执行, write < read	a1 < b2

推导过程为:

a1 happen-before a2, 则 a1 < a2

b1 happen-before b2, 则 b1 < b2

而只有当 a2 执行完后, b1 才会执行, 即构成 a2 happen-before b1 关系, a2 < b1

由于 happen-before 关系可传递

由上面知:

a1 happen-before a2

a2 happen-before b1

b1 happen-before b2

所以 a1 和 b2 构成 happen-before 关系, a1 < b2

总的来说 a1 < a2 < b1 < b2, 最终利用**原子操作**强制**非原子操作**遵从了某种次序

$~$

根据上述分析, 最终得到了 **enforced ordering**:  write of data **happen-before** read of data

下列展示这一过程中的几个 happen-before 关系:

```C++
write:					read:
{						{
    arr.push_back(1)		flag.load() 	返回 false
    flag = true				flag.load()		返回 false
        					flag.load()		返回 true
        					arr[0]			返回 1
}						}
```

![](.\image\happen-before.png)

### synchronize-with 关系

**synchronize-with** 关系只存在于**原子类型上的操作**间

如数据结构(原子类型成员)上的原子操作可能展现出这种**同步关系**

但本质上 **synchronize-with** 关系来源于**原子类型上的操作**

**作用**:

在变量 x 上, 适当 **memory order** 修饰的 **atomic write** 操作(记为 W)  **synchronize-with** 适当 **memory order** 修饰的 **atomic read** 操作:

* read 操作读到 W 写入的值
* read 操作读到 W 所在线程中在 W 之后的对 x 的 **atomic write** 写入的值
* read 操作读到**任意线程**作用在 x 上的 **atomic read-modify-write** 操作 **sequence**(序列)所写入的值, 此 **sequence** 的第一个 **read** 读到的值是 W 写入的值

**示例**:

```C++
shared variable x;

A:				B:				
{				{
    				x.CAS();		cas0
    x.write(1);						w1 == W
                    x.write(2);		w2
    				x.CAS();		cas1
    x.write(3);						w3
    x.CAS();						cas2
                    x.CAS();		cas3
}				}
```

atomic write W **synchronize-with** atomic read R 的含义是:

若 R 在 W 后面执行, 则 R 不可能读到 W 前面 write 操作写入的值

> W 代指 w1 write 操作, R 表示时间上在 W 后执行的 read 操作
>
> 则 R 不可能读到 w0 写入的值

* R 读到 W 写入的值

* R 读到 w3 写入的值

* R 读到 **read-modify-write** sequence `cas1 cas2 cas3` 中的某一个操作写入的值

  注意该序列的第一个 read 操作读到的必须是 W 写入的值

**分析**

**case1**:

R 读到 W 的值, 显然能说明 **W synchronize-with R**, 形成同步关系

**case2:**

R 读到 W 所在线程后续 write 的值, 即示例中 w3 的值

**case3:**

R 读到 **read-modify-write** sequence 中某个操作写入的值, 该序列的第一个读操作读到的是 W 写入的值

示例中该序列为 `cas1 cas2 cas3` 不包括 cas0 是因为其在 W 之前发生

必须是 **read-modify-write** sequence 的原因是要建立**同步关系**, 如果只是单纯的 write 操作(例如 w2), 写入的值跟 W 写入的值没有**相关性**, 自然就谈不上**同步关系**

> 与 W 在同一线程的 write 操作就能与 R 建立同步关系, 因为 x 后续的值对该线程可见

### happen-before 关系

**happen-before** 和 **strongly-happen-before** 关系是**确立操作次序**的基础

作用是**界定**哪些 **operation** 能够看到另一 **operation** 的  **effects**

**线程内**

若 operation A **sequence before** operation B

则 **A happen before B**, 且 **A strongly-happen-before B**

若同一语句有多个操作, 则没有 happen-before 关系, 因为 C++ 没有规定这种顺序, 所以**编译器可以任意重排**

**线程间**

若某一线程内的 operation A **inter-thread happen before** 另一线程的 operation B, 则 A happen before B

