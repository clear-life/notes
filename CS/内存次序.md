# 内存次序基础

## 内存模型

### 内存位置

**memory location**:

* 标量对象
* 非零位域最长连续序列

### 数据竞争

在同一**内存位置**上, **表达式 A write**, **表达式 B read 或 modify**, 就称**表达式 A 和 B 冲突**

存在表达式冲突就有数据竞争, 除非:

* A 和 B 在同一线程内
* A 和 B 是原子操作
* A 先发生于 B 或 B 先发生于 A

若出现数据竞争, 则行为未定义

```C++
int x = 0;
auto f = [&]{x++;};
thread t1(f), t2(f), t3(f);	// 行为未定义
```

```C++
#include <thread>
#include <atomic>

using namespace std;

int x = 0;

void func()
{
    for (int i = 0; i < 100000; i++)
        x++;	
}

int main()
{
    thread t1(func), t2(func);
    t1.join();	t2.join();

    cout << x << endl;	// 100000 ~ 200000

    return 0;
}


x++ 分三个指令执行:

memory x -> register r
r++
register r -> memory x
```

### 改动序列

原子变量上的**修改操作**的**全序序列**

## 操作间的关系

### 同步关系

**同步关系只存在于原子操作间**

**定义:** 同一内存位置上, 线程 1 上**原子 release store 操作 A** , 线程 2 上**原子 acquire load 操作 B**, 若下列任一为真, 则 **A 同步于 B**

* B 读取了 A 直接存入的值
* B 读取了 A 所在线程 A 后面的**原子写操作的值**
* B 读取了**任意线程在该内存位置上 RMW 操作序列写入的值**, 该序列第一个写入的值为 A 写入的值

**示例**:

```C++
shared variable x;

A:				B:				
{				{
    				x.CAS();		cas0
    x.write(1);						w1
                    x.write(2);		w2
    				x.CAS();		cas1
    x.write(3);						w3
    x.CAS();						cas2
                    x.read();		r
}				}
```

A 同步于 B 的含义是: **B 不可能读到 A 前面写操作写入的值**

若 w1 同步于 r, 则:

* r 读到 w1 的值(规则1)

* r 读到 w3 的值(规则2)

* r 读到 cas1 和 cas2 的值(规则3)

  > 不包括 cas0 是因为 cas0 是 w1 之前的操作

### 先行关系

先行关系是操作次序的基础, 它界定了**哪些操作能够看到某一操作产生的效果**

下列任一为真, 则**操作 A 先发生于操作 B**:

* A 先序于 B
* A 线程间先发生于 B

**线程内**

按控制流程顺序 A 在 B 之前执行, 则 A 先序于 B

**线程间**

线程间先发生于**基于同步关系**: **若 A 同步于 B** 且由不同线程执行, 则 **A 线程间先发生于 B**

线程间先发生于有**传递性**: 若 A 线程间先发生于 X, X 线程间先发生于 B, 则 **A 线程间先发生于 B**

线程间先发生于可**与先序于结合**:

* 若 A 先序于 X, X 线程间先发生于 B, 则 **A 线程间先发生于 B**
* 若 A 同步于 X, X 先序于 B, 则 **A 线程间先发生于 B**

> 强先发生于与先发生于大部分情况下一致, 仅在 **memory_order_consume** 上不同, 即强先发生于关系没有该 tag

### 示例

通过原子对象 `flag`, a2 和 b1 形成**同步关系**

由于线程内的控制流, a1 与 a2, b1 与 b2 形成**先行关系**

```C++
vector<int> arr;
atomic<bool> flag(false);

void write()
{
    arr.push_back(1);		a1
    flag = true;			a2
}

void read()
{
    while(!flag.load())		b1
        sleep();
    cout << arr[0] << endl;	b2
}
```

原子对象 `flag` 上的操作作为**内存栅栏**, 编译器和处理器进行**指令重排时不会越过内存栅栏**

于是通过原子对象 `flag` 的**同步关系**和 `flag` 与其他非原子操作的**先行关系**, 非原子操作的执行顺序得到了保障

总的来说 a1 < a2 < b1 < b2, 最终利用**原子操作**强制**非原子操作**遵从了某种次序

```C++
write:					read:
{						{
    arr.push_back(1)		flag.load() 	返回 false
    flag = true				flag.load()		返回 false
        					flag.load()		返回 true
        					arr[0]			返回 1
}						}
```

![](D:\workspace\repositories\studynotes\CS\image\happen-before.png)

$~$

# 内存次序

一共有 6 种**内存次序**

```C++
enum memory_order 
{
    memory_order_relaxed,
    memory_order_consume,
    memory_order_acquire,
    memory_order_release,
    memory_order_acq_rel,
    memory_order_seq_cst
};
```

分别代表了 3 种模型:

* **sequentially consistent ordering** **顺序一致次序**
  * memory_order_seq_cst
* **acquire-release ordering** **获取-释放次序**
  * memory_order_consume
  * memory_order_acquire
  * memory_order_release
  * memory_order_acq_rel
* **relaxed ordering** **宽松次序**
  * memory_order_relaxed

### 顺序一致次序

**sequentially consistent ordering**

**所有操作形成一个全序序列**, 就像所有操作在同一线程执行一样, 所有线程与该全序序列一致

> 看起来好像没有指令重排, 所有操作按照代码的方式执行

```C++
#include <atomic>
#include <thread>
#include <assert.h>

using namespace std;

atomic<bool> x, y;
atomic<int> z;

void write_x()
{
	x.store(true, memory_order_seq_cst);
}

void write_y()
{
	y.store(true, memory_order_seq_cst);
}

void read_x_then_y()
{
	while (!x.load(memory_order_seq_cst));
	if (y.load(memory_order_seq_cst))
		++z;
}

void read_y_then_x()
{
	while (!y.load(memory_order_seq_cst));
	if (x.load(memory_order_seq_cst))
		++z;
}

int main()
{
	x = false;
	y = false;
	z = 0;

	thread a(write_x);
	thread b(write_y);
	thread c(read_x_then_y);
	thread d(read_y_then_x);

	a.join();
	b.join();
	c.join();
	d.join();

	assert(z.load() != 0);
}
```

由于 x 和 y 上的 **store 和 load 的同步关系**, 所以形成了两个先行关系:

```C++
A:
{
    x.store(true, memory_order_seq_cst);	a1	// store 与 load 的同步关系
    while (!x.load(memory_order_seq_cst));	a2	// 同一线程内的先行关系
	if (y.load(memory_order_seq_cst))		a3
		++z;
}

B:
{
    y.store(true, memory_order_seq_cst);	b1	// store 与 load 的同步关系
    while (!y.load(memory_order_seq_cst));	b2	// 同一线程内的先行关系
	if (x.load(memory_order_seq_cst))		b3
		++z;
}
```

**全序序列**总共有 20 种情况, 18 种情况下 `z == 2`, 剩余两种情况下 `z == 1`

```C++
// 20 种所有情况
a1  a2  a3  b1  b2  b3  
a1  a2  b1  a3  b2  b3  
a1  a2  b1  b2  a3  b3  
a1  a2  b1  b2  b3  a3  
a1  b1  a2  a3  b2  b3  
a1  b1  a2  b2  a3  b3  
a1  b1  a2  b2  b3  a3  
a1  b1  b2  a2  a3  b3  
a1  b1  b2  a2  b3  a3  
a1  b1  b2  b3  a2  a3  
b1  a1  a2  a3  b2  b3  
b1  a1  a2  b2  a3  b3  
b1  a1  a2  b2  b3  a3  
b1  a1  b2  a2  a3  b3  
b1  a1  b2  a2  b3  a3  
b1  a1  b2  b3  a2  a3  
b1  b2  a1  a2  a3  b3  
b1  b2  a1  a2  b3  a3  
b1  b2  a1  b3  a2  a3  
b1  b2  b3  a1  a2  a3
```

```C++
// z == 1 的两种情况
a1 a2 a3 b1 b2 b3
b1 b2 b3 a1 a2 a3
```

## 非顺序一致次序

最大特点是**没有全序序列**, **线程间不必就操作次序达成一致**

* 对同样的一组操作, 不同线程看到的**次序和效果**可能不同

  * 必须有**真正的并发思维**, 舍弃线程操作交替执行的思维模式

    > 即所有操作同时发生

  * **线程间不必就操作次序达成一致**

    > 即对于操作 A 和 B, 线程 1 可能看到 A B 的次序, 线程 2 可能看到 B A 的次序

* **非顺序一致次序**的问题

  * 不仅仅在于编译器的**指令重排**

  * 还在于**CPU缓存**和**内存缓冲**

    > 即对于同一 **memory location**, memory, CPU cache 和 internal buffer 可能持有不同的值, 即很容易在不变量被破坏的情况下访问 memory location 

* 唯一的限制是**所有线程对每个变量的改动序列达成一致**

  > 如果没有额外的内存次序限制, 所有线程仅仅会在每个变量的改动序列上达成一致, 除此之外任何情况都会发生

### 宽松次序

**relaxed ordering**

**宽松次序没有同步关系**
