# 循环不变式在递归函数中的简单应用

### 问题 

输出从 n 个数中选 m 个数的所有组合

### 核心代码

```C++
int n, m;
vector<vector<int>> res;
vector<int> t;

dfs(1, 1)

void dfs(int start, int k)
{
    if(k == m + 1)
    {
        res.push_back(t);
        return;
    }

    for(int i = start; i <= n; i++)
    {
        t.push_back(i);
        dfs(i + 1, k + 1);
        t.pop_back();
    }
}
```

$~$

## 循环不变式

### 循环不变式

 数组 t 存储从 `[1, start)` 中选 `k - 1` 个数的当前组合

> dfs(start, k) 的含义是从 [start, n] 中选择当前组合的第 k 个数

$~$

### 情况说明

**1. 递归函数中的"循环"如何定义 ?**

目前暂定为从根节点到叶节点的一条路径代表一个循环, 循环所有路径是一个循环

也就是说把此问题的递归函数看作两重循环

```C++
for path in 所有从根节点到叶节点的路径
    for node in path
```

> 所说把递归函数抽象为二重循环, 但我们在证明时并未界限分明地显示出这一点, 这一部分我还没有想好

对应到代码中, 意味着调用一次 dfs 函数就是一次循环

$~$

**2. 循环不变式的终止并不是递归函数的终止**

循环不变式的终止其实对应着递归函数的最底层, 也就是叶节点

在普通 for 循环和 while 循环中, 循环不变式的终止意味着循环的结束

但在此处的递归函数中, 循环不变式的终止意味着当前**根节点到叶节点的路径**结束, 递归函数回溯并开始**下一条根节点到叶节点的路径**

$~$

### 证明

 数组 t 存储从 `[1, start)` 中选 `k - 1` 个数的当前组合

> dfs(start, k) 的含义是从 [start, n] 中选择当前组合的第 k 个数

$~$

**初始化**

dfs(1, 1), 即 start = 1, k = 1, t 为空

`[1, 1)` 为空, `k - 1 = 0`, t 为空

循环不变式显然成立

$~$

**保持**

当前循环为 `dfs(start, k)`

假定 t 已经存储从 `[1, start)` 中选 `k - 1` 个数的当前组合

我们将证明: `dfs(start, k)` 会从 `[start, n]` 中选择一个数作为当前组合的第 k 个数

$~$

当前循环的代码: 

```C++
for(int i = start; i <= n; i++)
{
    t.push_back(i);
    dfs(i + 1, k + 1);
    t.pop_back();
}
```

显而易见的, 此 for 循环会从 `[start, n]` 中从小到大挨个尝试选择一个数 `i` 作为当前组合的第 k 个数

$~$

于是, t 存储了从 `[1, i]` 中选 k 个数的当前组合

然后进行下一轮循环 `dfs(i + 1, k + 1)` , start 更新为 i + 1, k 更新为 k + 1

于是, 在循环变量 start, k 更新之后, 下一轮循环 `dfs(i + 1, k + 1)` 开始之前, 循环不变式成立

$~$

**终止**

循环结束时, dfs(start, k), k = m + 1 

> 此处的循环指的是从根节点到叶节点的循环

于是 t 存储从 `[1, start)` 中选 m 个数在当前组合, 满足题目要求

> start 最大为 n + 1
>
> 这一点从 for i  =  start  to  n	dfs(i + 1, k + 1) 中得到体现

$~$

### 总结

总的来讲, 我们证明了在一次 dfs 递归函数递归至底层时(也就是到叶节点时),  t 存储了从 n 个数中选 m 个数的当前组合

> 其实这个说法并不太严谨, 因为存在 t 不符合要求的情况, 到叶节点时, 当前路径上的结点数可能比 m 小
>
> 但对于循环的终止, 即 k = m + 1 时, 此时的 t 一定满足条件

### 展望

对于情况说明 1 中的第一重循环, 也就是对所有路径的循环, 由于并未存在明显的循环终止条件,  所以还没想好如何说明, 也许并不需要证明第一重循环, 两重循环是混合着的