# C++ 基础

### C++ 编译过程

**预处理** $\rightarrow$ **编译** $\rightarrow$ **汇编** $\rightarrow$ **链接**

1. **预处理**

   处理**预编译指令**, 删除**注释**, 添加**行号**和**文件标识**

2. **编译**

   **词法**分析, **语法**分析, **语义**分析 

   **中间代码**生成, **代码优化**

   **目标代码**生成

3. **汇编**

   根据汇编指令与机器指令**对照表挨个翻译**

4. **链接**

   将**二进制文件**, **动态库**和**静态库**打包生成**可执行文件**

### C++ 内存分区

五大区: 堆, 栈, 静态区, 常量区, 代码区

**栈(stack)**: 操作系统

**堆(heap)**: 程序员

**静态区(static)**: 全局变量和静态变量, 细分为**初始化区**和**未初始化区**

**常量区(const)**: 常量

**代码区**: 程序二进制代码

### 堆区和栈区的区别

| 区别     | 栈(stack)    | 堆(heap)                 |
| -------- | ------------ | ------------------------ |
| 控制     | **操作系统** | 程序员, **手动申请释放** |
| 数据结构 | 栈           | 链表                     |
| 方向     | 由高到低     | 由低到高                 |
| 效率     | 高           | 低                       |

> 操作系统有一个记录空闲内存地址的链表
>
> 遍历链表, 找到第一个大于申请空间的堆节点, 然后将该节点分配给程序

### inline 和 define 区别

**define**

**预处理** , **简单替换**, 不**参数检测**和**访问控制**检测

**inline**

**编译**, **建议**编译器**展开**, **函数**, **参数检测**, **类型安全**

没有调用函数, **少了入栈出栈**的过程, 用**空间换时间**

类内成员函数默认为 inline

### sizeof 和 strlen 区别

|      | sizeof             | strlen                             |
| ---- | ------------------ | ---------------------------------- |
| 类型 | **运算符**         | **函数**                           |
| 作用 | **分配**的内存大小 | 到 '\0' 有几个字符                 |
| 时期 | **编译**           | **运行**                           |
| 指针 | 指针的大小         | 从指针开始, 到 '\0' 结束有几个字符 |
| 参数 | 类型               | **char***                          |

### memcpy

> 优化: 字节流中每次取 4 个字节

```C++
void* memcpy(void *des, const void *src, size_t n)
{
    if(des == nullptr || src == nullptr)
        return nullptr;
    if(des == src)
        return des;
    
    char *a = static_cast<char*>(des);
    const char *b = static_cast<const char*>(src);
    
    if(a > b && a < b + n)
        for(size_t i = n - 1; i != -1; i--)
            a[i] = b[i];
    else
        for(size_t i = 0; i < n; i++)
            a[i] = b[i];
}
```

### static

C 初始化发生在编译阶段

C++ **全局对象**和 **static 对象**首次调用时才**构造并初始化**, 按照**构造的反方向析构**

拓扑构造, 反拓扑析构

### static 变量

* static 成员属于整个类, **初始化**时在**类外分配空间**
* 声明时加 static, 初始化时不加 static
* **staitc 全局变量**只能作用于本文件, **不能跨文件使用**

### const

**const:** **只读**, **定义时初始化**

**底层 const**

修饰指向的对象

`const int *p = &a` 或 `int const *p = &a`

**顶层 const**

修饰指针本身

`int * const p = &a`

> 权限: 底层 const 权限高, 顶层 const 权限低

**const 成员函数** 

相当于底层 const this 指针

### 为什么要区分顶层 const 与底层 const

1. **底层 const** 必须**由底层 const 接收**
2. **底层 const** 可以**区分函数重载**, 顶层 const 不能
3. **const_cast** 只能去掉**底层 const **的 const 属性

### 顶层 const 与底层 const 的比较

**顶层 const 不能区分参数**

```C++
// 顶层 const
int 与 const int 比较
    
int 	  	能接收 int 和 const int
const int 	能接收 int 和 const int
    
    
int * 与 int * const  比较
    
int * 		能接收 int * 和 int * const
int * const 能接收 int * 和 int * const
    
// 结论: 顶层 const 不能用于区分参数
```

**底层 const 能区分参数**

 ```C++
// 底层 const
int * 与 const int * 比较
    
int * 		只能接收 int *
const int * 能接收 int * 和 const int *
    
// 结论: 底层 const 能用于区分参数
 ```

**顶层 const 与底层 const**

```C++
// 顶层 const 与底层 const
int * const 与 const int * 比较
    
int * const	只能接收 int * const  
const int * 能接收 int * const 和 const int *
```

> 底层 const 权限高, 顶层 const 权限低
>

### volatile

volatile 表明变量随时有可能被修改, 要**直接访存取值**

应用: 多线程**两个线程访问同一变量**, 一个访问内存, 一个访问寄存器

### 四种类型转换符

> http://c.biancheng.net/view/2343.html

**static_cast**

大多数情况

1. **基本类型**转换

2. **指针**转换

3. **转换构造函数**或**类型转换函数**

   > 转换构造函数: 其他类型->当前类		
   >
   > ```C++
   > 一个参数的构造函数
   > ```
   >
   > 类型转换函数: 当前类->其他类型
   >
   > ```C++
   > operator int()
   > {
   >     return int;
   > }
   > ```


**const_cast**

去掉**底层 const** 的 const 属性

**reinterpret_cast**

二进制位的重新解释

> int 和指针
>
> A* 和 B*

**dynamic_cast**

RTTI 运行时转换**父子指针**

up: **子转父**, 无条件, 不检测

down: **父转子**, RTTI 检测是否安全

失败: 指针失败返回 NULL, 引用失败抛出 `std::bac_case` 异常

过程: 对指针进行类型转换时, 从**指针指向的对象的类**开始, 向上遍历**继承链**, 如果找到了**目标类型**, 就说明是**安全**的

### C++ 11 新特性

**1. 类型推导**

auto 推导**变量**类型

decltype 推导**表达式**类型

**2. 右值引用**

引用方式使用 C++ 右值

> 左值 loactor value 可寻址的值
>
> 右值 read value 临时对象, 只用来读的值

用于**移动语义**和**完美转发**

**3. 智能指针**

**4. 范围 for 循环**

**5. nullptr**

解决二义性

null 就是 0, nullptr 表示空指针

```C++
#define NULL ((void *)0)	// NULL 是一个宏, void* 类型的 0

void fun(int x);
void fun(char *x);

fun(NULL);		// 产生二义性, void * 可以隐式转换为 int 和 char * 
```

**6. 列表初始化**

**std::initializer_list**

什么时候**必须用到列表初始化**

1. **const **和**引用**
2. 必须调用构造函数时
   1. 没有**无参构造函数**
   2. 调用**父类构造函数**

### 移动语义

将一块内存单元转移到另一个对象

### 深浅拷贝

**浅拷贝**, 拷贝前后的**指针指向同一内存**

**深拷贝**, 拷贝前后的**指针指向不同内存**

**默认拷贝构造函数**是**浅拷贝**

### C 和 C++ 区别

C++ 比 C 多了**面向对象**,**泛型编程(STL)**, **元编程**

### RTTI 机制

> Run Time Type Identification 运行时类型识别

只适用于**多态机制**, **运行时**确定指针指向的对象类型

### 大端和小端

**大端**

高位低地址, 低位高地址

**小段**

高位高地址, 低位低地址

**计算机一般用小端**

> cpu 发送和接收网络数据包时, 都要反转一次

**通信一般用大端**

字节序符合大端规定, 符合人类习惯

### lambda

**匿名函数**, 简化代码

```C++
int x = 1, y = 2;
auto fun = [x, &y](int a, double b) -> int { return a + b + x; };

fun(2, 1.0);	
```

**变量捕获**

1. [] 不捕获
2. = 值传递
3. & 引用传递
4. this 传递 this 指针

# 面向对象

**封装**, **继承**, **多态**

## 封装

**类封装**: 将**数据和方法**封装在一起

## 继承

**好处:**

提高**代码复用**性

**坏处:**

耦合性增强, **独立性减弱**

> 编程原则: **高内聚, 低耦合**

**属性级别**

1. **private**

   **本类**

2. **protected**

   **本类及子类**

3. **public**

   **任何人**

**继承级别:**

**private > protected > public**

继承后: 级别**高的不变**, 级别**低的拉高到继承级别**

## 多态

**同名函数不同功能**

分类: 

1. **编译时多态**(静态多态): **函数重载**
2. **运行时多态**(动态多态): **虚函数, 继承**

### 函数重载

同一作用域, **参数列表**不同

**本质:** 能否区分不同参数

**函数重载命名**

编译器对函数**重命名**, 保证唯一性

* **构造函数可以被重载**: 因为可以**带参数**
* **析构函数不可以被重载**: 因为**没有参数**

### 多态底层实现

**虚表**

**编译器**会为有虚函数的类生成一个**虚表**, 保存**虚函数地址**, 存储在进程的**只读数据段**

**虚表地址 vptr**

**编译器**会在**类对象创建**时将其**前四个字节**设为虚表的地址, 用 `vptr` 表示

类对象 `a` 的 `vptr = *(int*)(&a)`  

第一个虚函数指针 `fun *p = *(int*)vptr = *(int*)*(int*)(&a)`

> 虚表相当于类的 static const 成员

**虚表创建**

编译时会对每个类创建一个虚表, **重写的覆盖**, **新增的添加**, **不变的不变**

**复制父类虚表**内容, 然后重写的覆盖, 新增的添加

**动态绑定**

父类指针指向子类对象, 只能访问**子类对象虚表中父类的部分**(**重写和不变**的部分)

> **父类指针限制**调用函数, 通过**子类对象的 vptr 访问子类对象的虚表**, 进而访问实际的虚函数

父类指针做**框架限制**, 子类对象做**实际调用**, 实际调用要在框架限制之内

## 类基础

### struct 和 class 区别

**struct** 属性和继承默认为 **public**

**class** 属性和继承默认为 **private**

**class 可以使用模板, struct 不能用模板**

### 重载, 重写, 隐藏的区别

**重载**

同一作用域, 同名函数, 不同参数列表

**重写**

继承作用域, 函数头相同

**隐藏**

不同作用域, 函数名相同, 参数列表可以相同, 可以不同

### 类内存分布

**1. 空类**

一个字节, 占位符

**2. 没有虚函数**

数据成员, **内存对齐**

**3. 有虚函数**

多一个四字节的 vptr 指针

**继承中的内存分布**

子类**继承父类的空间**, **自己定义的变量**放在**父类变量的下面**

如果子类定义了与父类同名的变量, 调用时就会**隐藏父类变量**, 但**父类变量本身依然存在**

### 内存对齐

1. 内存顺序与声明**顺序一致**
2. **类的大小**是**对齐单位 c** 的倍数
3. 变量的**偏移**量是 `min(type, c)` **倍数**

```C++
对齐单位: c = min(对齐系数, 最大类型)
```

### this 指针

不是类的成员, 只是非 static 函数隐含的参数, **顶层 const 指针**

## 虚函数

### 静态函数可以是虚函数吗

本质: **静态函数属于类**, 虚函数属于对象

原因: 静态函数**没有 this 指针**, **无法访问 vptr**, 也就不能访问虚表

### 构造函数和析构函数能否被继承

**不能**, 名字不一致, 不能成为子类的构造函数和析构函数

### 构造函数可以是虚函数吗

**不可以**, **构造函数不被继承**, 不可能被重写, 达不到多态的目的

### 构造函数能否调用虚函数

可以, 但会**屏蔽多态机制**, 将虚函数当作普通函数使用, 不会调用被子类重写的函数

**原因**

创建对象时, 先调用**父类构造函数**, 对象的**虚表**和**函数**还未初始化, 为了**避免父类构造函数调用到未初始化的内存**, 于是规定此时使用**静态绑定**, 不发生多态

> 构造子类时调用父类构造函数, 父类构造函数又调用了虚函数, 该虚函数即使被子类重写, 也不发生多态行为

```C++
#include <iostream>

using namespace std;

class A
{
public:
    A() 
    { 
        fun(); 
    }
    virtual void fun()
    {
        cout << "A" << endl;
    }

    void fun2()
    {
        fun();
    }
};

class B : public A
{
public:
    B() 
    { 
        fun(); 
    }
    
    virtual void fun()
    {
        cout << "B" << endl;
    }
};

int main()
{
    B b;
    b.fun2();
    return 0;
}

/*
A	构造函数屏蔽多态
B
B	普通函数的多态行为
*/
```



### 析构函数可以是虚函数吗

父类的析构函数最好是虚函数

父类指针指向子类对象, delete 父类指针时, 需要调用**具体子类对象**的析构函数, 也就是需要有多态机制

调用子类对象的析构函数: 从子类到父类依次调用析构函数, 即**析构函数链式析构**

### 如果析构函数不是虚函数, 一定会出现内存泄漏吗

不一定

如果子类**没有用指针开辟空间**, 就**不会出现内存泄漏**

如果子类用指针开辟空间,  delete 父类指针时, 如果析构函数不是虚函数, 就**只调用父类的析构函数**, 造成内存泄漏

### 虚函数的安全性

**子类对象**可以通过直接访问前四个字节(即 vptr) 访问**虚表**, 进而访问到**父类对象的 private 虚函数**, 破坏了封装特性

```C++
#include<iostream>

using namespace std;

class Base {
private:
	virtual void f() {
		cout << "Base::f" << endl;
	};
};

class Derive : public Base {

};
typedef void(*Fun)(void);

int main() {

	Derive d;

	Fun pFun = (Fun)*((int*)*(int*)(&d));

	pFun();

    return 0;
}
```

### 抽象类

含有**纯虚函数**的类, "根节点"

**本质**: 抽象概念的类, 没有实际对象

```C++
virtual fun() = 0;
```

限制: 

* **不能实例化对象**
* **不能作为实际对象的类型**使用

子类:

* 必须**实现所有纯虚函数**才是一个普通类

多态:

* 可以**定义抽象类的指针和引用**, 然后指向子类, 进而实现**多态**

### 析构函数可以是纯虚函数吗

**可以, 但必须定义函数体**

因为析构函数不被继承, 不能被子类实现, 但却会被子类析构函数调用

### override 和 final

**override**

表明是**重写**, 方便编译器判断

**final**

不希望类被继承, 不希望虚函数被重写



## 成员函数

和普通函数一样存放在代码区, 非静态成员函数隐含 **this 指针**

**编译**时确定调用**普通函数**

**运行**时确定调用**虚函数**

### static 成员函数

没有 this 指针, 只能调用**静态成员**

既能通过**对象访问**, 也能通过**类访问**

### 构造函数

1. 申请内存
2. 初始化列表
3. 构造函数体

> 自定义构造函数后, 编译器就不会自动生成构造函数了

### 拷贝构造函数

用拷贝的方式构造对象

```C++
class A
{
    A(const A &a);
}
```

**使用场景**

1. 初始化

   ```C++
   A a(b);
   A a = b;	// 不是赋值语句, 而是初始化语句
   			// 赋值语句的左边是已经定义好的变量
   ```

2. 参数传递

   ```C++
   fun(A a);
   ```

3. 函数返回

   ```C++
   A fun();
   ```

### 类默认生成哪几个成员函数

编译器默认生成 6 个成员函数:

**构造**函数, **拷贝构造**函数, **析构**函数

**赋值**运算符, 两个**取址**运算符

```C++
class A
{
    A();
    A(const A&);
    ~A();
    A& operator=(const A&);
    A* operator&();
    const A* operator&() const;
}
```

### const 成员函数

const 成员函数**不能修改数据成员**, 相当于 `const int* vptr` 给 `vptr` 加上底层 `const` 属性

**本质**: 把函数看作指针, 访问数据成员看作访问指向的对象, **不能修改数据成员**看作**不能修改指针指向的对象**, 那么 const 成员函数就看作底层 const

```C++
class A
{
    void fun();
	void fun() const;
}

// const 成员函数
fun() 与 fun() const 比较
    
fun() 		只能接收 A 对象
fun() const 能接收 A 对象和 const A 对象
    
// 结论: const 成员函数相当于底层 const
```

### 赋值运算符

两个对象均已存在

```C++
class A
{
    A& operator=(const A &b)
    {
        if(this != &b)
        {
            ...
        }
        return *this;
    }
}
```

### 赋值运算符与拷贝构造函数的区别

**赋值运算符**: 两个类对象已经存在

**拷贝构造函数**: 一个存在, 一个不存在

```C++
class A
{
    int *p;
    
    A(const A &b)				// 拷贝构造函数
    {
        p = new int(*b.p);
    }
        
    A& operator=(const A &b)	// 赋值函数
    {
        if(this == &b) return *this;

        delete p;			// 清空左边
        
        p = new int(*b.p);	// 重新赋值
        
        return *this;
    }
}
```

### 什么时候必须用初始化列表

必须**初始化**, **不能赋值**时

1. **const **和**引用**的初始化

2. 需要**初始化的数据成员是对象**时, 且该**对象只有含参构造函数**, 没有无参构造函数

   > 初始化列表构造, 函数体复制

3. 子类**初始化父类私有成员**


### 多继承

一个节点有多个父节点, 形成一个**拓扑图**

**构造函数**

**构造函数调用顺序**与初始化列表顺序无关, 与**声明顺序一**致

```C++
class C : public A, public B
{
    C() : B(...), A(...)	// 先调用 A, 再调用 B
}
```

**问题**

**命名冲突**, 不知道来自哪个父类, 容易出现**二义性**, 需要**显式指明**来自哪个类

# 动态内存

### new 和 malloc

**new**

1. **申请内存**: **operator new 函数**
2. **初始化**: **构造函数**

**delete**

1. **析构**: **析构函数**
2. **释放内存**: **operator delete 函数**

> 内置类型没有构造函数和析构函数

**new []**

**前四个字节**写入数组大小 n, `operator new[]` 申请内存后, 调用 **n 次构造函数**

**delete []**

**前四个字节**取出数组大小 n, 调用 **n 次析构函数**后, `operator delete[]`释放内存 

```C++
class A
{
    A();
    ~A();

    void * operator new(size_t sz);
    void operator delete(void * p);
};
```

**malloc**

```C++
void* malloc(size_t sz);	// sz 以字节为单位
```

**new 和 malloc 比较**

new 封装的更好, malloc 更底层

| 比较         | new                                          | malloc                 |
| ------------ | -------------------------------------------- | ---------------------- |
| 类型         | **运算符**                                   | **函数**               |
| 输入         | **类型**                                     | **字节数**             |
| 输出         | **类型**, 类型安全                           | **void ***, 类型不安全 |
| 分配失败     | 抛出**异常**                                 | 返回 **NULL**          |
| 内存不够     | 不可以重新分配                               | 可以重新分配(realloc)  |
| 过程         | 先调用 malloc 申请内存, 再调用构造函数初始化 | 向操作系统申请内存     |
| 申请内存位置 | **自由存储区**(堆/静态存储区/空)             | **堆**                 |

### new operator 和 operator new

new operator 指 **new 运算符**

operator new 指 **operator new 函数**

* new 第一步用 operator new 实现, operator new 一般用 malloc 实现

* new 无法重载, operator new 可以重载

### placement new

placement new 传入一块内存的地址, **只调用构造函数**

> 少了申请内存和释放内存的步骤
>
> 第一次申请内存, 最后一次释放内存
>
> 中间是**重复构造和析构**, 节省开销

```C++
char *mem = new char[n * sizeof(A)];	// 申请内存

A *p = new (mem) A;		// placement new, 只调用构造函数

p->~A();				// 显示调用析构函数

delete [] mem;			// 释放内存
```

### delete [] 如何知道 delete 多大的数组

new [] **类类型**数组时, 在**前四个字节**记录**数组大小 n**, delete [] 时取出数组大小, **调用 n 次析构函数**, 然后调用 operator delete [] 释放内存

### 内存泄漏

**没有正确释放内存**, 造成内存浪费

**原因**

1. **没有 delete**

   ```C++
   {
       int *p = new int(0);
   	p = nullptr;
    	// p 出局部作用域时销毁了    
   }
   ```

2. **没有配对使用**

   new [] 对应 delete

   new 对应 free

3. **循环引用**

**防止**

1. 用**系统栈**

2. 用 **STL**

   string 代替 char *

   vector 代替数组

   make_shared 代替 new

3. 用**智能指针**

4. **正确释放**

   malloc 对应 free

   new 对应 delete

   new [] 对应 delete []

5. **不用裸指针**

   > 裸指针: 普通指针
   >
   > 野指针: 指向的内存已释放


**检测是否泄漏**

分配和释放时做好记录, 对比记录判断是否泄漏

1. **地址**

   分配和释放内存的时候**打印地址**, 判断**分配的内存大小**是否等于**释放的内存大小**

2. **次数**

   判断**分配和释放的次数是否相等**

3. **工具**

### 内存溢出与内存泄漏

内存**溢出**: **空间不够**

内存**泄漏**: **空间没有释放**

内存溢出的原因:

1. 数据量过大
2. 循环过多, 递归过深
3. long 值给 int 内存

### 指针和引用区别

> "引用"默认指"左值引用"
>

引用的本质就是指针, 编译器**将指针封装成引用**

| 区别   | 指针             | 引用                          |
| ------ | ---------------- | ----------------------------- |
| 本质   | **地址变量**     | **指针封装**(顶层 const 指针) |
| 初始化 |                  | **必须初始化**                |
| 指向   | 随时任意改变     | **不能改变引用关系**          |
| 多级   | 可以有多级指针   | **只能有一级引用**            |
| 安全   | **没有类型检查** | **类型检查**, **类型安全**    |
| const  | 顶层和底层       | 只能底层 cosnt                |
| sizeof | 指针变量         | 引用对象                      |
| ++, -- | 指针变量的运算   | 引用对象的运算                |

|      | 值传递               | 指针传递                 | 引用传递     |
| ---- | -------------------- | ------------------------ | ------------ |
| 本质 | 形参是实参的**副本** | **值传递**, 传递指针变量 | **指针传递** |

**指针传递**和**引用传递**应用

1. 提高**传参效率**
2. 返回**多个值**
3. **函数内修改函数外**的变量

# STL

**泛型编程**的代表, 基于**模板**, 主要有**容器**, **迭代器**, **算法**

**容器**管理**数据**, **算法**实现**操作**, **迭代器连接**二者

## 容器

**顺序容器:** vector, deque, list, string, array

**关联容器:** set, map, unordered_set, unordered_map

**容器适配器:** stack, queue, priority_queue

| 容器           | 特点                                 |
| -------------- | ------------------------------------ |
| vector         | 动态数组, 倍增, 倍减                 |
| deque          | 多段连续空间构成, map 记录各段的入口 |
| list           | 双向链表                             |
| set/map        | 红黑树                               |
| stack          | 基于 deque                           |
| queue          | 基于 deque                           |
| priority_queue | 基于 vector                          |

### vector

两个重要参数: size 和 capacity

### reserve 与 resize

**reserve(n)**: 设置 capasity 不少于 n, size 不变

**resize(n)**: 设置 size 为 n, 多的擦去, 少的补上

## 智能指针

### 作用

避免**内存泄漏**

### 原理

**shared_ptr:** 多个指针指向同一对象

**unique_ptr:** 独占对象

**weak_ptr:** 辅助 share_ptr 

**shared_ptr**

每多一个指针, **引用计数就加 1**

每少一个指针, **引用计数就减 1**

引用计数为 0 时就释放内存

**unique_ptr**

引用计数只能为 1

没有拷贝构造函数

**weak_ptr**

**只能使用**但**没有所有权**, 不改变引用计数

**防止出现循环引用**

A 的成员指向 B, B 的成员指向 A

**循环引用**

```C++
class B;

class A
{
public:
    shared_ptr<B> _pb;	// 正确做法 weak_ptr<B>_pb;
};

class B
{
public:
    shared_ptr<A> _pa;	// 正确做法 weak_ptr<A>_pa;
};

shared_ptr<A> pa = make_shared<A>();	// pa->A
shared_ptr<B> pb = make_shared<B>();	// pb->B, 此时两个引用计数都为 1
	
pa->_pb = pb;			// pa->_pb->B	pb->B
pb->_pa = pa;			// pb->_pa->A	pa->A, 此时两个引用计数都为 2
```

问题:

出了作用域后, 两个引用计数不会变为 0, 而是变为 1, 资源没有被释放

结论:

**指针指向的内容**不应该拥有**资源的拥有权**

方法:

使用 `weak_ptr` 作为类的成员

### 实现

```C++
class Point
{
    int *ptr;			// 指针
    size_t* p_count;	// 引用计数
    
    // 构造, 析构, 拷贝构造
    Point(int *p = nullptr)
    {
        ptr = p;
        if(p != nullptr) *p_count = 1;
        else *p_count = 0;
    }
    
    ~Point()
    {
        if(--*p_count == 0)
            delete ptr;
    }
    
    Point(const Point& b)
    {
        ptr = b.ptr;
        p_count = b.p_count;
        *p_count++;
    }
    
    // 重载赋值运算符
    Point& operator=(const Point& b)
    {
        if(this == &b || ptr == b.ptr) return *this;	// 自赋值和等价赋值情况判断
        
        if(ptr != nullptr) 
        {
            if(--*p_count == 0) 
                delete ptr;
        }
        
        ptr = b.ptr;
        p_count = b.p_count;
        *p_count++;
        
        return *this;
    }
    
    T* operator->()
    {
        if(ptr != nullptr)
            return ptr;
    }
    
    T& operator*()
    {
        if(ptr != nullptr)
            return *ptr;
    }
}
```

# 并发

## 多线程

共享**代码段, 堆段**, 独占**栈段**

```C++
void fun()
{
	cnt++;    
}
```

`cnt++` 翻译为汇编语言有三步:

1. 取数 `mov 0x3f %eax`
2. 计算 `add 1 %eax`
3. 存回 `mov %eax 0x3f `

**有线程 A 和 B**

线程 A 在**第二步**完成后切换到线程 B

>  此时内存中 cnt 的值为 0, 寄存器中的值为 1

线程 B 执行完三步, 存回内存的值为 1

再切换到线程 A 执行存回操作, 存回内存的值也为 1

**问题:** 本应该加两次的 cnt 只加了一次, 原因在于**多线程对临界区访问**造成的问题
