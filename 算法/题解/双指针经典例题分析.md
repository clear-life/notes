# 双指针经典例题分析

目前分类:

* 单调性双指针

  $j = f(i)$ 单调性, 主要证明单调性

* 循环不变双指针

  $(i,j)$ 表示一个循环不变对象, 主要证明循环不变式

> 二者应该是能够相互转化的

### **[最长连续不重复子序列](https://www.acwing.com/problem/content/801/)**

**解法一: 单调性**

**$(i,j)$含义**:

$(i,j)$ 指代某个区间

对于每个 $i$,  $i$ 为区间右端点,

$j$ 表示所有不含重复元素区间 $[j,i]$ 中离 $i$ 最远的左端点

**样例**:

```C++
1 2 2 3 5
```

$i = 1$ 时, $j = 1$, 区间为 $[1,1]$

$i = 2$ 时, $j = 1$, 区间为 $[1,2]$

$i = 3$ 时, $j = 3$, 区间为 $[3,3]$

$i = 4$ 时, $j = 3$, 区间为 $[3,4]$

$i = 5$ 时, $j = 3$, 区间为 $[3,5]$

答案为所有满足条件 $(i,j)$ 中最长区间的长度, 即区间 $[3,5]$ 的长度 3

**单调性证明**:

对于 $j = f(i)$, 当 $i$ 递增后, 即 $j^{\prime} = f(i + 1)$

需要说明 $j^{\prime}$ 与 $j$ 的大小关系

假定 $j^{\prime} < j$

根据定义可知 $[j^{\prime},i+1]$ 是不含重复元素的区间

$\therefore$  $[j^{\prime},i]$ 也是不含重复元素的区间

根据 $j = f(i)$ 的定义, 显然 $j^{\prime} \geq j$, **产生矛盾**

$\therefore$  $j^{\prime} \geq j$, $j = f(i)$ 单调递增, 符合单调性

**遍历方向**:

由于 $j = f(i)$ 单调递增, 所以 $j$ 的遍历方向为 $1\rightarrow m$

**结果**:

所需结果为所有 $(i,j)$ 中最大区间的长度

**核心代码**:

```C++
int res = 0;
for(int i = 0, j = 0; i < n; i++)
{
    cnt[a[i]]++;
    
    while(j <= i && cnt[a[i]] > 1) cnt[a[j++]]--;
    
    res = max(res, i - j + 1);
}
```

### **[数组元素的目标和](https://www.acwing.com/problem/content/802/)**

**解法一: 单调性**

**$(i,j)$含义**:

$(i,j)$ 指代 $a_i+b_j$

对于每个 $i$, $j$ 表示满足 $a_i + b_j \leq x$ 的最大 $j$

**样例**:

```C++
a: 1 2 4 7
b: 3 4 6 8 9
x = 6
```

$i = 1$ 时, $j = 2$, 指代 1 + 4

$i = 2$ 时, $j = 2$, 指代 2 + 4

$i = 3$ 时, $j = 0$

$\dots$

所需结果为所有 $(i,j)$ 中与 x 相等的那个, 即 $(2,2)$

**单调性证明**:

对于 $j = f(i)$, 当 $i$ 递增后, 即 $j^{\prime} = f(i + 1)$

需要说明 $j^{\prime}$ 与 $j$ 的大小关系

假定 $j^{\prime} > j$

则 $j^{\prime} \geq j + 1$

根据定义可知 $a_i + b_j \leq x$ 和 $a_i + b_{j+1} > x$

则 $a_{i+1} + b_{j^{\prime}} \geq a_i + b_{j+1} > x$

这与 $j^{\prime} = f(i + 1)$ 的含义矛盾

$\therefore$  $j^{\prime} \leq j$, $j = f(i)$ 单调递减, 符合单调性

**遍历方向**:

由于 $j = f(i)$ 单调递减, 所以 $j$ 的遍历方向为 $m \rightarrow 1$

**结果**:

所需结果为所有 $(i,j)$ 中与 x 相等的那个

**核心代码**:

```C++
for(int i = 0, j = m - 1; i < n; i++)
{
    while(j >= 0 && a[i] + b[j] > x) j--;
    
    if(j >= 0 && a[i] + b[j] == x)
    	输出答案
}
```

> 事实上, 如这个[贴子](https://www.acwing.com/solution/content/175155/)的最后和下面所述, 这道题也可以用循环不变双指针的方法来做

$~$

**解法二: 循环不变**

```C++
for(int i = 0, j = m - 1; i < n && j >= 0;)
{
    if(a[i] + b[j] == x)
        输出答案
    else if(a[i] + b[j] > x) j--;
    else i++;
}
```

### **[判断子序列](https://www.acwing.com/problem/content/2818/)**

**解法一: 单调性**

**$(i,j)$含义**:

$(i,j)$ 指代当前匹配的进度

具体来说, 

$i$ 表示 a 序列进度, 即 $[a_1,\dots,a_{i-1}]$ 均已在 b 序列中找到匹配对象, 当前正在寻找 $a_i$ 匹配对象

$j$ 表示在上述前提下**尽可能靠左**的**与 $a_i$ 匹配的对象**

**样例**:

```C++
a: 1 3 5
b: 1 2 3 4 5
```

$i = 1$ 时, $j = 1$

$i = 2$ 时, $j = 3$

$i = 3$ 时, $j = 5$

**单调性证明**:

对于 $j = f(i)$, 当 $i$ 递增后, 即 $j^{\prime} = f(i + 1)$

需要说明 $j^{\prime}$ 与 $j$ 的大小关系

假定 $j^{\prime} \leq j$

则与子序列的定义矛盾

$\therefore$ $j^{\prime} > j$, $j = f(i)$ **严格单调递增**

> 换句话说, 就是**显然 $j^{\prime} > j$**

**遍历方向**:

由于 $j = f(i)$ 严格单调递增, 所以 $j$ 的遍历方向为 $1 \rightarrow m$

> 而且由于是严格单调递增, 所以代码与上面的两道题稍有不同

**结果**:

所需结果需要判断 $j = f(n)$ 是否合法

**核心代码**:

```C++
for(int i = 0, j = 0; i < n; i++)
{
    while(j < m && a[i] != b[j]) j++;
    
    if(j < m) j++;	// j = f(i) 严格单调递增的影响
    else
    	输出 No
}
输出 Yes
```

$~$

**解法二: 循环不变**

```C++
for(int i = 0, j = 0; i < n && j < m)
{
    if(a[i] == b[j]) i++;
    j++;
}

if(i == n)
    输出 Yes
else
    输出 No
```

