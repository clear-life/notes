# 动态规划

## 概念

1. **最优子结构**: 原问题的最优解由子问题的最优解组合而来

> $f[i] = g(f[1], \dots, f[i - 1])$

2. **重复子问题**: 很多子问题会重复求解, 动态规划只求一次

> 从小到大求解 $f[i]$ 时, $f[1], \dots, f[i - 1]$ 会重复求解 

**对比**

分治: 没有重复子问题

贪心: 有最优子结构, 没有重复子问题

$~$

**无后效性**

$f[i]$ 确定后, 求解 $f[j], j > i$ 时的 $f[j]$ 不会因为 $f[i]$ 决策的不同而改变

即, 一旦 $f[j] 只跟 $$f[i]$ 的值有关, 与如何得到 $f[i]$ 无关

$~$

## 思路

1.  **$f_{ij}$ 含义**

   1.  $A_{ij}$ 含义: **第一步到当前步**所有选择组合而成的**选法方案**
   2. 属性: $\min, \max, \DeclareMathOperator{\cnt}{cnt} \cnt$

   > $f_{ij} = \min, \max, \DeclareMathOperator{\cnt}{cnt} \cnt A_{ij}$

2. **递推式**

   枚举最后一步选择, 将 $A_{ij}$ 划分为更小的集合

   $A_{ij} =  g(\{A_{xy} | xy \in ij 的子问题 \})$

   $\DeclareMathOperator{\cnt}{cnt}
   f_{ij} = \min, \max, \cnt A_{ij} = \min, \max, \cnt g(\{A_{xy} \}) = \min, \max, \cnt g(\{f_{xy}\})$

   $\therefore f_{ij} = \min, \max, \cnt g(\{f_{xy}\})$

**递推式推导**

递推式推导时一定要分好情况进行讨论

推导时, 一定要把所有的状态分好类, 无论有多简单, 都要分好情况进行讨论

**状态分类**

常见分类: 起点与其他点

> 在路径问题中, 起点的路径数常 + 1

[统计所有可行路径](https://leetcode.cn/problems/count-all-possible-routes/)	先把所有状态分类, 再对每个状态进行递归式推导

## 做题步骤

1. 画出数据分布
2. 无后效性判断
3. 状态定义(靠猜)

$~$

## 技巧

### 问题等价变换

将问题进行等价变换, 使之更容易处理

1. **正向考虑** $\iff$ **反向考虑**

2. **起点到终点** $\iff$ **终点到起点**

   > 问题要求输出起点到终点的每一步的选择, 如果反向考虑
   >
   > 由于辅助数据存储时是反向存储的, 负负得正, 于是从终点到起点考虑问题时的辅助数据是正向存储的

3. **记忆化搜索改动态规划**

   记忆化搜索的思路比较好理解, 可以先从记忆化搜索的思路入手, 考虑 dfs 函数的下列因素

   1. 参数
   2. 返回值
   3. base case
   4. 如何递归

   然后根据**状态间的依赖关系**尝试将其改为动态规划写法
   
4. **问题等价变换**

   [出界的路径数](https://leetcode.cn/problems/out-of-boundary-paths/)	将问题等价变换到少走一步到达边界的路径个数

### 维度合并

将**高维数据**一一映射到**低维数据**, 减少边界条件出错的情况

```C++
f[2to1(i, j)] = f[2to1(x, y)] ...
```

### 数组下标

数组下标一般从 1 开始, 因为初值可以设在下标为 0 的位置

> 注意如果题目给定数组的下标从 0 开始, 那么就要进行一个下标转换

### 记忆化搜索(DFS) 的赋值

记忆化搜索本质上使用 DFS 来实现的, 如果在搜索过程中出现重复访问自身结点的情况, 那么对于状态的赋值必须要在计算完成后才能赋值, 不然会返回错误的结果

```C++
int dfs(int i, int j)
{
    if(f[i][j] != -1) return f[i][j];
    
    int t = 0;				// 如果提前给 f[i][j] 赋值的话, 那么如果在递归计算子问题 dfs(x, y) 时
    						// 又访问了 dfs(i, j) 那么此时 f[i][j] 的值就不是 -1 了
    						// 在代码看来, 此时的 f[i][j] 已经计算完成, 于是返回了一个错误的答案
    						// 当然, 如果递归计算子问题时不会访问原问题, 那么就不会出现这种情况
    for ij 的子问题 xy:
    	t += dfs(x, y)	
    f[i][j] = t;
    return t;
}
```



### 时间复杂度优化

**递推式的等价变形**

[下降路径最小和  II](https://leetcode.cn/problems/minimum-falling-path-sum-ii/)    对递推式找到等价的表示方式, 且该表示方式对于程序来说时间复杂度更低

[完全背包问题](https://www.acwing.com/problem/content/3/)    $f_{ij}$ 的递推式可用 $f_{ij-v_i}$ 代替部分式子, 减少了计算量 

**剪枝**

根据性质, 如果可以**提前确定状态 $f_{ij}$ 的值**, 那么就可以不根据递推式计算 $f_{ij}$ 的值, 而是直接赋值, 相当于 dfs 中的剪枝

$~$

### 空间复杂度优化

**前提**

**1. 一个一维数组**

当前行的状态**只依赖上一行的状态**, 且只依赖**上一行单向上的状态**

```C++
int f[n]
f[j] = g(f[j], f[j - 1])
```

**2. 两个一维数组**

当前行的状态**只依赖上一行的状态**

```C++
int f[2][n]
f[i & 1][j] = g(f[(i - 1) & 1][j], f[(i - 1) & 1][j - 1])
```

**初始值的变化**

注意由空间复杂度优化引起的**初始值含义的变化**

如原本只想要 `f[0][0] = 0`, 

优化后变成 `f[0] = 0` ,初始化含义就变成了 `f[i][0] = 0`, 显然不符合原意

**如何考虑空间复杂度优化引起的初始值的变化 ?**

画好数据分布图(包含初始值), 考虑空间复杂度优化后的数据分布图

### 时间复杂度估计

约为 **状态空间大小** $\times$ **选择的个数**

如:

01 背包问题: n 个物品, 体积为 v

约为 $O(2nv) = O(nv)$ 

多重背包问题: n 个物品, 每个物品最多选 s 次, 体积为 v

约为 $O(snv)$

$~$

## 题目分类

### 线性 dp

1. 单串 

   ```C++
   f[i] = g(f[i - 1],.. f[1])
   ```

   

## 题库

[打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

将一个复杂的 dp 问题分解为两个简单的 dp 子问题, 分解角度既可以为初值的不同, 也可以为范围的不同

[完全平方数](https://leetcode-cn.com/problems/perfect-squares/)	完全背包, 注意 j 的方向

[出界的路径数](https://leetcode.cn/problems/out-of-boundary-paths/)	记忆化搜索与 dp 的转换, 初始值的不同设置, 剪枝, 分类讨论递推式

### 记忆化搜索

考虑好是否计算过的条件设置, 设置不好很容易超时

[组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)	考虑好递归的终止条件

[统计所有可行路径](https://leetcode.cn/problems/count-all-possible-routes/)	递推式一定要分情况讨论



## 练习

[不同路径](https://leetcode.cn/problems/unique-paths/)	

**1. 通项含义 / 状态表示**

通项 $f_{ij} = cntA_{ij}$

$A_{ij}$ : 从 (1, 1) 到 (i, j) 的所有走法(符合题目约束条件) 

**2. 递推式 / 状态转移**

1. **划分集合**

   1. 划分依据: 最后一步的选择

   2. 划分 $A_{ij}$

      最后一步走下: $A_{i-1j} + 走下$

      最后一步走右: $A_{ij-1} + 走右$

      $A_{ij} = \{A_{i-1j} + 走下, A_{ij-1} + 走右\}$

2. **递推式**

   $f_{ij} = cntA_{ij} = cnt\{A_{i-1j} + 走下, A_{ij-1} + 走右\} = cntA_{i-1j} + cntA_{ij-1} = f_{i-1j} + f_{ij-1}$

   $\therefore f_{ij} = f_{i-1j} + f_{ij-1}$

[下降路径最小和](https://leetcode.cn/problems/minimum-falling-path-sum/)	

**1. $A_{ij}$**

从第一行走到 $ij$ 的所有方案

每一步: 当前行走到下一行

每一步的选择: 当前行能走到下一行的三个位置

**2. $f_{ij}$**

$f_{ij} = \min A_{ij}$ 所有方案的最小路径和

**3. 递推式**

$f_{ij} = \min \{f_{i-1j}, f_{i-1j}, f_{i-1j+1}\} + a[i][j]$

**4. 无后效性**

$f_{ij}$ 只与子问题的值有关, 跟如何得到子问题的值无关, 满足无后效性

[统计所有可行路径](https://leetcode.cn/problems/count-all-possible-routes/)

分情况讨论练习

**1. $A_{ij}$**

从起点 st 走到 i, 汽油不超过 j 的所有路径

每一步: 当前点到下一点的走法

每一步的选择: 当前点走到与自己不同的点

**2. $f_{ij}$**

$f_{ij} = \cnt A_{ij}$ 所有路径的个数

**3. 无后效性**

$f_{ij}$ 只与上一步的路径个数有关, 与如何走到上一步的选择无关, 满足无后效性

**4. 递推式**

**状态分类**

所有状态分为两类: 终点与起点不同, 终点在起点上

即 $f_{ij}, i \neq st$ 和 $f_{ij}, i = st$

**case 1: $f_{ij}, i \neq st$**

则 $f_{ij}$ 上一步一定由不同的点转移过来, 故 $f_{ij} = \sum f_{xy}, x \neq i$ 

**case 2: $f_{ij}, i = st$**

$f_{ij}$ 上一步除了由不同的点转移过来外, 还有可能从 st 转移过来, 因为本身就在 st 上,哪都不用走就是一个方案, 还因为按照 case 1 的计算方案, 路径上相邻两个点一定是不同的, 还要加上本身就在 st 点这个方案

