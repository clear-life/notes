# 动态规划

**离散数学**

1. **集合论与图论**
2. **代数结构与组合数学**
3. **数理逻辑**

**动态规划的本质模型是图论里的拓扑图**

## 概念

1. **最优子结构**: 原问题的最优解由子问题的最优解组合而来

> $f[i] = g(f[1], \dots, f[i - 1])$

2. **重复子问题**: 很多子问题会重复求解, 动态规划只求一次

> 从小到大求解 $f[i]$ 时, $f[1], \dots, f[i - 1]$ 会重复求解 

**对比**

分治: 没有重复子问题

贪心: 有最优子结构, 没有重复子问题

$~$

**无后效性**

$f[i]$ 确定后, 求解 $f[j], j > i$ 时的 $f[j]$ 不会因为 $f[i]$ 决策的不同而改变

即, 一旦 $f[j] 只跟 $$f[i]$ 的值有关, 与如何得到 $f[i]$ 无关

$~$

## 思路

1.  **$f_{ij}$ 含义**

   1.  $A_{ij}$ 含义: **第一步到当前步**所有选择组合而成的**选法方案**
   2. 属性: $\min, \max, \DeclareMathOperator{\cnt}{cnt} \cnt$

   > $f_{ij} = \min, \max, \DeclareMathOperator{\cnt}{cnt} \cnt A_{ij}$

2. **递推式**

   枚举**最后一步**的选择, 将 $A_{ij}$ 划分为更小的集合

   $A_{ij} =  g(\{A_{xy} | xy \in ij 的子问题 \})$

   $\DeclareMathOperator{\cnt}{cnt}
   f_{ij} = \min, \max, \cnt A_{ij} = \min, \max, \cnt g(\{A_{xy} \}) = \min, \max, \cnt g(\{f_{xy}\})$

   $\therefore f_{ij} = \min, \max, \cnt g(\{f_{xy}\})$

**递推式推导**

递推式推导时一定要分好情况进行讨论

推导时, 一定要把所有的状态分好类, 无论有多简单, 都要分好情况进行讨论

**状态分类**

常见分类: 起点与其他点

> 在路径问题中, 起点的路径数常 + 1

[统计所有可行路径](https://leetcode.cn/problems/count-all-possible-routes/)	先把所有状态分类, 再对每个状态进行递归式推导

## 做题步骤

1. 画出数据分布
2. 无后效性判断
3. 状态定义(靠猜)

$~$

## 技巧

### 问题等价变换

将问题进行等价变换, 使之更容易处理

1. **正向考虑** $\iff$ **反向考虑**

2. **起点到终点** $\iff$ **终点到起点**

   > 问题要求输出起点到终点的每一步的选择, 如果反向考虑
   >
   > 由于辅助数据存储时是反向存储的, 负负得正, 于是从终点到起点考虑问题时的辅助数据是正向存储的

3. **记忆化搜索改动态规划**

   记忆化搜索的思路比较好理解, 可以先从记忆化搜索的思路入手, 考虑 dfs 函数的下列因素

   1. 参数
   2. 返回值
   3. base case
   4. 如何递归

   然后根据**状态间的依赖关系**尝试将其改为动态规划写法
   
4. **问题等价变换**

   [出界的路径数](https://leetcode.cn/problems/out-of-boundary-paths/)	将问题等价变换到少走一步到达边界的路径个数

### 维度合并

将**高维数据**一一映射到**低维数据**, 减少边界条件出错的情况

```C++
f[2to1(i, j)] = f[2to1(x, y)] ...
```

### 数组下标

数组下标一般从 1 开始, 因为初值可以设在下标为 0 的位置

> 注意如果题目给定数组的下标从 0 开始, 那么就要进行一个下标转换

$~$

### step 模型

推导递推式时, 常枚举最后一步的选择

那么这个**最后一步**的模型有哪些呢 ?

或者说, 每一步代表的模型有哪些

**1. 每件物品选或不选**

01 背包: 

step: 每个物品

选择: 物品选 或 物品不选

**2. 每个物品选几件**

多重背包:

step: 每个物品

选择: 每个物品选 0 ~ $s_i$ 件

**3. 每一步往哪走**

路径问题:

step: 每一步

选择: 往哪个方向走

**4. 两条路线每一步往哪走**

路径问题两条路径:

step: 走的步数 / 横纵坐标之和的对角线

选择: **确定两条路线分别走的方向**, 然后根据**乘法原理**乘起来

如: 路线1 能走 1 2 3 共三个方向, 路线2 能走 1 2 共两个方向

选择: {(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2)}

> (3, 2) 表示路线 1 走方向 3, 同时路线2 走方向 2

### 状态表示

猜测状态表示时, 更应该看是否满足中间过程前后状态的递推, 不应该看终止状态是否满足条件

$~$

### 初始值设置

**1. 常规情况**

求最大时常设较小的值, 求最小时常设较大的值, 求数量时常设 0

**2. 特殊要求**

例: 背包容量必须用完

如果想要最终状态 ed 一定从某个起点 st 出发的话

**max**: 其余起点设为负无穷大, 起点 st 设为正常值, 使得其余起点完全竞争不过起点 st, **因为 st 远远比其余起点大**

**min**: 其余起点设为正无穷大, 起点 st 设为正常值, 使得其余起点完全竞争不过起点 st, **因为 st  远远比其余起点小**

### 记忆化搜索(DFS) 的赋值

记忆化搜索本质上使用 DFS 来实现的, 如果在搜索过程中出现重复访问自身结点的情况, 那么对于状态的赋值必须要在计算完成后才能赋值, 不然会返回错误的结果

```C++
int dfs(int i, int j)
{
    if(f[i][j] != -1) return f[i][j];
    
    int t = 0;				// 如果提前给 f[i][j] 赋值的话, 那么如果在递归计算子问题 dfs(x, y) 时
    						// 又访问了 dfs(i, j) 那么此时 f[i][j] 的值就不是 -1 了
    						// 在代码看来, 此时的 f[i][j] 已经计算完成, 于是返回了一个错误的答案
    						// 当然, 如果递归计算子问题时不会访问原问题, 那么就不会出现这种情况
    for ij 的子问题 xy:
    	t += dfs(x, y)	
    f[i][j] = t;
    return t;
}
```



### 时间复杂度优化

**递推式的等价变形**

[下降路径最小和  II](https://leetcode.cn/problems/minimum-falling-path-sum-ii/)    对递推式找到等价的表示方式, 且该表示方式对于程序来说时间复杂度更低

[完全背包问题](https://www.acwing.com/problem/content/3/)    $f_{ij}$ 的递推式可用 $f_{ij-v_i}$ 代替部分式子, 减少了计算量 

**剪枝**

根据性质, 如果可以**提前确定状态 $f_{ij}$ 的值**, 那么就可以不根据递推式计算 $f_{ij}$ 的值, 而是直接赋值, 相当于 dfs 中的剪枝

$~$

### 空间复杂度优化

**前提**

**1. 一个一维数组**

当前行的状态**只依赖上一行的状态**, 且只依赖**上一行单向上的状态**

```C++
int f[n]
f[j] = g(f[j], f[j - 1])
```

**2. 两个一维数组**

当前行的状态**只依赖上一行的状态**

```C++
int f[2][n]
f[i & 1][j] = g(f[(i - 1) & 1][j], f[(i - 1) & 1][j - 1])
```

**初始值的变化**

注意由空间复杂度优化引起的**初始值含义的变化**

如原本只想要 `f[0][0] = 0`, 

优化后变成 `f[0] = 0` ,初始化含义就变成了 `f[i][0] = 0`, 显然不符合原意

**如何考虑空间复杂度优化引起的初始值的变化 ?**

画好数据分布图(包含初始值), 考虑空间复杂度优化后的数据分布图

### 修改源数据

在源数据的某些数据如果需要特判的话, 可以考虑直接大胆修改源数据, 方便递推计算 f 函数值

### 时间复杂度估计

约为 **状态空间大小** $\times$ **选择的个数**

如:

01 背包问题: n 个物品, 体积为 v

约为 $O(2nv) = O(nv)$ 

多重背包问题: n 个物品, 每个物品最多选 s 次, 体积为 v

约为 $O(snv)$

$~$

## 题目分类

### 最优方案

最优方案指从**开始状态**到**终止状态**的**最优选择的序列**

**最优方案获取**

1. 根据**前后状态值**的关系**推测最优选择**

   ```C++
   if f[i][j] = f[i - 1][u]
       最优选择是从 f[i - 1][u] -> f[i][j]
   else if f[i][j] = f[i - 1][v]
       最优选择是从 f[i - 1][v] -> f[i][j]
   else
       ...
   ```

2. **状态转移时**用辅助数组**记录最优选择**

   ```C++
   if ...
       f[i][j] = f[i - 1][u]		
       g[i][j] = 最优选择 u
   else if ...
       f[i][j] = f[i - 1][v]
       g[i][j] = 最优选择 v
   else
       ...
   ```

**字典序最优方案**

一般情况下, 题目要求从起点到终点的字典序最优方案, 此时**状态转移的方向**, 或者说**状态的定义**就有点不一样

例: 01 背包的字典序最优方案

假定最终状态的转移路径存在**选择第一个物品**的情况, 那么**为了字典序最小, 必须选择第一个物品**, 

那么问题就缩小为**从 2 ~ n 这些物品中找到字典序最优方案**, 此时选择了第一个物品的状态作为新的最终状态

于是, 状态定义需要做出修改: $A_{ij}:$ 从 i ~ n 这些物品中选择, 体积不超过 j 的所有方案

> 状态转移方程: $f_{ij} = \max \{f_{i+1j}, f_{i+1j-v_i} + w_i \}$

```C++
for(int i = n; i >= 1; i--)
    for(int j = 0; j <= m; j++)
    {
        f[i][j] = f[i + 1][j];
		if(j >= v[i]) f[i][j] = max(f[i][j], f[i + 1][j - v[i]] + w[i]);
	}

// 生成字典序最小最优方案
for(int i = 1, j = m; i <= n; i++)
    if(j >= v[i] && f[i][j] == f[i + 1][j - v[i]] + w[i];
       cout << i << " ";
cout << endl;
```



### 线性 dp

1. 单串 

   ```C++
   f[i] = g(f[i - 1],.. f[1])
   ```

   

## 题库

[打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

将一个复杂的 dp 问题分解为两个简单的 dp 子问题, 分解角度既可以为初值的不同, 也可以为范围的不同

[完全平方数](https://leetcode-cn.com/problems/perfect-squares/)	完全背包, 注意 j 的方向

[出界的路径数](https://leetcode.cn/problems/out-of-boundary-paths/)	记忆化搜索与 dp 的转换, 初始值的不同设置, 剪枝, 分类讨论递推式

[最大得分的路径数目](https://leetcode.cn/problems/number-of-paths-with-max-score/)	两个 dp 相互影响

### 记忆化搜索

考虑好是否计算过的条件设置, 设置不好很容易超时

[组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)	考虑好递归的终止条件

[统计所有可行路径](https://leetcode.cn/problems/count-all-possible-routes/)	递推式一定要分情况讨论



## 练习

[不同路径](https://leetcode.cn/problems/unique-paths/)	

**1. 通项含义 / 状态表示**

通项 $f_{ij} = cntA_{ij}$

$A_{ij}$ : 从 (1, 1) 到 (i, j) 的所有走法(符合题目约束条件) 

**2. 递推式 / 状态转移**

1. **划分集合**

   1. 划分依据: 最后一步的选择

   2. 划分 $A_{ij}$

      最后一步走下: $A_{i-1j} + 走下$

      最后一步走右: $A_{ij-1} + 走右$

      $A_{ij} = \{A_{i-1j} + 走下, A_{ij-1} + 走右\}$

2. **递推式**

   $f_{ij} = cntA_{ij} = cnt\{A_{i-1j} + 走下, A_{ij-1} + 走右\} = cntA_{i-1j} + cntA_{ij-1} = f_{i-1j} + f_{ij-1}$

   $\therefore f_{ij} = f_{i-1j} + f_{ij-1}$

[下降路径最小和](https://leetcode.cn/problems/minimum-falling-path-sum/)	

**1. $A_{ij}$**

从第一行走到 $ij$ 的所有方案

每一步: 当前行走到下一行

每一步的选择: 当前行能走到下一行的三个位置

**2. $f_{ij}$**

$f_{ij} = \min A_{ij}$ 所有方案的最小路径和

**3. 递推式**

$f_{ij} = \min \{f_{i-1j}, f_{i-1j}, f_{i-1j+1}\} + a[i][j]$

**4. 无后效性**

$f_{ij}$ 只与子问题的值有关, 跟如何得到子问题的值无关, 满足无后效性

[统计所有可行路径](https://leetcode.cn/problems/count-all-possible-routes/)

分情况讨论练习

**1. $A_{ij}$**

从起点 st 走到 i, 汽油不超过 j 的所有路径

每一步: 当前点到下一点的走法

每一步的选择: 当前点走到与自己不同的点

**2. $f_{ij}$**

$f_{ij} = \cnt A_{ij}$ 所有路径的个数

**3. 无后效性**

$f_{ij}$ 只与上一步的路径个数有关, 与如何走到上一步的选择无关, 满足无后效性

**4. 递推式**

**状态分类**

所有状态分为两类: 终点与起点不同, 终点在起点上

即 $f_{ij}, i \neq st$ 和 $f_{ij}, i = st$

**case 1: $f_{ij}, i \neq st$**

则 $f_{ij}$ 上一步一定由不同的点转移过来, 故 $f_{ij} = \sum f_{xy}, x \neq i$ 

**case 2: $f_{ij}, i = st$**

$f_{ij}$ 上一步除了由不同的点转移过来外, 还有可能从 st 转移过来, 因为本身就在 st 上,哪都不用走就是一个方案, 还因为按照 case 1 的计算方案, 路径上相邻两个点一定是不同的, 还要加上本身就在 st 点这个方案

## 提高课

#### 合法状态

状态分合法与不合法, 所有的**合法状态只能由合法状态转移过来**

**状态合法与不合法的区分方式**

**区分方式 1: 非法值**

赋予状态一个**非法值**, 只用于表示**非法状态**, **不表示实际含义**

需要在状态转移时判断上一状态是否合法

```C++
f[0] = 0 (合法值)	f[0] = -1 (非法值)

状态转移:
	if(f[u] != -1)		// 合法性判断
        f[v] = g(f[u])
    else
        f[v] = -1		// 若所有的上一状态不合法, 那么该状态一般也不合法, 因为不能由某个合法状态转移过来
```

**区分方式 2: 理论不可达值**

赋予状态一个理论上不可达到的值, **该值理论上能够表示实际含义**, 但**实际转移时不会转移到其他状态**

不需要在状态转移时判断上一状态是否合法, 但需要**根据实际问题设置理论不可达值**

```C++
fi = min Ai 	
min 模型, 那么理论不可达值为正无穷大, 因为正常值与正无穷大相比, 无论何时都是正常值在 min 模型的竞争中获胜, 得以由其转移到下一状态
所以只需要将非法状态赋值为正无穷大, 合法状态正常设值, 那么非法状态一定不会转移到别的状态
    
f[0] = 0 (正常值)  f[0] = +INF (理论不可达值)
f[v] = min(f[u1], f[u2])
    
一般情况下, 实际含义中的理论不可达值常为: 
min: 理论不可达值为 +INF
max: 理论不可达值为 -INF
cnt: 理论不可达值为 0
```



### 集合模型

问题模型之上的抽象

#### 路径模型

一条路径

**1. 从起点到当前点走, 路径的所有方案**

> 从 st 到 (i, j) 的所有方案

```C++
Aij 的划分: 最后一步的选择
Aij = A.. + 最后一步
```



两条路径

**2. 两条路线, 同时从起点到当前线走, 路径的所有方案**

> 从 st 和 st 到 (k, i1, i2) 的所有方案

```C++
Aki1i2 的划分: 最后一步的选择
Aki1i2 = Ak-1.. + 最后一步   
```

$~$

#### 子序列模型

一个子序列

**1. 从开头到当前下标, 所有的子序列**

> [1..i] 的所有子序列

```C++
Ai 的划分: 子序列的最后一个元素
Ai = A. + 子序列的最后一个元素
```

有条件约束的子序列

**2. 从开头到当前下标, 所有以 $a_i$ 结尾的子序列**

> [1..i] 的所有以 $a_i$ 结尾的子序列

```C++
Ai 的划分: 子序列的倒数第二个元素
Ai = A. + 子序列的倒数第二个元素
```



两个子序列

**3. 从两个开头到两个当前下标, 所有的子序列**

> [1..i] 选第一个子序列 a, [1..j] 选第二个子序列 b, 所有的 (a, b)

```C++
Aij 的划分: 两个子序列的最后一个元素的笛卡尔积
Aij = A.. + (a 的最后一个元素, b 的最后一个元素)
```



公共子序列

**4. 从两个开头到两个当前下标, 所有的公共子序列**

> [1..i] 选第一个子序列 a, [1..j] 选第二个子序列 b
>
> a = b 的条件下, 所有的公共子序列

```C++
Aij 的划分: 两个子序列的最后一个元素的笛卡尔积是否有 ai 和 bj
Aij = A.. + (a 的最后一个元素, b 的最后一个元素)
    
根据 a 的最后一个元素是否为 ai, b 的最后一个元素是否为 bj, 可分为:
00, 01, 10, 11		// 0 表示否, 1 表示是
    
case 1: a.back 不是 ai, b.back 不是 bj
    就是 A i-1 j-1
case 2: a.back 不是 ai, b.back 是 bj
    是 A i-1 j 的子集
case 3: a.back 是 ai, b.back 不是 bj
    是 A i j-1 的子集
case 4: a.back 是 ai, b.back 是 bj
    ai = bj 时, 是 A i-1 j-1 + (ai, bj)
```

**5. 从两个开头到两个当前下标, 所有以 bj 为结尾的公共上升子序列**

> [1..i] 选第一个子序列 a, [1..j] 选第二个子序列 b
>
> a = b 的条件下, 所有以 bj 结尾的公共上升子序列

```C++
Aij 的划分: 以 bj 结尾的公共上升子序列是否含有 ai
划分: 
不含 ai, 即 fi-1 j
含有 ai, 再次划分
    划分: 公共子序列倒数第二个元素
    前提是满足 LIS 要求
        空: 1
        b1: fi-1 1
        b2: fi-1 2
        ...
        bj-1: fi-1 j-1
```

#### 组合模型

一维限制

**1. 从前 i 个物品中选, 限制为 j**

> $A_{ij}$ : 从前 i 个物品中选, 限制为 j 的所有方案

**"限制"的常见类别:**

1. 体积 $\leq j$

   > 所有初值设为 0
   >
   > 体积 $v \geq 0$

2. 体积 $= j$

   > $f[0] = 0, f[i] = \infty 或 -1 或 0$ (根据实际问题出发设置非法值)
   >
   > 体积 $v \geq 0$

3. 体积 $\geq j$  

   > $f[0] = 0, f[i] = \infty 或 -1$
   >
   > 体积 v 不限制, v 可以是负数 0 和 正数, 但由于数组没有负数下标, 在负数状态与 0 状态等价的前提下, 可以将负数状态与 0 状态合并表示合法状态

```C++
Aij 的划分: 第 i 个物品是否选择
不选: Ai-1 j
选: Ai-1 j-vi + 选择 ai
```

二维限制

**1. 从前 i 个物品中选, 限制 1 为 j, 限制 2 为 k**

> $A_{ijk}$ : 从前 i 个物品中选, 限制 1 为 j, 限制 2 为 k的所有方案

[潜水员](https://www.acwing.com/problem/content/description/1022/) : 限制不再是 **不超过**, 而是 **不小于 / 至少为**

> 思路是将限制条件所在的维度, 初始状态的 0 值及负值看作合法状态(统一用 0 表示), 其余看作非法状态

```C++
Aijk 的划分: 第 i 个物品是否选择
不选: Ai-1 j k
选: Ai-1 j-vi k-vi + 选择 ai
```



$~$

### 问题模型

#### 数字三角形模型

**从起点到某点走过路径的所有方案**

[方格取数](https://www.acwing.com/problem/content/1029/)

$A_{ki_1i_2}$ : 两条路线走同样的步数, 从 (1, 1) 和 (1, 1) 走到 (i1, k - i1) 和 (i2, k - i2) 的所有方案

step: 横纵坐标之和代表的对角线

[传纸条](https://www.acwing.com/problem/content/277/) 	特殊状态特殊判断, 分类讨论, 分类进行递推式推导

#### 最长上升子序列(LIS)模型

> **LIS : Longest Increasing Subsequence**

**以某元素为结尾的所有方案**

[登山](https://www.acwing.com/problem/content/1016/)

动态规划方法预处理出每个元素左右两边的 LIS, 然后以此为基础求出结果

[友好城市](https://www.acwing.com/problem/content/description/1014/)

分析性质, 得出 LIS 模型, 然后用模板解决问题

> 由于程序中常顺序考虑问题, 考虑 n 个元素的关系太复杂
>
> 一般尝试考虑任意两个(或相邻两个元素)元素, 查找其关系 / 性质
>
> 如果两个元素的位置关系不固定, 不妨设元素间的位置关系

分析:

考虑任意两个元素 (a, b) 和 (c, d), 什么情况下满足建桥相交 ?

不妨设 $a \leq c$ , 且固定 a 和 c 的位置

> 即位置关系由第一个元素确定

由于 b 和 d 都不固定, 可以先固定一个位置

**固定 b**

画图可知, $d > b$ 时不相交, $d \leq b$ 时相交

固定 d 时, 同理可得相同的结论

特殊情况: a 和 c 相等时, 也能得到相同的结论

> 复杂问题简单考虑
> n 个元素的关系, 简化成任意两个元素的关系
> 任意两个元素的关系, 简化成前后任意两个元素的关系
> 元素的分量间的关系, 简化成固定一个元素, 另一个元素变化

**得到性质:**

$a \leq c$ 时, $b < d$ 时不相交, $b \geq d$ 时相交

贪心性质: 只要最后一个桥(最后一个选中元素)与当前元素不相交, 那么当前元素与之前选中的元素都不相交

**于是, LIS 模型抽出:** 在对元素 (a, b) sort 的情况下, 元素的第二个分量满足 LIS 模型 

#### 最长公共子序列(LCS)模型

> **LCS: Longest Common Subsequence**

$A_{ij}$: 从 a[1..i], b[1..j] 中选, 所有的公共子序列

划分: 公共子序列是否含有 $a_i$, $b_j$

```C++
公共子序列:
不含 ai, 不含 bj
不含 ai, 含 bj
含 ai, 不含 bj
含 ai, 含 bj
```

[最长公共子序列](https://www.acwing.com/problem/content/899/)

#### 最长公共上升子序列模型

$A_{ij}$: 从 a[1..i], b[1..j] 中选, 所有以 bj 结尾的公共上升子序列

划分: 以 bj 结尾的公共上升子序列是否含有 ai

```C++
不含 ai: fi-1j
含有 ai:
前提条件是 ai = bj
    再次划分
		划分依据: 倒数第二个元素(LIS)
        前提条件是满足上升子序列的要求
            空: 1
            b1: fi-1 1
            b2: fi-1 2
            b3: fi-1 3
            ...
            bj-1: fi-1 j-1
```

#### 背包模型

$A_{ij}$: 从前 i 个物品中选, 体积不超过 j 的所有方案(组合)

划分: 最后一个物品是否选择

```C++
不选: Ai-1 j
选: Ai-1 j-vi + 选择 ai
```

$A_{ij}$: 从前 i 个物品中选, 体积刚好为 j 的所有方案(组合)

$A_{ij}$: 从前 i 个物品中选, 体积至少为 j 的所有方案(组合)
