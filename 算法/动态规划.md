# 动态规划

**离散数学**

1. **集合论与图论**
2. **代数结构与组合数学**
3. **数理逻辑**

**动态规划的本质模型是图论里的拓扑图**

## 概念

1. **最优子结构**: 原问题的最优解由子问题的最优解组合而来

> $f[i] = g(f[1], \dots, f[i - 1])$

2. **重复子问题**: 很多子问题会重复求解, 动态规划只求一次

> 从小到大求解 $f[i]$ 时, $f[1], \dots, f[i - 1]$ 会重复求解 

**对比**

分治: 没有重复子问题

贪心: 有最优子结构, 没有重复子问题

$~$

**无后效性**

$f[i]$ 确定后, 求解 $f[j], j > i$ 时的 $f[j]$ 不会因为 $f[i]$ 决策的不同而改变

即, 一旦 $f[j] 只跟 $$f[i]$ 的值有关, 与如何得到 $f[i]$ 无关

$~$

## 思路

1.  **$f_{ij}$ 含义**

   1.  $A_{ij}$ 含义: **第一步到当前步**所有选择组合而成的**选法方案**
   2. 属性: $\min, \max, \DeclareMathOperator{\cnt}{cnt} \cnt$

   > $f_{ij} = \min, \max, \DeclareMathOperator{\cnt}{cnt} \cnt A_{ij}$

2. **递推式**

   枚举**最后一步**的选择, 将 $A_{ij}$ 划分为更小的集合

   $A_{ij} =  g(\{A_{xy} | xy \in ij 的子问题 \})$

   $\DeclareMathOperator{\cnt}{cnt}
   f_{ij} = \min, \max, \cnt A_{ij} = \min, \max, \cnt g(\{A_{xy} \}) = \min, \max, \cnt g(\{f_{xy}\})$

   $\therefore f_{ij} = \min, \max, \cnt g(\{f_{xy}\})$

**递推式推导**

递推式推导时一定要分好情况进行讨论

推导时, 一定要把所有的状态分好类, 无论有多简单, 都要分好情况进行讨论

**状态分类**

常见分类: 起点与其他点

> 在路径问题中, 起点的路径数常 + 1

[统计所有可行路径](https://leetcode.cn/problems/count-all-possible-routes/)	先把所有状态分类, 再对每个状态进行递归式推导

## 做题步骤

1. 画出数据分布
2. 无后效性判断
3. 状态定义(靠猜)

$~$

## 技巧

### 问题等价变换

将问题进行等价变换, 使之更容易处理

1. **正向考虑** $\iff$ **反向考虑**

2. **起点到终点** $\iff$ **终点到起点**

   > 问题要求输出起点到终点的每一步的选择, 如果反向考虑
   >
   > 由于辅助数据存储时是反向存储的, 负负得正, 于是从终点到起点考虑问题时的辅助数据是正向存储的

3. **记忆化搜索改动态规划**

   记忆化搜索的思路比较好理解, 可以先从记忆化搜索的思路入手, 考虑 dfs 函数的下列因素

   1. 参数
   2. 返回值
   3. base case
   4. 如何递归

   然后根据**状态间的依赖关系**尝试将其改为动态规划写法
   
4. **问题等价变换**

   [出界的路径数](https://leetcode.cn/problems/out-of-boundary-paths/)	将问题等价变换到少走一步到达边界的路径个数

### 维度合并

将**高维数据**一一映射到**低维数据**, 减少边界条件出错的情况

```C++
f[2to1(i, j)] = f[2to1(x, y)] ...
```

### 数组下标

动态规划的数组下标一般从 1 开始, 因为初值可以设在下标为 0 的位置

> 注意如果题目给定数组的下标从 0 开始, 那么就要进行一个下标转换

$~$

### step 模型

推导递推式时, 常枚举最后一步的选择

那么这个**最后一步**的模型有哪些呢 ?

或者说, 每一步代表的模型有哪些

**1. 每件物品选或不选**

01 背包: 

step: 每个物品

选择: 物品选 或 物品不选

**2. 每个物品选几件**

多重背包:

step: 每个物品

选择: 每个物品选 0 ~ $s_i$ 件

**3. 每一步往哪走**

路径问题:

step: 每一步

选择: 往哪个方向走

**4. 两条路线每一步往哪走**

路径问题两条路径:

step: 走的步数 / 横纵坐标之和的对角线

选择: **确定两条路线分别走的方向**, 然后根据**乘法原理**乘起来

如: 路线1 能走 1 2 3 共三个方向, 路线2 能走 1 2 共两个方向

选择: {(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2)}

> (3, 2) 表示路线 1 走方向 3, 同时路线2 走方向 2

### 状态表示

猜测状态表示时, 更应该看是否满足中间过程前后状态的递推, 不应该看终止状态是否满足条件

### 状态定义

遇到一个未做过类似题型的 dp 问题时, 可以**先把所有的方案描述出来**, 然后再看如何**将所有的方案分个类**

分完类后, 再用集合定义**具体描述出方案定义**

> 可以根据方案里的细节, 根据哪些因素是否会影响状态转移, 可以将其加入到状态定义的维度中去

例: [最低加油次数](https://leetcode.cn/problems/minimum-number-of-refueling-stops/)	

**1. 所有方案**

从起点到达第 i 个加油站的**所有加油方案**

**2. 方案里的因素**

加油方案里能**细分的因素**有: **加油次数 A** , **加油后的油量 B**

**方案分类**: 根据**第 i 个**加油站**是否加油**分类

**3. 定义状态**

由于需要判断**油量 B 与距离 C**的关系

在 i 固定时, C 是固定的, 所以其实不用考虑 C 的影响

但 i 固定时, 当 A 固定后, 油量 B 是不固定的, 存在多种情况

但由贪心的思想, 我们当然想的是 **"在满足限制条件的前提下, i 和 A 固定后, B 尽可能大"**

于是, 状态定义就出来了: $\max B = f[i][A]$

$f[i][A]$ : 到达第 i 个加油站后, 加油次数为 A 时的最大油量

> 默认考虑过了限制条件的影响

例1: 求**树的直径**

问题: 求树的直径大小

**1. 方案描述**: 我们需要找到**所有的简单路径**, 然后找到**所有简单路径中最长的那个路径**, 其就是**树的直径**

**2. 方案分类**: 通过观察, 我们发现**所有在树上的简单路径**都有一个特点: **路径上的所有结点中有一个结点最高**

于是就可以**以简单路径上的最高结点为划分依据(指标)**, **将所有的简单路径分个类**

**3. 方案定义**: $A_i$ 表示以结点 i 为最高结点的所有简单路径

**4. 状态定义**: $f_i$ 表示以结点 i 为最高结点的所有简单路径中的**最长简单路径的长度**

> $f_i = \max A_i$

例2:  01 背包

探索为什么 01 背包的状态定义为 $f_{ij}$: 从前 i 个物品中选, 体积不超过 j 的最大价值

> 不写出 $f_{ij}$ 的定义, 应该从零出发推导出来 

**1. 方案描述**: 需要找到在体积的限制下, **所有的物品选择方案**, 然后找到所有方案中**价值最大的那个方案**, 其就是最大价值

**2. 方案分类 1**: 苦思冥想, 我也无法找到一个理由从固定的 n v 突破到灵动的 i j. 只能寻求一点点场外援助, 然后从 n, v 突破到 i, v

场外援助: 在数组 / 序列类问题中, 我们常常通过从左到右遍历元素(循环变量为 i), 然后一步步解决前 i 个元素的问题, 直到最后 i 遍历完整个数组了, 于是就解决了在整个数组上的问题. 这就是**循环不变式**的思想, 或者说**数学归纳法**, 或者说**多米诺骨牌**

例: 找到所有数组元素中的最大值

做法:

```C++
int maxi = -INF;
for(int i = 0; i < n; i++)
    maxi = max(maxi, a[i]);

// 循环结束后, maxi 是 [0, n) 中元素的最大值
```

**循环不变式视角**

maxi 表示 $[0, i)$ 范围内的最大值

1. 初始化

   maxi = -INF, i = 0, $[0, 0)$ 为空, 显然成立

2. 保持

   假定 maxi 表示 $[0, i)$ 范围内的最大值

   执行第 i 轮循环(下标从 0 开始):

   ​	maxi 会取 maxi 与 a[i] 的最大值

   于是 maxi 表示 $[0, i + 1)$ 范围内的最大值

   于是: 在循环变量 i 自增之后, 下一轮循环开始之前, 循环不变式成立

3. 终止

   循环结束时, i = n, 于是 maxi 表示 $[0, n)$ 范围内的最大值, 满足题目要求

**3. 方案分类 2**: 借助循环不变式的思想, 我们发现可以从前往后依次求出**在前 i 个物品中选, 体积为 v 的最大价值**, 当 i 循环到 n 的时候, 含义就是**在前 n 个物品中选, 体积为 v 的最大价值**

于是, 我们可以把状态定义为 $f_i$: 从前 i 个物品中选, 体积不超过 v 的最大价值

接下来就是 01 背包的经典分析了, 但有一点不太一样的地方: **我们的状态定义不太一样**

不管如何, 我们先**基于自己定义的状态 $f_i$** 进行分析

如何将 $f_i$ 分解呢, 我们求助于动态规划中常见的技巧: **枚举"最后一步"的选择**并分类讨论

此处的"最后一步"的选择显然就是: 第 i 个物品 {选, 不选}

case 1: 不选

那么 $f_i$ 显然等于 $f_{i-1}$, 把其代表的含义翻译出来就明白了

case2: 选

确定选择第 i 个物品, 于是问题转化为了从前 i - 1 个物品中选, 

关键点来了: 选择了第 i 个物品后, 我们的体积发生了变化, 背包空间 v 中被第 i 个物品的体积占据了一部分

我们需要表示前 i - 1 个物品中选, 体积不超过 v - v[i] 的状态

但 f[i - 1] 的状态定义已经不能满足此要求了, 我们需要额外表示体积这一维度

于是最终的状态定义如下

**3. 方案定义**: $A_{ij}$ 表示前 i 个物品, 体积为 j 的所有方案

**4. 状态定义**: $f_{ij}$ 表示前 i 个物品, 体积为 j 的所有方案的最大价值

于是, 最终的状态表示**既要考虑物品的影响, 也要考虑体积的影响**, 就成了现在的定义方式

### 状态定义 2

状态定义的**含义**要与所在**位置**有关

**1. 结尾**

状态定义与**结尾元素**有关的话, 一般以 **"最后一步"** 为划分

$f_{i}$: 以第 i 个元素**为结尾**的 XXX 的**最大值/最小值/个数**

$f_{ij}$: 以 $(i,j)$为**终点**的 XXX 的**最大值/最小值/个数**

**2. 开头**

状态定义与**开头元素**有关的话, 一般以 **"第一步"** 为划分

$f_{ij}$: 以 $(i,j)$为**起点**的 XXX 的**最大值/最小值/个数**

**3. 区间**

状态含义是区间的话, 既可以以 **"第一步"** 为划分, 也可以以 **"最后一步"** 为划分

具体如何**划分**要**以状态转移的需要为依据**

例1:

若定义 $f_i$ 表示区间 $[1,i]$ 的值, 如果**枚举第一步**的话, 区间就变成 $[2,i]$, 显然不能用 $f_i$ 的含义正确表示出来

所以需要**枚举最后一步**, 枚举最后一步, 区间就变成 $[1,i-1]$, 可以用 $f_{i-1}$ 来表示

例2:

[鸡蛋掉落](https://leetcode.cn/problems/super-egg-drop/)	

**状态定义**: $f_{ij}$: i 层楼, j 个鸡蛋, 极端情况下的最小操作次数

**动作: 扔鸡蛋**

**状态划分:**

由于 $f_{ij}$ 表示的是区间, 所以以 **"第一步"** 和 **"最后一步"** 为划分都是可以的, 关键要**看哪个能够进行状态转移**

若以 **"最后一步动作"** 为划分, 由于**最后一步动作**是由前面的**动作**决定的, 并**不能满足 dp 的无后效性**, 即 $f_{ij}$ 只由做出**最后一步动作**之前的子问题的值决定, 不受如何得到该子问题的动作影响

而以 **"第一步动作"** 为划分可以满足**无后效性**的要求, 首先**枚举第一步的动作**: 扔的楼层 k

分两种情况进行讨论: 

case1 : 鸡蛋碎了, 那么 f 一定在 **k 之前的楼层**, 同时**鸡蛋数量减一**

问题就转化为了 $f_{k-1j-1}$, 且只与 $f_{k-1j-1}$ 的值有关, 与如何得到 $f_{k-1j-1}$ 无关, 满足无后效性的要求

case2 : 鸡蛋没碎, 那么 f 一定在 **k 之后的楼层**, 同时**鸡蛋数量不变**

> k 看作第 0 层, 那么第 i 层就是 i - k 层

问题就转化为了 $f_{i-kj}$, 且只与 $f_{i-kj}$ 的值有关, 与如何得到  $f_{i-kj}$ 无关, 满足无后效性的要求

### 状态转移

前后状态转移时, 除了常见的表达式, 还会出现**前后状态间的关系又是一个 dp 问题**的情况

简单来讲, 就是 dp 问题套 dp 问题

**三状态间的转移**

当前状态 i 不仅与上一状态 j 有关, 还与上上状态 k 有关时, 需要在状态定义时记录当前 i 和上一状态 j

$A_{ij}$: [1..i] 的所有以 $a_i$ 结尾以 $a_j$ 为次尾的子序列

```C++
Aij 的划分: 子问题的最后一个元素和倒数第二个元素
for(int i = 1; i <= n; i++)
    for(int j = 1; j < i; j++)
        for(int k = 1; k < j; k++)
            if(...)		// 一般都有限制
                f[i][j] = max(f[i][j], f[j][k] + ...);
```



$~$

### 集合划分

目的: 细分集合 $A$

划分方式:

**1. 集合的并**

$A = A_1 \cup A_2 \cup \dots \cup A_i$

$\max A = \max \{A_1, A_2, \dots ,A_i\}$

$\min A = \min \{A_1, A_2, \dots ,A_i\}$

$\cnt A = \cnt A_1 + \cnt A_2 + \dots + \cnt A_i$

**2. 集合的笛卡尔积**

$A = A_1 \times A_2 \times \dots \times A_i$

> 前提是 $A_1, A_2, \dots, A_i$ 之前互不影响
>
> 假定 $\max A$ 和 $\min A$ 的表达式等于子集的和

$\max A = \max A_1 + \max A_2 + \dots + \max A_i$

$\min A = \min A_1 + \min A_2 + \dots + \min A_i$

$\cnt A = \cnt A_1 \times \cnt A_2 \times \dots \times \cnt A_i$

$~$

### 初始值设置

**1. 常规情况**

求最大时常设较小的值, 求最小时常设较大的值, 求数量时常设 0

**2. 特殊要求**

例: 背包容量必须用完

如果想要最终状态 ed 一定从某个起点 st 出发的话

**max**: 其余起点设为负无穷大, 起点 st 设为正常值, 使得其余起点完全竞争不过起点 st, **因为 st 远远比其余起点大**

**min**: 其余起点设为正无穷大, 起点 st 设为正常值, 使得其余起点完全竞争不过起点 st, **因为 st  远远比其余起点小**

**3. 求方案的初值**

求具体方案时, 记得在**初始化 f 函数初值的时候**同时**初始化记录方案的 函数 g 的初值**

```C++
f[0][0] = ... , g[0][0] = ...
```



### 记忆化搜索(DFS) 的赋值

记忆化搜索本质上使用 DFS 来实现的, 如果在搜索过程中出现重复访问自身结点的情况, 那么对于状态的赋值必须要在计算完成后才能赋值, 不然会返回错误的结果

```C++
int dfs(int i, int j)
{
    if(f[i][j] != -1) return f[i][j];
    
    int t = 0;				// 如果提前给 f[i][j] 赋值的话, 那么如果在递归计算子问题 dfs(x, y) 时
    						// 又访问了 dfs(i, j) 那么此时 f[i][j] 的值就不是 -1 了
    						// 在代码看来, 此时的 f[i][j] 已经计算完成, 于是返回了一个错误的答案
    						// 当然, 如果递归计算子问题时不会访问原问题, 那么就不会出现这种情况
    for ij 的子问题 xy:
    	t += dfs(x, y)	
    f[i][j] = t;
    return t;
}
```

### 记忆化搜索(DFS) 三种状态值

记忆化搜索共有三种状态值

1. **非法值**: 表示未访问过 / 未计算过
2. **合法正常值**: 表示已访问过 / 已计算过, 且**有对应的实际含义**
3. **合法非正常值**: 表示已访问过 / 已计算过, 但**没有对应的实际含义**

```C++
min 属性
非法值: -1
合法正常值: [0, INF)
合法非正常值: INF
        
int dfs(int x, int y)
{
    if(f[x][y] != -1) return f[x][y];
    
    if(...)		// 递归终止情况
        return f[x][y] = ...
    
    
    f[x][y] = INF;	// 先赋值为合法非正常值, 合法是因为要表明改状态已计算过, 防止重复计算导致超时
    
    f[x][y] = min(f[x][y], dfs(..., ...));
    
    return f[x][y];
}
```



### 时间复杂度优化

**递推式的等价变形**

[下降路径最小和  II](https://leetcode.cn/problems/minimum-falling-path-sum-ii/)    对递推式找到等价的表示方式, 且该表示方式对于程序来说时间复杂度更低

[完全背包问题](https://www.acwing.com/problem/content/3/)    $f_{ij}$ 的递推式可用 $f_{ij-v_i}$ 代替部分式子, 减少了计算量 

**剪枝**

根据性质, 如果可以**提前确定状态 $f_{ij}$ 的值**, 那么就可以不根据递推式计算 $f_{ij}$ 的值, 而是直接赋值, 相当于 dfs 中的剪枝

$~$

### 空间复杂度优化

**前提**

**1. 一个一维数组**

当前行的状态**只依赖上一行的状态**, 且只依赖**上一行单向上的状态**

```C++
int f[n]
f[j] = g(f[j], f[j - 1])
```

**2. 两个一维数组**

当前行的状态**只依赖上一行的状态**

```C++
int f[2][n]
f[i & 1][j] = g(f[(i - 1) & 1][j], f[(i - 1) & 1][j - 1])
```

**初始值的变化**

注意由空间复杂度优化引起的**初始值含义的变化**

如原本只想要 `f[0][0] = 0`, 

优化后变成 `f[0] = 0` ,初始化含义就变成了 `f[i][0] = 0`, 显然不符合原意

**如何考虑空间复杂度优化引起的初始值的变化 ?**

画好数据分布图(包含初始值), 考虑空间复杂度优化后的数据分布图

### 修改源数据

在源数据的某些数据如果需要特判的话, 可以考虑直接大胆修改源数据, 方便递推计算 f 函数值

### 时间复杂度估计

约为 **状态空间大小** $\times$ **选择的个数**

如:

01 背包问题: n 个物品, 体积为 v

约为 $O(2nv) = O(nv)$ 

多重背包问题: n 个物品, 每个物品最多选 s 次, 体积为 v

约为 $O(snv)$

$~$

## 题目分类

### 最优方案

最优方案指从**开始状态**到**终止状态**的**最优选择的序列**

**最优方案获取**

1. 根据**前后状态值**的关系**推测最优选择**

   ```C++
   if f[i][j] = f[i - 1][u]
       最优选择是从 f[i - 1][u] -> f[i][j]
   else if f[i][j] = f[i - 1][v]
       最优选择是从 f[i - 1][v] -> f[i][j]
   else
       ...
   ```

2. **状态转移时**用辅助数组**记录最优选择**

   ```C++
   if ...
       f[i][j] = f[i - 1][u]		
       g[i][j] = 最优选择 u
   else if ...
       f[i][j] = f[i - 1][v]
       g[i][j] = 最优选择 v
   else
       ...
   ```

**最优方案初始化**

记得在**初始化 f 值**的时候, 同时**初始化最优方案 g 的值**

**字典序最优方案**

一般情况下, 题目要求从起点到终点的字典序最优方案, 此时**状态转移的方向**, 或者说**状态的定义**就有点不一样

例: 01 背包的字典序最优方案

假定最终状态的转移路径存在**选择第一个物品**的情况, 那么**为了字典序最小, 必须选择第一个物品**, 

那么问题就缩小为**从 2 ~ n 这些物品中找到字典序最优方案**, 此时选择了第一个物品的状态作为新的最终状态

于是, 状态定义需要做出修改: $A_{ij}:$ 从 i ~ n 这些物品中选择, 体积不超过 j 的所有方案

> 状态转移方程: $f_{ij} = \max \{f_{i+1j}, f_{i+1j-v_i} + w_i \}$

```C++
for(int i = n; i >= 1; i--)
    for(int j = 0; j <= m; j++)
    {
        f[i][j] = f[i + 1][j];
		if(j >= v[i]) f[i][j] = max(f[i][j], f[i + 1][j - v[i]] + w[i]);
	}

// 生成字典序最小最优方案
for(int i = 1, j = m; i <= n; i++)
    if(j >= v[i] && f[i][j] == f[i + 1][j - v[i]] + w[i];
       cout << i << " ";
cout << endl;
```

* 总结: **状态转移自底向上的方向**要与**字典序优先级由高到低方向**相反

### 线性 dp

1. 单串 

   ```C++
   f[i] = g(f[i - 1],.. f[1])
   ```

   

## 题库

[打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

将一个复杂的 dp 问题分解为两个简单的 dp 子问题, 分解角度既可以为初值的不同, 也可以为范围的不同

[完全平方数](https://leetcode-cn.com/problems/perfect-squares/)	完全背包, 注意 j 的方向

[出界的路径数](https://leetcode.cn/problems/out-of-boundary-paths/)	记忆化搜索与 dp 的转换, 初始值的不同设置, 剪枝, 分类讨论递推式

[最大得分的路径数目](https://leetcode.cn/problems/number-of-paths-with-max-score/)	两个 dp 相互影响

### 记忆化搜索

考虑好是否计算过的条件设置, 设置不好很容易超时

[组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)	考虑好递归的终止条件

[统计所有可行路径](https://leetcode.cn/problems/count-all-possible-routes/)	递推式一定要分情况讨论

### 状态定义和划分整理

[最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)	

$A_{i}$: 以 $a_i$ 结尾的所有合法方案

划分: 与 $a_i$ 匹配的元素

```C++
case 1: ai = '('
    f[i] = 0
case 2: ai = ')'
    1. ai-1 = '('
    	f[i] = f[i - 2] + 2;
	2. ai-1 = ')'
        if(ai-1-f[i-1] = '(')
            f[i] = f[i - 1] + 2 + f[i - 2 - f[i - 1]]
```

[安排邮筒](https://leetcode.cn/problems/allocate-mailboxes/)	

$A_{ij}$: 前 i 个房子, j 个邮筒的所有方案

划分依据: 第 j 个邮筒的**影响范围**

> 按照以前的思维定式, 应该要枚举第 j 个邮筒的所在位置
>
> 但这样一来, 不能够唯一确定上一个邮筒的位置, 也就不容易确定子问题 

```C++
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= m;j++)
        for(int l = 1; l <= i; l++)		// 第 j 个邮筒影响范围左边界, 右边界固定为 i
       		f[i][j] = min(f[i][j], f[l - 1][j - 1] + s[l][i]);	
```

[通配符匹配](https://leetcode.cn/problems/wildcard-matching/)	

$A_{ij}$: s[1..i] 和 p[1..j] 的匹配方案

划分: 

首先要分情况讨论, 根据 pj 的类型进行讨论

case1: pj 是字母

```C++
pj 是字母时, 还要再次分情况讨论
    1. pj = si 时
    	Ai-1j-1
    2. pj != si 时
    	false
```

case2: pj 是 `'?'`

$A_{i-1j-1}$

case3: pj 是 `'*'`

> 笨方法是根据 '*' 的匹配范围[l, r]划分, r 固定死了为 i
>
> 那么剩下的就是枚举左边界 l
>
> 因为要考虑 [l, r] 为空的情况, 所以 l 的范围为 1~r+1
>
> 所以剩下要考虑的就是 Al-1j-1 是否匹配

枚举 `'*'` 是否使用

1. `'*'` 不使用

   $A_{ij-1}$

2. `'*'` 使用

   $A_{i-1j}$

[正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)

$A_{ij}$: s[1..i] 和 p[1..j] 的匹配方案

划分: 

首先要分情况讨论, 根据 pj 的类型进行讨论

case1: pj 不是 `'*'`

那么 pj 就必须跟 si 匹配上

$f(i, j) = i \and f_{i-1j-1} \and (p_j = $`'.'`$ \or p_j = s_i)$ 

case2: pj 是 `'*'`

正常情况下, 此时应该以 `'*'` 的影响范围为划分, 即枚举 `'*'` 匹配字符的个数, 表达式如下

$f(i,j) = f(i, j - 2) \or f(i - 1, j - 2) \and s_i \or f(i - 2, j - 2) \and s_i \and s_{i-1} \or \dots \or f(0, j - 2) \and s_i \and s_{i-1} \and \dots s_1$

> si 是 si == pj 的简写, 其他 si-1 ... s1 也一样

采用类似完全背包的思路, 写出 $f(i-1,j)$ 的表达式

$f(i - 1,j) = f(i - 1, j - 2) \or f(i - 2, j - 2) \and s_{i - 1} \or f(i - 3, j - 2) \and s_{i - 1} \and s_{i - 2} \or \dots \or f(0, j - 2) \and s_{i - 1} \and s_{i - 2} \and \dots s_1$

$\therefore$ $f(i, j) = f(i, j - 2) \or i \and f(i - 1, j) \and s_i$

[交错字符串](https://leetcode.cn/problems/interleaving-string/)

$A_{ij}$: s1[1..i] 和 s2[1..j] 组成 s3[1..i+j] 的方案

划分: s1i 与 s3i+j 是否匹配, s2j 与 s3i+j 是否匹配

> 初值的设置
>
> 要么在循环外设置, 然后再循环内不能将其覆盖掉
>
> 要么在循环内特判并赋值

```C++
for(int i = 0; i <= n; i++)
    for(int j = 0; j <= m; j++)
    {
        if(!i && !j)
        {
            f[i][j] = true;
            continue;
        }
        f[i][j] = i && f[i - 1][j] && s1[i] == s3[i + j] || j && f[i][j - 1] && s2[j] == s3[i + 1];
    }
```



## 练习

[不同路径](https://leetcode.cn/problems/unique-paths/)	

**1. 通项含义 / 状态表示**

通项 $f_{ij} = cntA_{ij}$

$A_{ij}$ : 从 (1, 1) 到 (i, j) 的所有走法(符合题目约束条件) 

**2. 递推式 / 状态转移**

1. **划分集合**

   1. 划分依据: 最后一步的选择

   2. 划分 $A_{ij}$

      最后一步走下: $A_{i-1j} + 走下$

      最后一步走右: $A_{ij-1} + 走右$

      $A_{ij} = \{A_{i-1j} + 走下, A_{ij-1} + 走右\}$

2. **递推式**

   $f_{ij} = cntA_{ij} = cnt\{A_{i-1j} + 走下, A_{ij-1} + 走右\} = cntA_{i-1j} + cntA_{ij-1} = f_{i-1j} + f_{ij-1}$

   $\therefore f_{ij} = f_{i-1j} + f_{ij-1}$

[下降路径最小和](https://leetcode.cn/problems/minimum-falling-path-sum/)	

**1. $A_{ij}$**

从第一行走到 $ij$ 的所有方案

每一步: 当前行走到下一行

每一步的选择: 当前行能走到下一行的三个位置

**2. $f_{ij}$**

$f_{ij} = \min A_{ij}$ 所有方案的最小路径和

**3. 递推式**

$f_{ij} = \min \{f_{i-1j}, f_{i-1j}, f_{i-1j+1}\} + a[i][j]$

**4. 无后效性**

$f_{ij}$ 只与子问题的值有关, 跟如何得到子问题的值无关, 满足无后效性

[统计所有可行路径](https://leetcode.cn/problems/count-all-possible-routes/)

分情况讨论练习

**1. $A_{ij}$**

从起点 st 走到 i, 汽油不超过 j 的所有路径

每一步: 当前点到下一点的走法

每一步的选择: 当前点走到与自己不同的点

**2. $f_{ij}$**

$f_{ij} = \cnt A_{ij}$ 所有路径的个数

**3. 无后效性**

$f_{ij}$ 只与上一步的路径个数有关, 与如何走到上一步的选择无关, 满足无后效性

**4. 递推式**

**状态分类**

所有状态分为两类: 终点与起点不同, 终点在起点上

即 $f_{ij}, i \neq st$ 和 $f_{ij}, i = st$

**case 1: $f_{ij}, i \neq st$**

则 $f_{ij}$ 上一步一定由不同的点转移过来, 故 $f_{ij} = \sum f_{xy}, x \neq i$ 

**case 2: $f_{ij}, i = st$**

$f_{ij}$ 上一步除了由不同的点转移过来外, 还有可能从 st 转移过来, 因为本身就在 st 上,哪都不用走就是一个方案, 还因为按照 case 1 的计算方案, 路径上相邻两个点一定是不同的, 还要加上本身就在 st 点这个方案

## 提高课

#### 合法状态

状态分合法与不合法, 所有的**合法状态只能由合法状态转移过来**

**状态合法与不合法的区分方式**

**区分方式 1: 非法值**

赋予状态一个**非法值**, 只用于表示**非法状态**, **不表示实际含义**

需要在状态转移时判断上一状态是否合法

```C++
f[0] = 0 (合法值)	f[0] = -1 (非法值)

状态转移:
	if(f[u] != -1)		// 合法性判断
        f[v] = g(f[u])
    else
        f[v] = -1		// 若所有的上一状态不合法, 那么该状态一般也不合法, 因为不能由某个合法状态转移过来
```

**区分方式 2: 理论不可达值**

赋予状态一个理论上不可达到的值, **该值理论上能够表示实际含义**, 但**实际转移时不会转移到其他状态**

不需要在状态转移时判断上一状态是否合法, 但需要**根据实际问题设置理论不可达值**

```C++
fi = min Ai 	
min 模型, 那么理论不可达值为正无穷大, 因为正常值与正无穷大相比, 无论何时都是正常值在 min 模型的竞争中获胜, 得以由其转移到下一状态
所以只需要将非法状态赋值为正无穷大, 合法状态正常设值, 那么非法状态一定不会转移到别的状态
    
f[0] = 0 (正常值)  f[0] = +INF (理论不可达值)
f[v] = min(f[u1], f[u2])
    
一般情况下, 实际含义中的理论不可达值常为: 
min: 理论不可达值为 +INF
max: 理论不可达值为 -INF
cnt: 理论不可达值为 0
```



### 集合 A 的模型

问题模型之上的抽象

#### 路径模型

一条路径

**1. 从起点走到当前点, 路径的所有方案**

$A_{ij}$ : 终点为 $(i, j)$ 的所有路径

> 从 st 到 (i, j) 的所有方案, st 可不固定

```C++
Aij 的划分: 最后一步的选择
Aij = A.. + 最后一步
```

$A_{ij}$ : 起点为 $(i, j)$ 的所有路径

```C++
Aij 的划分: 第二步的选择
Aij = A.. + 第二步
```



两条路径

**2. 两条路线, 同时从起点到当前线走, 路径的所有方案**

> 从 st 和 st 到 (k, i1, i2) 的所有方案

```C++
Aki1i2 的划分: 最后一步的选择
Aki1i2 = Ak-1.. + 最后一步   
```

$~$

#### 子序列模型

子序列问题, **问题仅与位置 i 有关**时, 就为单串 $f_i$ 的问题

在此基础上, 如果**问题还与某种影响因素 k 有关**, 就扩展为多维 dp

k 的实际意义常见的有: **长度, 个数, 次数, 公差, 颜色等**, 用一个词来形容就是 **状态**

[带维度单串 dp[i][k]](https://leetcode.cn/leetbook/read/dynamic-programming-1-plus/5mw29e/)

**一个子序列**

**1. 从开头到当前下标, 所有的子序列**

> [1..i] 的所有子序列

```C++
Ai 的划分: 子序列的最后一个元素
Ai = A. + 子序列的最后一个元素
```

有条件约束的子序列

**2. 从开头到当前下标, 所有以 $a_i$ 结尾的子序列**

> [1..i] 的所有以 $a_i$ 结尾的子序列

```C++
Ai 的划分: 子序列的倒数第二个元素
Ai = A. + 子序列的倒数第二个元素
```

**3. 从开头到当前下标, 最后一个元素为 $a_i$ 并且倒数第二个元素为 $a_j$ 的子序列**

> $A_{ij}$: [1..i] 的所有以 $a_i$ 结尾以 $a_j$ 为次尾的子序列

```C++
Aij 的划分: 子问题的最后一个元素和倒数第二个元素
for(int i = 1; i <= n; i++)
    for(int j = 1; j < i; j++)
        for(int k = 1; k < j; k++)
            if(...)		// 一般都有限制
                f[i][j] = max(f[i][j], f[j][k] + ...);
```

**4. 从开头到当前下标, 最后一个元素为 $a_i$ 公差为 d 的子序列**

> $A_{ij}$: [1..i] 的所有以 $a_i$ 结尾以 $a_j$ 为次尾的子序列

```C++
Aij 的划分: 子问题的最后一个元素和倒数第二个元素
for(int i = 1; i <= n; i++)
    for(int j = 1; j < i; j++)
        for(int k = 1; k < j; k++)
            if(...)		// 一般都有限制
                f[i][j] = max(f[i][j], f[j][k] + ...);
```



**两个子序列**

**5. 从两个开头到两个当前下标, 所有的子序列**

> [1..i] 选第一个子序列 a, [1..j] 选第二个子序列 b, 所有的 (a, b)

```C++
Aij 的划分: 两个子序列的最后一个元素的笛卡尔积
Aij = A.. + (a 的最后一个元素, b 的最后一个元素)
```



公共子序列

**6. 从两个开头到两个当前下标, 所有的公共子序列**

> 从 [1..i] 选第一个子序列 a, 从 [1..j] 选第二个子序列 b
>
> a = b 的条件下, 所有的公共子序列

```C++
Aij 的划分: 两个子序列的最后一个元素的笛卡尔积是否有 ai 和 bj
Aij = A.. + (a 的最后一个元素, b 的最后一个元素)
    
根据 a 的最后一个元素是否为 ai, b 的最后一个元素是否为 bj, 可分为:
00, 01, 10, 11		// 0 表示否, 1 表示是
    
case 1: a.back 不是 ai, b.back 不是 bj
    就是 A i-1 j-1
case 2: a.back 不是 ai, b.back 是 bj
    是 A i-1 j 的子集
case 3: a.back 是 ai, b.back 不是 bj
    是 A i j-1 的子集
case 4: a.back 是 ai, b.back 是 bj
    ai = bj 时, 是 A i-1 j-1 + (ai, bj)
```

$A_{ij}$: s 前 i 个元素, t 前 j 个元素, 所有公共子序列的所有方案

例: s = "abc", t = "abc"

$A_{11} = \{a\}$

$A_{12} = \{a\}$, $A_{21} = \{a\}$

> 末尾元素不相等的情况 $s_1 \neq t_2$ $s_2 \neq t_1$
>
> $A_{12} = A_{11}$, $A_{21} = A_{11}$  

$A_{22} = \{a, b, ab\}$

> 末尾元素相等 $s_2 = t_2$
>
> $A_{22} = A_{11} \cup (A_{11} \times \{s_2\}) \cup \{s_2\}$

$A_{23} = \{a, b, ab\}$, $A_{32} = \{a, b, ab\}$

> 末尾元素不相等 $s_2 \neq t_3$ $s_3 \neq t_2$
>
> $A_{23} = A_{22}$, $A_{32} = A_{22}$  

$A_{33} = \{a, b, c, ab, ac, bc, abc\}$

> 末尾元素相等 $s_3 = t_3$
>
> $A_{33} = A_{22} \cup (A_{22} \times \{s_3\}) \cup \{s_3\}$

**7. 从两个开头到两个当前下标, 所有以 bj 为结尾的公共上升子序列**

> [1..i] 选第一个子序列 a, [1..j] 选第二个子序列 b
>
> a = b 的条件下, 所有以 bj 结尾的公共上升子序列

```C++
Aij 的划分: 以 bj 结尾的公共上升子序列是否含有 ai
划分: 
不含 ai, 即 fi-1 j
含有 ai, 再次划分
    划分: 公共子序列倒数第二个元素
    前提是满足 LIS 要求
        空: 1
        b1: fi-1 1
        b2: fi-1 2
        ...
        bj-1: fi-1 j-1
```

#### 组合模型

一维限制

**1. 从前 i 个物品中选, 限制为 j**

> $A_{ij}$ : 从前 i 个物品中选, 限制为 j 的所有方案

**"限制"的常见类别:**

1. 体积 $\leq j$

   > 所有初值设为 0
   >
   > 体积 $v \geq 0$

2. 体积 $= j$

   > $f[0] = 0, f[i] = \infty 或 -1 或 0$ (根据实际问题出发设置非法值)
   >
   > 体积 $v \geq 0$

3. 体积 $\geq j$  

   > $f[0] = 0, f[i] = \infty 或 -1$
   >
   > 体积 v 不限制, v 可以是负数 0 和 正数, 但由于数组没有负数下标, 在负数状态与 0 状态等价的前提下, 可以将负数状态与 0 状态合并表示合法状态

```C++
Aij 的划分: 第 i 个物品是否选择
不选: Ai-1 j
选: Ai-1 j-vi + 选择 ai
```

二维限制

**1. 从前 i 个物品中选, 限制 1 为 j, 限制 2 为 k**

> $A_{ijk}$ : 从前 i 个物品中选, 限制 1 为 j, 限制 2 为 k的所有方案

[潜水员](https://www.acwing.com/problem/content/description/1022/) : 限制不再是 **不超过**, 而是 **不小于 / 至少为**

> 思路是将限制条件所在的维度, 初始状态的 0 值及负值看作合法状态(统一用 0 表示), 其余看作非法状态

```C++
Aijk 的划分: 第 i 个物品是否选择
不选: Ai-1 j k
选: Ai-1 j-vi k-vi + 选择 ai
```

#### 状态机模型

所有的状态分个类, 不同类别状态间的转移是一个状态机

$A_{ij}$: 走到第 i 步, 状态为 j 的所有方案

> j 为状态机中的状态, 对所有的状态进行一个分类

$f_{ij}$: 对于状态机中的每一个状态 j, 都要**单独**进行**递归式推导**

**状态机的起点**

状态机必须由起点开始, 起点也需要指向一些状态

在 dp 代码中, 必须设计成**第一个状态只能由起点(起点可能有多个)转移过来**

**必须设置起点在与其余状态的竞争中获胜**, 具体参考 dp 初值的设置

```C++
f[0][0] = 0, f[0][1] = -INF;

for(int i = 1; i <= n; i++)
    f[i][0] = max(f[i - 1][0], f[i - 1][1]);
	f[i][1] = f[i - 1][0] + w[i];
```

**状态机的步**

**状态机的一步状态转移**相当于 **dp 中一步状态的转移**

#### 状态压缩模型

用十进制数的二进制表示每一位上的 0/1 表示整体 n 位的状态

**1. 基于连通性 / 棋盘**

**一维状态压缩**

$A_{ij}$ : 前 i 行 / 列, 第 i 行 / 列的状态为 j 的所有方案, j 常用其**二进制含义解释状态**

$A_{ij}$划分: 第 i 行状态 j 与第 i - 1 行状态 k 的所有合法路径

**合法状态**: 常用 **j & k** 和 **j | k** 来计算是否合法, 通常还需要**预处理出所有的合法状态**

**结果**: 通常用第 n + 1 行 / 列的结果来表示最终答案, 通常是 `f[n + 1][0]`

**前提**: 要求第 i 行 / 列的状态只与第 i - 1 行 / 列的状态有关

**trik**

```C++
// 判断状态是否有连续的 1
return !(st & st >> 1)
    
// 判断两个状态是否有 十字重合
if(a & b)	// 重合
    
// 判断两个状态是否有 井式重合
if(a & b  ||  a | b 有连续的 1)		// 重合
    
// 判断状态是否与棋盘状态合法
// st: 第 i 行的状态, 1 表示有 0 表示无
// g[i]: 第 i 行的棋盘状态, 1 表示不能放, 0 表示能放
if(st & g[i])	// 不合法
    
// g[i]: 第 i 行的棋盘状态, 1 表示能放, 0 表示不能放
if(st & g[i] == st)	// 合法
```

**二维状态压缩**

$A_{ijk}$ : 前 i 行 / 列, 第 i 行 / 列的状态为 j , 第 i - 1 行 / 列的状态为 k 的所有方案

$A_{ijk}$划分: $A_{ijk}$ 划分为 $A_{i-1kl}$ k 是同一个状态, 划分依据是 l 的不同, 不过一般要考虑 l 对 j 的影响

**结果**: 通常用第 n + 2 行 / 列的结果来表示最终答案, 通常是 `f[n + 2][0][0]`

**前提**: 要求第 i 行 / 列的状态与第 i - 1 和 i - 2 行 / 列的状态都有关

$~$

**2. 集合**

状态常表示为集合中每个元素是否使用, 1 表示使用, 0 表示未使用

**$A_{ij}$**: 从起点走到 i, 每个点是否走的状态为 j 的所有方案

**遍历顺序:** 一定要画图弄明白各维度的依赖关系, 才能最终搞明白遍历所有可行的遍历顺序

```C++
// 常见的状态依赖导致的遍历顺序
状态 j 依赖与比 j 小的状态 k
i 所在维度没有依赖关系, 或者说依赖关系是任意的(所有)
    
// 遍历
for j = 0 to (1 << n) - 1
    for i = 0 to n - 1
    
for j = 0 to (1 << n) - 1
    for i = n - 1 to 0
```

**trik**

```C++
从起点走向任意一点且每个点只走一次的路径问题,
由于起点必走, 所以遍历状态时, 可以保证起点所在位必为 1, 且每次递增时 + 2, 保证了起点状态必为 1
    
for(int i = 1; i < 1 << n; i += 2)
    ...
```

#### 区间模型

以区间 `[l, r]` 为对象进行**状态定义和递推**

> 由于二维区间模型划分不够形象, 不太好理解, 有时可以采用记忆化搜索的方式实现二维区间 dp

**1. 一维区间**

**$A_{ij}$**: 区间 `[i, j]` 的所有合法方案

$A_{ij}$划分: 以区间的最后分界点为划分依据, 大区间 `[i, j]` 划分为两个非空小区间 `[i, k]` 和  `[k, j]`

初始化: 常设置**区间长度为 1 的区间为合法值**, 其余区间为非法值

前提: **区间划分只与区间的状态值有关**, 与如何得到该状态值无关, 即无后效性

```C++
// 初始化
for(int i = 1; i <= n; i++) f[i][i] = ...
    
// 递推
for(int len = 2; len <= n; len++)
    for(int i = 1; i + len - 1 <= n; i++)
    {
        int j = i + len - 1;
        for(int k = i; k < j; k++)	// 枚举左边区间的右端点
            f[i][j] = ... f[i][k] ... f[k + 1][j] ...
	}
```

**初始化**

区间模型的状态一般**最初都来自于区间长度为 1 的状态**, 或者说**都由区间长度为 1的状态转移而来**

所以一般**要对区间长度为 1 的状态正确初始化**

**易犯错部分**

1. 划分区间时, 设分界点为 k, 则一个区间为 [l, k], 另一个为 [k + 1, r]

   千万别忘了 k + 1

2. 已知区间**左端点** `i` 和长度 `len`, 则区间**右端点**为 `i + len - 1`, 一定要记得 `-1`

   尤其是区间长度为 n 的时候, 应该是 `[i, i + n - 1]`

**2. 一维环形区间**

环形区间: 首尾相连的区间, 其余均与一维区间问题相同

**trik:**

将区间再次复制一份到区间末尾, 然后遍历**区间长度范围不变**, 但**区间左端点的范围增大了**

```C++
for(int i = 1; i <= n; i++) cin >> a[i], a[i + n] = a[i];

for(int len = 1; len <= n; len++)
    for(int i = 1; i + len - 1 <= 2 * n; i++)
    {
        int j = i + len - 1;
        for(int k = i; k < j; k++)
            f[i][j] = ...
    }

int res = ...
    for(int i = 1; i <= n; i++)
        res = ... f[i][i + n - 1]
```

**3. 一维树形区间**

以二叉树的遍历(前中后)序列为研究对象, 看作一个区间, 研究二叉树相关区间 dp

$A_{ij}$: 给定二叉树的遍历序列, 以**点 i 为左端点, 点 j 为右端点**的所有**二叉树建树方案**

$A_{ij}$ 划分: 以建树方案的最后一步选择为划分依据, 通常为根节点的选择

```C++
// 初始化常对叶节点和空结点进行初始化
for(int i = 1; i <= n; i++) f[i][i] = ...		// 叶节点初始化
for(int i = 0; i <= n; i++) f[i + 1][i] = ...	// 空节点初始化, 或者直接在递推时特殊处理

for(int len = 2; len <= n; len++)
   	for(int i = 1; i + len - 1 <= n; i++)
    {
        int j = i + len - 1;
        for(int k = i; k <= j; k++)
            原问题 f[i][j], 子问题 f[i][k - 1], f[k + 1][j]
    }
```

**4. 二维区间(矩阵)**

二维区间即为矩阵, 可用**左上角坐标 + 右下角坐标**唯一表示

$A_{x_1, y_1,x_2y_2}$:  二维区间 (x1, y1, x2, y2) 的所有划分方案

$A_{x_1, y_1,x_2y_2}$ 划分: 以**最后一次分割线**为划分依据, 不仅要考虑**分割方向**, 还要考虑分割完后**以哪个二维区间为下一次分割的对象**

```C++
int dfs(int x1, int y1, int x2, int y2, ...)
{
    ...			// 剪枝
    
    int &v = f[x1][y1][x2][y2];
    if(v != -1) return v;
    
    if(...)		// 递归终止条件
        return v = ...
        
    f[x1][y1][x2][y2] = INF;
        
    // 横向切
    for(int i = x1; i < x2; i++)
    {
        v = min(v, dfs(x1, y1, i, y2, ...) + ...);		// 选择上半部继续切
        v = min(v, dfs(i + 1, y1, x2, y2, ...) + ...);	// 选择下半部继续切
    }
    
    // 纵向切
    for(int j = y1; j < y2; j++)
    {
        v = min(v, dfs(x1, y1, x2, j, ...) + ...);		// 选择左半部继续切
        v = min(v, dfs(x1, j + 1, x2, y2, ...) + ...);	// 选择右半部继续切
    }
    
    return v;
}
```

#### 树模型

**树定型**

通常给定一个无向树, 即根节点是任意的

**这不利于分析问题**, 我们可以**以任意一个结点作为根节点**, **以其为根将整棵树拎起来**

##### 树中的路径

选结点 i 作为 "圆心"

"直径" 

$A_i$: 以结点 i 为最高点的简单路径

> 以结点 i 为最高点的简单路径, 可以**将所有的简单路径方案进行很好的分类**, 但**不容易进行集合划分**
>
> 因为与以 i 的子结点为最高点的简单路径不能联系起来, 不能进行**集合划分**
>
> 但可以作为一个**中间思路**描述出来

"半径"

**向下走**

$A_i$: **从结点 i 开始, 向子树方向延伸的所有简单路径**

> 有点像 LIS 模型中的状态定义 $A_i$ : 前 i 个元素, 所有以 $a_i$ 结尾的子序列

$A_i$ 划分: 紧挨着结点 i 的倒数第二个结点

```C++
Ai 划分:
for j in 结点 i 的所有子结点
	Ai = Aj + 结点 i
```

**向上走**

$A_i$: **从结点 i 开始, 向根节点方向延伸的所有简单路径**

> 有点像 LIS 模型中的状态定义 $A_i$ : 前 i 个元素, 所有以 $a_i$ 结尾的子序列

$A_i$ 划分: 紧挨着结点 i 的倒数第三个结点

> 因为向子树方向延伸, 所以倒数第二个节点固定为结点 i 的父亲结点, 所以以倒数第三个结点作为划分依据

```C++
设 p[N] 表示每个结点的父亲结点
Ai 划分:
for  j  in  {p[i] 的所有子节点 - i, p[p[i]]}
	Ai = Aj + 边 (p[i], i)
      
// {p[i] 的所有子节点 - i, p[p[i]]}
p[i] 的所有子节点 - i : p[i] 的所有子节点不包含结点 i 的结点集合
p[p[i]]: i 的父亲结点的父亲结点		// 爷父子三代同堂了
```

##### 树中的子树

选结点 i 作为子树的根节点

**$A_{ij}$: 以结点 i 为根的子树中, 子树状态为 j 的所有方案**

> $A_{ij}$划分: 以子树状态与当前树状态的关系进行划分

**子树状态与当前树状态的关系**

**1. 分组背包模型**

**$A_{ij}$: 以结点 i 为根的子树中, 资源为 j 的所有方案**

> 每颗子树是一个物品组, 每个物品是子树的不同状态
>
> 设当前结点为 u, 状态为 j, 子结点为 v
>
> 以 v 为根的子树是一个物品组, 物品有: f[v\][0], f[v\][1], ... , f[v\][j]
>
> **所有的物品组就是所有 u 的子树**, 每个物品组的物品就是**子节点的所有状态**

每颗当前树的子树都是一组物品, 物品指对应子树的状态, 体积根据状态确定, 价值一般是子树相应状态的值

```C++
void dfs(int u)
{
    // 整体目标: 求以 u 为根的子树中, 状态为 j 的最大价值
    for(int i = h[u]; i != -1; i = ne[i])	// 循环物品组
    {
        int son = e[i];
        dfs(son);
        for(int j = m; j >= 0; j--)			// 枚举体积
            for(int k = 0; k <= j; k++)		// 枚举每个物品
                f[u][j] = max(f[u][j], f[u][j - k] + f[son][k]);	// f[u] 数组作为滚动数组
    }
    for(int j = m; j >= 0; j--)
        f[u][j] = ...		// 将 f[u][j] 修正为应有的值, 因为此前只是将 f[u] 数组当作一个临时数组存储值
}
```

```C++
void dfs(int u)
{
    // 整体目标: 求以 u 为根的子树中, 状态为 j 的最大价值
    for(int i = h[u]; i != -1; i = ne[i])	// 循环物品组
    {
        int son = e[i];
        dfs(son);
        // 如果子树物品被用到, 那么物品 u 一定被用到, 所以要预留体积为 v[u] 的空间
        for(int j = m - v[u]; j >= 0; j--)			// 枚举体积
            for(int k = 0; k <= j; k++)		// 枚举每个物品
                f[u][j] = max(f[u][j], f[u][j - k] + f[son][k]);	// f[u] 数组作为滚动数组
    }
    for(int j = m; j >= 0; j--)
        if(j >= v[u]) f[u][j] = f[u][j - v[u]] + w[u];
    	else f[u][j] = 0;
}
```

**2. 状态机模型**

结点 u 选与不选 会影响到结点 v 的选择, 通常没有体积的限制

> u 为 v 的父亲节点

u v 互斥, 若其中一个选了, 另一个就不能选

u v 保底, 至少选择 u v 其中一个

**状态定义**

$A_{uj}$: 从 u 为根的子树中选, u 的状态为 j 的所有方案 (j = 0 和 1,  0 表示不选, 1 表示选) 

```C++
// u v 互斥
for  v  in  u 的所有邻接点
    f[u][0] += max(f[v][0], f[v][1]);
    f[u][1] += f[v][0]
   
        
// u v 保底
设 u 的子节点数为 k
        
f[u][0]		// 子树必须选一个
int sum = 0;
for  v  in  u 的所有邻接点
    sum += min/max(f[v][0], f[v][1]);	// 先把所有子树选不选的和加起来
for  v  in  u 的所有邻接点	// 枚举每个子节点, 让该子节点选, 并用 sum 减去该子节点的部分
    f[u][0] = min/max(f[u][0], f[v][1] + sum - min/max(f[v][0], f[v][1]))	

    
// 若题目要求, 当前结点不选的话, 所有子节点都必须选, 那么就是下面这种表达式
for  v  in  u 的所有邻接点
	f[u][0] += f[v][1]
    
    
f[u][1]		// 子树选不选都行
for  v  in  u 的所有邻接点
    f[u][1] += max(f[v][0], f[v][1])	
```

#### 数模型

常为某个区间内满足条件的数的个数

```C++
要求: 求出 [l, r] 内满足条件的数的个数

// 利用前缀和思想
先求出任意 s(r) = [1, r] 内满足条件的数的个数	// 定义 s(r) = [0, r] 也行
然后用 [1, r] - [1, l-1] 就是 [l, r] 内满足条件的数的个数
即 s(r) - s(l - 1)
```

从**树的角度**考虑数位 DP



$~$

### 问题模型

#### 数字三角形模型

**从起点到某点走过路径的所有方案**

[方格取数](https://www.acwing.com/problem/content/1029/)

$A_{ki_1i_2}$ : 两条路线走同样的步数, 从 (1, 1) 和 (1, 1) 走到 (i1, k - i1) 和 (i2, k - i2) 的所有方案

step: 横纵坐标之和代表的对角线

[传纸条](https://www.acwing.com/problem/content/277/) 	特殊状态特殊判断, 分类讨论, 分类进行递推式推导

#### 最长上升子序列(LIS)模型

> **LIS : Longest Increasing Subsequence**

**以某元素为结尾的所有方案**

[登山](https://www.acwing.com/problem/content/1016/)

动态规划方法预处理出每个元素左右两边的 LIS, 然后以此为基础求出结果

[友好城市](https://www.acwing.com/problem/content/description/1014/)

分析性质, 得出 LIS 模型, 然后用模板解决问题

> 由于程序中常顺序考虑问题, 考虑 n 个元素的关系太复杂
>
> 一般尝试考虑任意两个(或相邻两个元素)元素, 查找其关系 / 性质
>
> 如果两个元素的位置关系不固定, 不妨设元素间的位置关系

分析:

考虑任意两个元素 (a, b) 和 (c, d), 什么情况下满足建桥相交 ?

不妨设 $a \leq c$ , 且固定 a 和 c 的位置

> 即位置关系由第一个元素确定

由于 b 和 d 都不固定, 可以先固定一个位置

**固定 b**

画图可知, $d > b$ 时不相交, $d \leq b$ 时相交

固定 d 时, 同理可得相同的结论

特殊情况: a 和 c 相等时, 也能得到相同的结论

> 复杂问题简单考虑
> n 个元素的关系, 简化成任意两个元素的关系
> 任意两个元素的关系, 简化成前后任意两个元素的关系
> 元素的分量间的关系, 简化成固定一个元素, 另一个元素变化

**得到性质:**

$a \leq c$ 时, $b < d$ 时不相交, $b \geq d$ 时相交

贪心性质: 只要最后一个桥(最后一个选中元素)与当前元素不相交, 那么当前元素与之前选中的元素都不相交

**于是, LIS 模型抽出:** 在对元素 (a, b) sort 的情况下, 元素的第二个分量满足 LIS 模型 

#### 最长公共子序列(LCS)模型

> **LCS: Longest Common Subsequence**

$A_{ij}$: 从 a[1..i], b[1..j] 中选, 所有的公共子序列

划分: 公共子序列是否含有 $a_i$, $b_j$

```C++
公共子序列:
不含 ai, 不含 bj	f[i - 1][j - 1] 就是这种情况
不含 ai, 含 bj		f[i - 1][j] 包含这种情况和上面那种情况
含 ai, 不含 bj		f[i][j - 1] 包含这种情况和第一种情况
含 ai, 含 bj		f[i - 1][j - 1] 就是这种情况 (前提是 ai = bj)
```

[最长公共子序列](https://www.acwing.com/problem/content/899/)

#### 最长公共上升子序列模型

$A_{ij}$: 从 a[1..i], b[1..j] 中选, 所有以 bj 结尾的公共上升子序列

划分: 以 bj 结尾的公共上升子序列是否含有 ai

```C++
不含 ai: fi-1j
含有 ai:
前提条件是 ai = bj
    再次划分
		划分依据: 倒数第二个元素(LIS)
        前提条件是满足上升子序列的要求
            空: 1
            b1: fi-1 1
            b2: fi-1 2
            b3: fi-1 3
            ...
            bj-1: fi-1 j-1
```

#### 背包模型

$A_{ij}$: 从前 i 个物品中选, 体积不超过 j 的所有方案(组合)

划分: 最后一个物品是否选择

```C++
不选: Ai-1 j
选: Ai-1 j-vi + 选择 ai
```

$A_{ij}$: 从前 i 个物品中选, 体积刚好为 j 的所有方案(组合)

$A_{ij}$: 从前 i 个物品中选, 体积至少为 j 的所有方案(组合)

$A_{uj}$: 从以 u 为根的子树中选, 体积不超过 j 的所有方案(组合)

#### 状态机模型

$A_{ij}$: 走到第 i 步, 状态为 j 的所有方案

划分: 状态 j 由哪些状态转移过来

```C++
根据状态机的定义: 状态 j 可以由哪些状态转移过来
    Aij = Ai-1 k1
    Aij = Ai-1 k2
    ...
    Aij = Ai-1 kl
```



#### 状态压缩 DP

##### 棋盘式(基于连通性)

[蒙德里安的梦想](https://www.acwing.com/problem/content/293/)

$A_{ij}$: 第 i 列中, 上一列伸出来的第 i 列所有小方格的状态为 j 的所有方案

> 只考虑 $1 \times 2$ 小方格的放法

```C++
Aij 划分: 第 i 列与第 i - 1 列的合法状态
设第 i - 1 的状态为 k
    1. 第 i 列与第 i - 1 列伸出的小方格不能重合
    	表现为 j & k == 0
    2. 第 i 列与第 i - 1 列所有伸出的小方格合并在一块的时候, 不能有奇数个空, 因为放不下 2 X 1 的小方格
    	表现为 j | k 没有连续奇数个 0, 要提前预处理好
```

##### 集合

状态常表示为集合中每个元素是否使用, 1 表示使用, 0 表示未使用

$A_{ij}$: 从起点走到 i, 每个点是否走的状态为 j 的所有方案

**遍历顺序:** 一定要画图弄明白各维度的依赖关系, 才能最终搞明白遍历所有可行的遍历顺序

```C++
// 常见的状态依赖导致的遍历顺序
状态 j 依赖与比 j 小的状态 k
i 所在维度没有依赖关系, 或者说依赖关系是任意的(所有)
    
// 遍历
for j = 0 to (1 << n) - 1
    for i = 0 to n - 1
    
for j = 0 to (1 << n) - 1
    for i = n - 1 to 0
```

#### 区间模型

**$A_{ij}$**: 区间 `[i, j]` 的所有合法方案

$A_{ij}$划分: 以区间的最后分界点为划分依据, 大区间 `[i, j]` 划分为两个非空小区间 `[i, k]` 和  `[k, j]`

```C++
Aij 划分: 区间分界点
设分界点为 k, k 一般为左边区间的右端点
    枚举 k 的范围为 [i, j - 1]
    i: Aii 和 Ai+1j
    i+1: Aii+1 和 Ai+2j
    ...
    j-1: Aij-1 和 Ajj
```

环形区间: 首尾相连的区间, 其余均与一维区间问题相同

应对方法: 将区间再次复制一份到区间末尾, 然后遍历**区间长度范围不变**, 但**区间左端点的范围增大了**

[凸多边形的划分](https://www.acwing.com/problem/content/1071/)

$A_{ij}$: 以点 i 为左端点, 点 j 为右端点的所有方案

$f_{ij} = \min A_{ij} $

$A_{ij}$划分: 确定三角形两个点为 i 和 j, 划分依据是合法的第三个点

$f_{ij} = \min \{f_{ij}, f_{ik} + f_{kj} + w[i] \times w[k] \times w[j]\}$

