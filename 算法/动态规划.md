# 动态规划

## 概念

1. **最优子结构**: 原问题的最优解由子问题的最优解组合而来

> $f[i] = g(f[1], \dots, f[i - 1])$

2. **重复子问题**: 很多子问题会重复求解, 动态规划只求一次

> 从小到大求解 $f[i]$ 时, $f[1], \dots, f[i - 1]$ 会重复求解 

**对比**

分治: 没有重复子问题

贪心: 有最优子结构, 没有重复子问题

$~$

**无后效性**

$f[i]$ 确定后, 求解 $f[j], j > i$ 时的 $f[i]$ 不会改变

即, 一旦 $f[i]$ 确定, 永远就不会改变了

$~$

## 思路



### 时间复杂度估计

约为 **状态空间大小** $\times$ **选择的个数**

如:

01 背包问题: n 个物品, 体积为 v

约为 $O(2nv) = O(nv)$ 

多重背包问题: n 个物品, 每个物品最多选 s 次, 体积为 v

约为 $O(snv)$

## 题目分类

### 线性 dp

1. 单串 

   ```C++
   f[i] = g(f[i - 1],.. f[1])
   ```

   

## 题库

[打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

将一个复杂的 dp 问题分解为两个简单的 dp 子问题, 分解角度既可以为初值的不同, 也可以为范围的不同

[完全平方数](https://leetcode-cn.com/problems/perfect-squares/)	完全背包, 注意 j 的方向



### 记忆化搜索

考虑好是否计算过的条件设置, 设置不好很容易超时

[组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)	考虑好递归的终止条件



## 练习

[不同路径](https://leetcode.cn/problems/unique-paths/)	

**1. 通项含义 / 状态表示**

通项 $f_{ij} = cntA_{ij}$

$A_{ij}$ : 从 (1, 1) 到 (i, j) 的所有走法(符合题目约束条件) 

**2. 递推式 / 状态转移**

1. **划分集合**

   1. 划分依据: 最后一步的选择

   2. 划分 $A_{ij}$

      最后一步走下: $A_{i-1j} + 走下$

      最后一步走右: $A_{ij-1} + 走右$

      $A_{ij} = \{A_{i-1j} + 走下, A_{ij-1} + 走右\}$

2. **递推式**

   $f_{ij} = cntA_{ij} = cnt\{A_{i-1j} + 走下, A_{ij-1} + 走右\} = cntA_{i-1j} + cntA_{ij-1} = f_{i-1j} + f_{ij-1}$

   $\therefore f_{ij} = f_{i-1j} + f_{ij-1}$
