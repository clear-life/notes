# 动态规划

**离散数学**

1. **集合论与图论**
2. **代数结构与组合数学**
3. **数理逻辑**

**动态规划的本质模型是图论里的拓扑图**

## 概念

1. **最优子结构**: 原问题的最优解由子问题的最优解组合而来

> $f[i] = g(f[1], \dots, f[i - 1])$

2. **重复子问题**: 很多子问题会重复求解, 动态规划只求一次

> 从小到大求解 $f[i]$ 时, $f[1], \dots, f[i - 1]$ 会重复求解 

**对比**

分治: 没有重复子问题

贪心: 有最优子结构, 没有重复子问题

$~$

**无后效性**

$f[i]$ 确定后, 求解 $f[j], j > i$ 时的 $f[j]$ 不会因为 $f[i]$ 决策的不同而改变

即, 一旦 $f[j] 只跟 $$f[i]$ 的值有关, 与如何得到 $f[i]$ 无关

$~$

## 思路

1.  **$f_{ij}$ 含义**

   1.  $A_{ij}$ 含义: **第一步到当前步**所有选择组合而成的**选法方案**
   2. 属性: $\min, \max, \DeclareMathOperator{\cnt}{cnt} \cnt$

   > $f_{ij} = \min, \max, \DeclareMathOperator{\cnt}{cnt} \cnt A_{ij}$

2. **递推式**

   枚举**最后一步**的选择, 将 $A_{ij}$ 划分为更小的集合

   $A_{ij} =  g(\{A_{xy} | xy \in ij 的子问题 \})$

   $\DeclareMathOperator{\cnt}{cnt}
   f_{ij} = \min, \max, \cnt A_{ij} = \min, \max, \cnt g(\{A_{xy} \}) = \min, \max, \cnt g(\{f_{xy}\})$

   $\therefore f_{ij} = \min, \max, \cnt g(\{f_{xy}\})$

**递推式推导**

递推式推导时一定要分好情况进行讨论

推导时, 一定要把所有的状态分好类, 无论有多简单, 都要分好情况进行讨论

**状态分类**

常见分类: 起点与其他点

> 在路径问题中, 起点的路径数常 + 1

[统计所有可行路径](https://leetcode.cn/problems/count-all-possible-routes/)	先把所有状态分类, 再对每个状态进行递归式推导

## 做题步骤

1. 画出数据分布
2. 无后效性判断
3. 状态定义(靠猜)

$~$

## 技巧

### 问题等价变换

将问题进行等价变换, 使之更容易处理

1. **正向考虑** $\iff$ **反向考虑**

2. **起点到终点** $\iff$ **终点到起点**

   > 问题要求输出起点到终点的每一步的选择, 如果反向考虑
   >
   > 由于辅助数据存储时是反向存储的, 负负得正, 于是从终点到起点考虑问题时的辅助数据是正向存储的

3. **记忆化搜索改动态规划**

   记忆化搜索的思路比较好理解, 可以先从记忆化搜索的思路入手, 考虑 dfs 函数的下列因素

   1. 参数
   2. 返回值
   3. base case
   4. 如何递归

   然后根据**状态间的依赖关系**尝试将其改为动态规划写法
   
4. **问题等价变换**

   [出界的路径数](https://leetcode.cn/problems/out-of-boundary-paths/)	将问题等价变换到少走一步到达边界的路径个数

### 维度合并

将**高维数据**一一映射到**低维数据**, 减少边界条件出错的情况

```C++
f[2to1(i, j)] = f[2to1(x, y)] ...
```

### 数组下标

数组下标一般从 1 开始, 因为初值可以设在下标为 0 的位置

> 注意如果题目给定数组的下标从 0 开始, 那么就要进行一个下标转换

$~$

### step 模型

推导递推式时, 常枚举最后一步的选择

那么这个**最后一步**的模型有哪些呢 ?

或者说, 每一步代表的模型有哪些

**1. 每件物品选或不选**

01 背包: 

step: 每个物品

选择: 物品选 或 物品不选

**2. 每个物品选几件**

多重背包:

step: 每个物品

选择: 每个物品选 0 ~ $s_i$ 件

**3. 每一步往哪走**

路径问题:

step: 每一步

选择: 往哪个方向走

**4. 两条路线每一步往哪走**

路径问题两条路径:

step: 走的步数 / 横纵坐标之和的对角线

选择: **确定两条路线分别走的方向**, 然后根据**乘法原理**乘起来

如: 路线1 能走 1 2 3 共三个方向, 路线2 能走 1 2 共两个方向

选择: {(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2)}

> (3, 2) 表示路线 1 走方向 3, 同时路线2 走方向 2

### 状态表示

猜测状态表示时, 更应该看是否满足中间过程前后状态的递推, 不应该看终止状态是否满足条件

$~$

### 初始值设置

**1. 常规情况**

求最大时常设较小的值, 求最小时常设较大的值, 求数量时常设 0

**2. 特殊要求**

例: 背包容量必须用完

如果想要最终状态 ed 一定从某个起点 st 出发的话

**max**: 其余起点设为负无穷大, 起点 st 设为正常值, 使得其余起点完全竞争不过起点 st, **因为 st 远远比其余起点大**

**min**: 其余起点设为正无穷大, 起点 st 设为正常值, 使得其余起点完全竞争不过起点 st, **因为 st  远远比其余起点小**

### 记忆化搜索(DFS) 的赋值

记忆化搜索本质上使用 DFS 来实现的, 如果在搜索过程中出现重复访问自身结点的情况, 那么对于状态的赋值必须要在计算完成后才能赋值, 不然会返回错误的结果

```C++
int dfs(int i, int j)
{
    if(f[i][j] != -1) return f[i][j];
    
    int t = 0;				// 如果提前给 f[i][j] 赋值的话, 那么如果在递归计算子问题 dfs(x, y) 时
    						// 又访问了 dfs(i, j) 那么此时 f[i][j] 的值就不是 -1 了
    						// 在代码看来, 此时的 f[i][j] 已经计算完成, 于是返回了一个错误的答案
    						// 当然, 如果递归计算子问题时不会访问原问题, 那么就不会出现这种情况
    for ij 的子问题 xy:
    	t += dfs(x, y)	
    f[i][j] = t;
    return t;
}
```



### 时间复杂度优化

**递推式的等价变形**

[下降路径最小和  II](https://leetcode.cn/problems/minimum-falling-path-sum-ii/)    对递推式找到等价的表示方式, 且该表示方式对于程序来说时间复杂度更低

[完全背包问题](https://www.acwing.com/problem/content/3/)    $f_{ij}$ 的递推式可用 $f_{ij-v_i}$ 代替部分式子, 减少了计算量 

**剪枝**

根据性质, 如果可以**提前确定状态 $f_{ij}$ 的值**, 那么就可以不根据递推式计算 $f_{ij}$ 的值, 而是直接赋值, 相当于 dfs 中的剪枝

$~$

### 空间复杂度优化

**前提**

**1. 一个一维数组**

当前行的状态**只依赖上一行的状态**, 且只依赖**上一行单向上的状态**

```C++
int f[n]
f[j] = g(f[j], f[j - 1])
```

**2. 两个一维数组**

当前行的状态**只依赖上一行的状态**

```C++
int f[2][n]
f[i & 1][j] = g(f[(i - 1) & 1][j], f[(i - 1) & 1][j - 1])
```

**初始值的变化**

注意由空间复杂度优化引起的**初始值含义的变化**

如原本只想要 `f[0][0] = 0`, 

优化后变成 `f[0] = 0` ,初始化含义就变成了 `f[i][0] = 0`, 显然不符合原意

**如何考虑空间复杂度优化引起的初始值的变化 ?**

画好数据分布图(包含初始值), 考虑空间复杂度优化后的数据分布图

### 修改源数据

在源数据的某些数据如果需要特判的话, 可以考虑直接大胆修改源数据, 方便递推计算 f 函数值

### 时间复杂度估计

约为 **状态空间大小** $\times$ **选择的个数**

如:

01 背包问题: n 个物品, 体积为 v

约为 $O(2nv) = O(nv)$ 

多重背包问题: n 个物品, 每个物品最多选 s 次, 体积为 v

约为 $O(snv)$

$~$

## 题目分类

### 线性 dp

1. 单串 

   ```C++
   f[i] = g(f[i - 1],.. f[1])
   ```

   

## 题库

[打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

将一个复杂的 dp 问题分解为两个简单的 dp 子问题, 分解角度既可以为初值的不同, 也可以为范围的不同

[完全平方数](https://leetcode-cn.com/problems/perfect-squares/)	完全背包, 注意 j 的方向

[出界的路径数](https://leetcode.cn/problems/out-of-boundary-paths/)	记忆化搜索与 dp 的转换, 初始值的不同设置, 剪枝, 分类讨论递推式

[最大得分的路径数目](https://leetcode.cn/problems/number-of-paths-with-max-score/)	两个 dp 相互影响

### 记忆化搜索

考虑好是否计算过的条件设置, 设置不好很容易超时

[组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)	考虑好递归的终止条件

[统计所有可行路径](https://leetcode.cn/problems/count-all-possible-routes/)	递推式一定要分情况讨论



## 练习

[不同路径](https://leetcode.cn/problems/unique-paths/)	

**1. 通项含义 / 状态表示**

通项 $f_{ij} = cntA_{ij}$

$A_{ij}$ : 从 (1, 1) 到 (i, j) 的所有走法(符合题目约束条件) 

**2. 递推式 / 状态转移**

1. **划分集合**

   1. 划分依据: 最后一步的选择

   2. 划分 $A_{ij}$

      最后一步走下: $A_{i-1j} + 走下$

      最后一步走右: $A_{ij-1} + 走右$

      $A_{ij} = \{A_{i-1j} + 走下, A_{ij-1} + 走右\}$

2. **递推式**

   $f_{ij} = cntA_{ij} = cnt\{A_{i-1j} + 走下, A_{ij-1} + 走右\} = cntA_{i-1j} + cntA_{ij-1} = f_{i-1j} + f_{ij-1}$

   $\therefore f_{ij} = f_{i-1j} + f_{ij-1}$

[下降路径最小和](https://leetcode.cn/problems/minimum-falling-path-sum/)	

**1. $A_{ij}$**

从第一行走到 $ij$ 的所有方案

每一步: 当前行走到下一行

每一步的选择: 当前行能走到下一行的三个位置

**2. $f_{ij}$**

$f_{ij} = \min A_{ij}$ 所有方案的最小路径和

**3. 递推式**

$f_{ij} = \min \{f_{i-1j}, f_{i-1j}, f_{i-1j+1}\} + a[i][j]$

**4. 无后效性**

$f_{ij}$ 只与子问题的值有关, 跟如何得到子问题的值无关, 满足无后效性

[统计所有可行路径](https://leetcode.cn/problems/count-all-possible-routes/)

分情况讨论练习

**1. $A_{ij}$**

从起点 st 走到 i, 汽油不超过 j 的所有路径

每一步: 当前点到下一点的走法

每一步的选择: 当前点走到与自己不同的点

**2. $f_{ij}$**

$f_{ij} = \cnt A_{ij}$ 所有路径的个数

**3. 无后效性**

$f_{ij}$ 只与上一步的路径个数有关, 与如何走到上一步的选择无关, 满足无后效性

**4. 递推式**

**状态分类**

所有状态分为两类: 终点与起点不同, 终点在起点上

即 $f_{ij}, i \neq st$ 和 $f_{ij}, i = st$

**case 1: $f_{ij}, i \neq st$**

则 $f_{ij}$ 上一步一定由不同的点转移过来, 故 $f_{ij} = \sum f_{xy}, x \neq i$ 

**case 2: $f_{ij}, i = st$**

$f_{ij}$ 上一步除了由不同的点转移过来外, 还有可能从 st 转移过来, 因为本身就在 st 上,哪都不用走就是一个方案, 还因为按照 case 1 的计算方案, 路径上相邻两个点一定是不同的, 还要加上本身就在 st 点这个方案

## 提高课

### 数字三角形模型

**从起点到某点走过路径的所有方案**

[方格取数](https://www.acwing.com/problem/content/1029/)

$A_{ki_1i_2}$ : 两条路线走同样的步数, 从 (1, 1) 和 (1, 1) 走到 (i1, k - i1) 和 (i2, k - i2) 的所有方案

step: 横纵坐标之和代表的对角线

[传纸条](https://www.acwing.com/problem/content/277/)

### 最长上升子序列(LIS)模型

**LIS : Longest Increasing Sequence**

**以某元素为结尾的所有方案**

[登山](https://www.acwing.com/problem/content/1016/)

动态规划方法预处理出每个元素左右两边的 LIS, 然后以此为基础求出结果

[友好城市](https://www.acwing.com/problem/content/description/1014/)

分析性质, 得出 LIS 模型, 然后用模板解决问题

> 由于程序中常顺序考虑问题, 考虑 n 个元素的关系太复杂
>
> 一般尝试考虑任意两个(或相邻两个元素)元素, 查找其关系 / 性质
>
> 如果两个元素的位置关系不固定, 不妨设元素间的位置关系

分析:

考虑任意两个元素 (a, b) 和 (c, d), 什么情况下满足建桥相交 ?

不妨设 $a \leq c$ , 且固定 a 和 c 的位置

> 即位置关系由第一个元素确定

由于 b 和 d 都不固定, 可以先固定一个位置

**固定 b**

画图可知, $d > b$ 时不相交, $d \leq b$ 时相交

固定 d 时, 同理可得相同的结论

特殊情况: a 和 c 相等时, 也能得到相同的结论

> 复杂问题简单考虑
> n 个元素的关系, 简化成任意两个元素的关系
> 任意两个元素的关系, 简化成前后任意两个元素的关系
> 元素的分量间的关系, 简化成固定一个元素, 另一个元素变化

**得到性质:**

$a \leq c$ 时, $b < d$ 时不相交, $b \geq d$ 时相交

贪心性质: 只要最后一个桥(最后一个选中元素)与当前元素不相交, 那么当前元素与之前选中的元素都不相交

**于是, LIS 模型抽出:** 在对元素 (a, b) sort 的情况下, 元素的第二个分量满足 LIS 模型 
