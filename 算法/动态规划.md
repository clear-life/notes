# 动态规划

## 概念

1. **最优子结构**: 原问题的最优解由子问题的最优解组合而来

> $f[i] = g(f[1], \dots, f[i - 1])$

2. **重复子问题**: 很多子问题会重复求解, 动态规划只求一次

> 从小到大求解 $f[i]$ 时, $f[1], \dots, f[i - 1]$ 会重复求解 

**对比**

分治: 没有重复子问题

贪心: 有最优子结构, 没有重复子问题

$~$

**无后效性**

$f[i]$ 确定后, 求解 $f[j], j > i$ 时的 $f[j]$ 不会因为 $f[i]$ 决策的不同而改变

即, 一旦 $f[j] 只跟 $$f[i]$ 的值有关, 与如何得到 $f[i]$ 无关

$~$

## 思路

1.  **$f_{ij}$ 含义**

   1.  $A_{ij}$ 含义: **第一步到当前步**所有选择组合而成的**选法方案**
   2. 属性: $\min, \max, \DeclareMathOperator{\cnt}{cnt} \cnt$

   > $f_{ij} = \min, \max, \DeclareMathOperator{\cnt}{cnt} \cnt A_{ij}$

2. **递推式**

   枚举最后一步选择, 将 $A_{ij}$ 划分为更小的集合

   $A_{ij} =  g(\{A_{xy} | xy \in ij 的子问题 \})$

   $\DeclareMathOperator{\cnt}{cnt}
   f_{ij} = \min, \max, \cnt A_{ij} = \min, \max, \cnt g(\{A_{xy} \}) = \min, \max, \cnt g(\{f_{xy}\})$

   $\therefore f_{ij} = \min, \max, \cnt g(\{f_{xy}\})$

**递推式推导**

递推式推导时一定要分好情况进行讨论

推导时, 一定要把所有的状态分好类, 无论有多简单, 都要分好情况进行讨论

## 做题步骤

1. 画出数据分布
2. 无后效性判断
3. 状态定义(靠猜)

$~$

## 技巧

### 问题等价变换

将问题进行等价变换, 使之更容易处理

1. **正向考虑** $\iff$ **反向考虑**

2. **起点到终点** $\iff$ **终点到起点**

   > 问题要求输出起点到终点的每一步的选择, 如果反向考虑
   >
   > 由于辅助数据存储时是反向存储的, 负负得正, 于是从终点到起点考虑问题时的辅助数据是正向存储的

### 维度合并

将**高维数据**一一映射到**低维数据**, 减少边界条件出错的情况

```C++
f[2to1(i, j)] = f[2to1(x, y)] ...
```

### 数组下标

数组下标一般从 1 开始, 因为初值可以设在下标为 0 的位置

> 注意如果题目给定数组的下标从 0 开始, 那么就要进行一个下标转换

### 时间复杂度优化

**递推式的等价变形**

[下降路径最小和  II](https://leetcode.cn/problems/minimum-falling-path-sum-ii/)    对递推式找到等价的表示方式, 且该表示方式对于程序来说时间复杂度更低

[完全背包问题](https://www.acwing.com/problem/content/3/)    $f_{ij}$ 的递推式可用 $f_{ij-v_i}$ 代替部分式子, 减少了计算量 

$~$

### 空间复杂度优化

**前提**

**1. 一个一维数组**

当前行的状态**只依赖上一行的状态**, 且只依赖**上一行单向上的状态**

```C++
int f[n]
f[j] = g(f[j], f[j - 1])
```

**2. 两个一维数组**

当前行的状态**只依赖上一行的状态**

```C++
int f[2][n]
f[i & 1][j] = g(f[(i - 1) & 1][j], f[(i - 1) & 1][j - 1])
```

**初始值的变化**

注意由空间复杂度优化引起的**初始值含义的变化**

如原本只想要 `f[0][0] = 0`, 

优化后变成 `f[0] = 0` ,初始化含义就变成了 `f[i][0] = 0`, 显然不符合原意

**如何考虑空间复杂度优化引起的初始值的变化 ?**

画好数据分布图(包含初始值), 考虑空间复杂度优化后的数据分布图

### 时间复杂度估计

约为 **状态空间大小** $\times$ **选择的个数**

如:

01 背包问题: n 个物品, 体积为 v

约为 $O(2nv) = O(nv)$ 

多重背包问题: n 个物品, 每个物品最多选 s 次, 体积为 v

约为 $O(snv)$

$~$

## 题目分类

### 线性 dp

1. 单串 

   ```C++
   f[i] = g(f[i - 1],.. f[1])
   ```

   

## 题库

[打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

将一个复杂的 dp 问题分解为两个简单的 dp 子问题, 分解角度既可以为初值的不同, 也可以为范围的不同

[完全平方数](https://leetcode-cn.com/problems/perfect-squares/)	完全背包, 注意 j 的方向



### 记忆化搜索

考虑好是否计算过的条件设置, 设置不好很容易超时

[组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)	考虑好递归的终止条件



## 练习

[不同路径](https://leetcode.cn/problems/unique-paths/)	

**1. 通项含义 / 状态表示**

通项 $f_{ij} = cntA_{ij}$

$A_{ij}$ : 从 (1, 1) 到 (i, j) 的所有走法(符合题目约束条件) 

**2. 递推式 / 状态转移**

1. **划分集合**

   1. 划分依据: 最后一步的选择

   2. 划分 $A_{ij}$

      最后一步走下: $A_{i-1j} + 走下$

      最后一步走右: $A_{ij-1} + 走右$

      $A_{ij} = \{A_{i-1j} + 走下, A_{ij-1} + 走右\}$

2. **递推式**

   $f_{ij} = cntA_{ij} = cnt\{A_{i-1j} + 走下, A_{ij-1} + 走右\} = cntA_{i-1j} + cntA_{ij-1} = f_{i-1j} + f_{ij-1}$

   $\therefore f_{ij} = f_{i-1j} + f_{ij-1}$

[下降路径最小和](https://leetcode.cn/problems/minimum-falling-path-sum/)	

**1. $A_{ij}$**

从第一行走到 $ij$ 的所有方案

每一步: 当前行走到下一行

每一步的选择: 当前行能走到下一行的三个位置

**2. $f_{ij}$**

$f_{ij} = \min A_{ij}$ 所有方案的最小路径和

**3. 递推式**

$f_{ij} = \min \{f_{i-1j}, f_{i-1j}, f_{i-1j+1}\} + a[i][j]$

**3. 无后效性**

$f_{ij}$ 只与子问题的值有关, 跟如何得到子问题的值无关, 满足无后效性
