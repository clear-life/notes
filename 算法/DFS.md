# DFS

用 dp 的思想来考虑递归

**树形 dp**

自底向上: 用子树信息组合出父节点信息

自顶向下: 子树信息由父结点信息得出, 父结点向子节点传递信息

## 思路(伪代码)

和一般的 bfs 一样, dfs 也是出队时访问

```C++
void dfs(int u)
{
    visit(u)	// 相当于出队
        
    for v  in  u 的邻接点
        if v 未遍历过
            dfs(v)	// 相当于入队
        else
            做出相应操作
}
```

希望遍历每个点的所有邻接点时用, 无论邻接点是否遍历过

```C++
type dfs(int u)
{
    if u 遍历过 
        return 相应的值
        
    visit(u)	// 相当于出队
        
    for v  in  u 的邻接点
        dfs(v)	// 相当于入队
}
```

显示用栈实现 DFS

```C++
stk.push(root)
while(stk.size())
{
    auto u = stk.top(); stk.pop();
    visit(u);
    st[u] = true;
    
    for v  in  u 的邻接点	// 跟递归实现的方式要反着来(如果考虑顺序的话, 如果不考虑就无所谓)
        if v 未遍历过
            stk.push(v)
        else
            ...
}
```

### 回溯

出队时访问

```C++
dfs(int u)
{
    st[u] = true;
    visit(u)
        
   	for v  in  u 的邻接点	// 跟递归实现的方式要反着来(如果考虑顺序的话, 如果不考虑就无所谓)
        if v 未遍历过
            dfs(v)
        else
            ...
            
    st[u] = false;
}
```

**递归终止条件**: **遍历完所有结点**, 有时候**递归到空结点**等价于该终止条件

[二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)	

**自底向上递归**

先递归子节点, 根据子节点的结果组合出要返回的值, 然后返回结果

类似于后序遍历

```C++
int dfs(TreeNode* node)
{
    if(!node) return 0;		// 递归的终止情况

    int l = dfs(node->left), r = dfs(node->right);	// 类比后序遍历的左右子树
    return max(l, r) + 1;	// 类比访问当前结点
}

dfs(root);
```

**自顶向下递归**

该结点的信息已知, 递归子结点, 并**向子节点传递信息**

类似于先序遍历

```C++
void dfs(TreeNode* node, int d)
{
    if(!node->left && !node->right)	// 递归的终止情况: 该结点是叶节点
        res = max(res, d);

    if(node->left) dfs(node->left, d + 1);
    if(node->right) dfs(node->right, d + 1);
}
```

**后序遍历与 dp**

自顶向下的 dp 思想: 假定子问题的解得到了, 然后由子问题的解组合出原问题的解

后序遍历视角下的 dp : 先递归得到所有子树的解, 然后遍历根节点得到整棵树的解

## 分类

dfs 题目, 或者说**树与图**相关的题目, 都可以划分为这几类

**分类依据: 是否需要遍历全图**

1. **可行解**

   在图中只需要找到**一个满足要求的结点**就可以结束了

   此类问题常需要**设置 dfs 函数的返回值为 bool 类型, 表明是否找到解**

   ```C++
   bool dfs(int u)
   {
       if(u == target) return true;
       
       for v in adj[u]
           if(dfs(v)) return true;
       
      	return false;
   }
   ```

2. **最优解**或**所有解**

   在图中需要**遍历完所有的结点**才能确定**最优解**和**所有满足条件的解**

   因此此类问题**不需要设置 dfs 函数的返回值**

   ```C++
   void dfs(int u)
   {
       if(u 满足条件)
       {
           最优解: 更新最优解
           所有解: 添加 u 到结果里
           return;
   	}
       for v in adj[u]
           dfs(v)
   }
   ```

**分类依据: 为排列或组合方式枚举**

1. **排列**

   排列方式枚举元素, 元素之前有顺序关系

   > 默认为不重复枚举, 即每个元素只使用一次

   ```C++
   bool st[N]
   int path[N]
   void dfs(int u)
   {
       if(u == n) return;
      
       for(int i = 1; i <= n; i++)
           if(!st[i])
           {
               st[i] = true;
               path[u] = i;
               dfs(u + 1);
               st[i] = false;
           }
   }
   
   dfs(0)
   ```

2. **组合**

   组合方式枚举元素, 元素之间不考虑顺序

   > 默认为不重复枚举, 即每个元素只使用一次

   ```C++
   int path[N]
       
   void dfs(int u, int start)
   {
       if(u == n) return;
       
       for(int i = start; i <= n; i++)
       {
   		path[u] = i;
           dfs(u + 1, i + 1);
       }
   }
   ```

   

## 应用

**二分图**

等价判定条件:

1. 二分图
2. 二染色
3. 不存在奇数环

染色法判断二分图

## 题库

[对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)	逻辑判断递归

[路径总和](https://leetcode-cn.com/problems/path-sum/)	dfs bfs, 自定向下

[克隆图](https://leetcode-cn.com/problems/clone-graph/)	dfs 重复判断可以在访问时判断, 模板增加重复点的处理逻辑

[二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)	dfs 可以返回子树的状态, 返回值用状态码表示

[二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)	重要, dfs 序列化与 dfs 反序列化

[太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/)	flood fill 算法

[找到最终的安全状态](https://leetcode.cn/problems/find-eventual-safe-states/)	判断有向图的每个结点是否有回路, dfs  判断环

[课程表 II](https://leetcode.cn/problems/course-schedule-ii/)	dfs 实现 拓朴排序, 还需要判断环

> 1. 结点有回路: 从该结点出发的所有路径中 [存在回路 / 存在一条路径没有终点]
>
> 2. 结点没有回路: 从该节点出发的所有路径 [都没有回路 / 终点都是出度为 0 的点]
>
> 证: 
>
> 假定从某点出发的所有路径都没有回路, 却存在一条路径没有终点
>
> 那么选定一个点 u, 其出度不为 0, 任选一个点邻边 v, 继续走下去, 同样操作 v
>
> 设图的结点数为 n, 操作 n + 1 次后, 由抽屉原理, 一定存在两个点相等, 于是存在回路, 产生矛盾
>
> 所以结点没有回路等价于终点都是出度为 0 的点

$~$

## 算法提高课

**点的模型**

1. **具体的点**

   如迷宫中的点, 二维点, 三维点....

2. **抽象的点**

   抽象的一个状态

**恢复现场**

是否恢复现场跟问题的模型无关, 跟具体的实现手段有关

如果实现手段需要我们来维护结点的状态(通常表现形式为结点用全局变量表示), 那么就需要恢复现场

如果实现手段不需要我们来维护结点的状态(通常表现形式为结点用局部变量传参表示), 那么就不需要恢复现场

$~$

**剪枝优化**

剪枝方法:

> 优化搜索顺序 与 排除等价情况 的区别
>
> 相同点: 
>
> 减少总搜索空间的大小
>
> 都是在所有等价总搜索空间中选择最小的那个
>
> 不同点: 
>
> 优化搜索顺序是在搜到某个具体子树时, 选择等价搜索子树中最小的那个来搜索
>
> 主要是思路是**一大一小选小的**
>
> 排除等价情况是设置一个方法, 然后使得整个搜索空间中所有等价情况只搜索一次
>
> 主要思路是**二者等价只搜一次**

**1. 优化搜索顺序**

优先搜索结点少的分支

> 搜索树(子树)有多个等价搜索空间情况下, 优先选择搜索空间小的搜索树(子树)来搜索
>
> 例: 
>
> 目的: 检查是否有假钱, 对 50 块钱的两种等价情况: 
>
> 1.  一张 50 面额的纸币
> 2. 两张 20 面额的纸币, 一张 10 面额的纸币
>
> 第一种搜索树的明显更简单, 操作更少, 只需要检查一张纸币
>
> 第二种搜索树的结点更多, 操作更多, 最多需要检查三张纸币
>
> 所以优先选择第一种搜索树会减少总搜索空间的大小

**2. 排除等价情况**

等价情况要设置一个方法, 使得只会搜索一次等价情况

> 等价情况是指在总的搜索空间中, 存在某两个搜索子树是等价的, 
>
> 此时就需要把所有的等价情况归为一类, 对等价情况只搜索一次, 就能减少总的搜索空间大小

**3. 可行性剪枝**

提前发现不可行就剪枝

**4. 最优性剪枝**

提前发现不最优就剪枝

**5. 记忆化搜索(DP)**

**口诀总结**

**一大一小选小的, 二者等价只搜一次, 提前不可行不最优就止损**

$~$

**迭代加深**

每次**在划定的范围内寻找解**, 如果找到了就返回, 没找到就增大划定的范围继续找(之前找过的会再找一遍)

适用于**树的层数很深但解的层数不深**的情况

```C++
int max_depth = 1;
while(!dfs(0, max_depth)) max_depth++;
  
bool dfs(int k, int max_depth)
{
    if(k > max_depth) return false;	// 超出规定范围就返回 false
    if(k == max_depth)	// 终止情况
    {
        ...
    }
    
    ...
}
```

$~$

**双向 DFS**

并不是真正的双向嗅探, 而是单独 dfs 一半的路径, 记录好所有路径的结果, 然后用别的算法来找到最终的解

**思想**: 用空间换时间, 两次 dfs 一般的路径, 然后记录下结果, 然后只需要查表就行

**时间复杂度:**

单向 DFS:

设起点到重点的**路径长度为 N**, **分叉数为 k**

则最后一层的结点数为 $k^N$, 总的时间复杂度为 $O(\frac{k^{N + 1} - 1}{k - 1}) \approx O(k^N)$

双向 DFS:

两次单独 DFS 的路径为 $\frac{N}{2}$, 时间复杂度约为 $O(k^{\frac{N}{2}})$

用其余算法的时间复杂度再对 $O(k^{\frac{N}{2}})$ 进行计算才是最终的时间复杂度

$~$

**IDA***

在迭代加深的基础上, 预估结点是否会超出上限 `max_depth`

如果无论如何都一定超出上限 `max_depth` 就提前剪枝

**估价函数:** 当前点到终点的估计距离

要求: 估价函数 $\leq$ 真实值

> max_depth 给定
>
> 当前点 u, 终点 d
>
> u 到起点的距离为 v
>
> u 到 d 的真实距离为 $k$, $k'$ 为 u 到 d 的估计距离
>
> 任意情况下, $k' \leq k$
>
> 若 $v + k' \geq {max\_depth}$, 则可以提前剪枝了
