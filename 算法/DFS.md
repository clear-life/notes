# DFS

用 dp 的思想来考虑递归

**树形 dp**

自底向上: 用子树信息组合出父节点信息

自顶向下: 子树信息由父结点信息得出, 父结点向子节点传递信息

## 思路(伪代码)

和一般的 bfs 一样, dfs 也是出队时访问

```C++
void dfs(int u)
{
    visit(u)	// 相当于出队
        
    for v  in  u 的邻接点
        if v 未遍历过
            dfs(v)	// 相当于入队
        else
            做出相应操作
}
```

希望遍历每个点的所有邻接点时用, 无论邻接点是否遍历过

```C++
type dfs(int u)
{
    if u 遍历过 
        return 相应的值
        
    visit(u)	// 相当于出队
        
    for v  in  u 的邻接点
        dfs(v)	// 相当于入队
}
```

显示用栈实现 DFS

```C++
stk.push(root)
while(stk.size())
{
    auto u = stk.top(); stk.pop();
    visit(u);
    st[u] = true;
    
    for v  in  u 的邻接点	// 跟递归实现的方式要反着来(如果考虑顺序的话, 如果不考虑就无所谓)
        if v 未遍历过
            stk.push(v)
        else
            ...
}
```

### 回溯

出队时访问

```C++
dfs(int u)
{
    st[u] = true;
    visit(u)
        
   	for v  in  u 的邻接点	// 跟递归实现的方式要反着来(如果考虑顺序的话, 如果不考虑就无所谓)
        if v 未遍历过
            dfs(v)
        else
            ...
            
    st[u] = false;
}
```

**递归终止条件**: **遍历完所有结点**, 有时候**递归到空结点**等价于该终止条件

[二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)	

**自底向上递归**

先递归子节点, 根据子节点的结果组合出要返回的值, 然后返回结果

类似于后序遍历

```C++
int dfs(TreeNode* node)
{
    if(!node) return 0;		// 递归的终止情况

    int l = dfs(node->left), r = dfs(node->right);	// 类比后序遍历的左右子树
    return max(l, r) + 1;	// 类比访问当前结点
}

dfs(root);
```

**自顶向下递归**

该结点的信息已知, 递归子结点, 并**向子节点传递信息**

类似于先序遍历

```C++
void dfs(TreeNode* node, int d)
{
    if(!node->left && !node->right)	// 递归的终止情况: 该结点是叶节点
        res = max(res, d);

    if(node->left) dfs(node->left, d + 1);
    if(node->right) dfs(node->right, d + 1);
}
```

**后序遍历与 dp**

自顶向下的 dp 思想: 假定子问题的解得到了, 然后由子问题的解组合出原问题的解

后序遍历视角下的 dp : 先递归得到所有子树的解, 然后遍历根节点得到整棵树的解

## 分类

dfs 题目, 或者说**树与图**相关的题目, 都可以划分为这几类

### 分类依据: 是否需要遍历全图

1. **可行解**

   在图中只需要找到**一个满足要求的结点**就可以结束了

   此类问题常需要**设置 dfs 函数的返回值为 bool 类型, 表明是否找到解**

   ```C++
   bool dfs(int u)
   {
       if(u == target) return true;
       
       for v in adj[u]
           if(dfs(v)) return true;
       
      	return false;
   }
   ```

2. **最优解**或**所有解**

   在图中需要**遍历完所有的结点**才能确定**最优解**和**所有满足条件的解**

   因此此类问题**不需要设置 dfs 函数的返回值**

   ```C++
   void dfs(int u)
   {
       if(u 满足条件)
       {
           最优解: 更新最优解
           所有解: 添加 u 到结果里
           return;
   	}
       for v in adj[u]
           dfs(v)
   }
   ```

### 分类依据: 排列或组合方式枚举

1. **排列**

   排列方式枚举元素, 元素之前有顺序关系

   > 默认为不重复枚举, 即每个元素只使用一次

   ```C++
   bool st[N]
   int path[N]
   void dfs(int u)
   {
       if(u == n) return;
      
       for(int i = 1; i <= n; i++)
           if(!st[i])
           {
               st[i] = true;
               path[u] = i;
               dfs(u + 1);
               st[i] = false;
           }
   }
   
   dfs(0)
   ```

2. **组合**

   组合方式枚举元素, 元素之间不考虑顺序

   > 默认为不重复枚举, 即每个元素只使用一次

   ```C++
   int path[N]
       
   void dfs(int u, int start)
   {
       if(u == n) return;
       
       for(int i = start; i <= n; i++)
       {
   		path[u] = i;
           dfs(u + 1, i + 1);
       }
   }
   ```

### 模型分类

**枚举位置和元素的放置关系**

[小猫爬山](https://www.acwing.com/problem/content/167/)

```C++
// 对位置枚举元素
void dfs(位置)
{
    for 元素 in 元素集合
        ...
}

// 对元素枚举位置
void dfs(元素)
{
    for 位置 in 所有位置
        ...
}
```





## DFS 函数设计

### 返回值设计

DFS 函数的返回值由**两个因素共同决定**: **是否搜索全局** 和 **需要返回的信息**

**1. 是否搜索全局**

是否搜索全局含义: 是否需要搜索整个图的所有结点

res 分两种类型: **最优解**  和  **可行解**

最优解需要搜索整个图, **必须对比完所有可行的解才能得到最优解**

可行解不需要搜索整个图, 只要找到满足条件的解就行

```C++
最优解对返回值的影响: void dfs()
可行解对返回值的影响: bool dfs() 表明是否找到解
```

**2. 需要返回的信息**

有时候需要得到递归底层的一些信息

这些信息如果是固定不变的, 是递归底层固有的信息, 那么可以通过返回值来传递

根据返回信息的不同, 对 DFS 函数返回值的影响不同

```C++
DFS 返回值的类型通常和返回信息类型一致, 但要设计好跟因素 1 影响的共存
例:
返回一个 int, 表示某种值
int dfs()

返回一个 bitset, 表示某种状态码 (状态数少的话可以用 int)
bitset<N> dfs()
    
返回一个 vector, 表示序列信息
vector<int> dfs()
    
当然, 也有可能不需要返回信息
```

**两种影响因素共同作用**

```C++
case 1:
	某一种影响因素不需要返回的话, 就以另一种影响因素为主
case 2:
	两种影响因素都都需要返回
    就要设计返回值的一部分表示 true 的同时表示返回信息, 另一部分 表示 false 的同时表示返回信息(当然也可以不表示返回信息, 只表示 false)
    例:
		返回信息是正整数, 同时需要返回 bool 类型
        则返回类型为 int, 0 表示 false, 非 0 表示 true 的同时表示返回信息
```

$~$

### 参数设计

DFS 参数分为三类: **结点状态信息**, **辅助信息** 和 **结果信息**

**1. 结点状态信息**

**类型**

结点状态信息根据变量类型分为两类: **局部变量和全局变量**

**局部变量**是**系统栈**帮助我们维护结点状态

**全局变量**需要我们**手动维护结点状态**, 也就是常说的**恢复现场**

**内容**

**结点状态信息**通常把**结点状态分解为各个变量**来表示其**不同部分的含义**

```C++
例:
group 表示当前组号, idx 表示枚举所要填入的下标 / 当前考虑的下标
total 表示已经确定的元素个数, bool 数组表示每个元素是否确定过
path 表示已经遍历过的路径信息, cnt 表示剩余待考虑的个数, 
u 表示当前结点的编号, start 表示从 start 到结尾考虑元素, 并且保证组合式枚举
....
```

**2. 辅助信息**

**辅助信息也分为两种: 全局变量和局部变量**

全局变量通常为固定的信息, 如原数据

**局部变量通常跟状态有关, 其实本质就是结点状态信息** 但常常看起来不像是结点状态信息

```C++
例:
start 表示从 [start, n] 中枚举元素, 功能除了有剪枝的作用
更重要的是可以保证组合式枚举
即后面枚举的元素的下标一定比前面大
```

**3. 结果信息**

结果信息通常与返回信息不同, 指的是**解(最优解或可行解)**, **常为全局变量**

```C++
例:
最常见的就是 res
有时也是一个 vector
```

**结果信息的赋值**

如果**结果信息**含有**第一次**因素, 那么就要考虑好**赋值后是否会被覆盖**的情况

设计好赋值条件, 保证结果信息是**第一次遇到的解**

```C++
例:
type res = null
   
bool dfs()
{
    ...
       
    if(...)		// 是否找到解
    {
        if(!res)	// 是否是第一次遇见
            res = ...
        return true;
    }
    ...
}
```

$~$

### 逻辑设计

DFS 的模型常可以抽象为**向位置放入元素**

**线性模型**

对象有两个: **位置  和  元素**

线性模型指位置是线性的

根据**枚举的方向**分为两种 DFS 逻辑: **每个位置应该放哪个元素**, **每个元素应该放到哪个位置**

> 两种情况的结点状态信息本质上是一样的, 区别在于明显的表示内容, 即**实际的 dfs 参数**

**1. 对位置枚举元素**

**结点状态**明显表示为**位置信息**

> 每个位置应该放哪个元素

```C++
void dfs(int group, int idx, ...)	// group 组 idx 位置应该放哪个元素 
{
    ...
        
    for x in 元素的集合
        ...
}
```

**2. 对元素枚举位置**

**结点状态**明显表示为**元素信息**

> 每个元素应该放到哪个位置

```C++
void dfs(int u)		// 元素 u 应该放到哪个位置
{
    ...
        
    for idx in 位置下标的集合
        ...
}
```



## 应用

**二分图**

等价判定条件:

1. 二分图
2. 二染色
3. 不存在奇数环

染色法判断二分图

## 相关技巧

**去重枚举出的重复情况**

**排列枚举去重**

```C++
bool st[N];
int arr[N];
sort(arr, arr + n);		// 需要对需要枚举的集合排好序

void dfs(int k)
{
    if(k == n) return;
    
    for(int i = 0; i < n; i++)
        // 第一种去重方式: 相等元素在一个位置只枚举一次, 后面的相等元素跳过去, 跳到下一个与当前已枚举元素不相等的元素
        if(!st[i])
        {
            st[i] = true;
            dfs(k + 1);
            st[i] = false;
            
            // 当一个元素枚举到位置 k 后, 跳过后面的相等元素可以去重
            int j = i + 1;
            while(j < n && s[j] == s[i]) j++;
            i = j - 1;
		}
    
    	// 第二种去重方式: 给相等元素间规定好次序, 每次枚举都枚举第一个未使用的元素
    	// 如果上一个元素与当前元素相等, 且上一个元素未使用, 则当前元素不能被使用
    	if(!st[i])
        {
            // 如果 i 不是第一个元素, 且当前元素与上一元素相等, 且上一元素未使用, 则不枚举当前元素
            if(i && s[i] == s[i - 1] && !st[i - 1]) continue;
        	st[i] = true;
            dfs(k + 1);
            st[i] = false;
        }
}


```

**组合枚举去重**

```C++
// 思路 1 : 相等元素规定好次序, 如果上一相同元素未使用, 就不枚举当前的相同元素了
void dfs(int k)
{
    if(k == n) return;
    
    dfs(k + 1);
    
    if(k && arr[k] == arr[k - 1] && !st[k - 1]) return;
    
    st[k] = true;
    dfs(k + 1);
    st[k] = false;
}

// 思路 2 : 枚举每个元素的次数, 这样就没有重复问题了
void dfs(int k)
{
    if(k == n) return;
    
    // cnt 是第 k 个元素的次数
    for(int i = 0; i <= cnt; i++)
    {
        dfs(j);		// j 是下一个不同元素
        path.push_back(k);
    }
    
    // 恢复现场
    for(int i = 0; i <= cnt; i++)
    {
        dfs(j);		// j 是下一个不同元素
        path.push_back(k);
    }
}
```



## 题库

[对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)	逻辑判断递归

[路径总和](https://leetcode-cn.com/problems/path-sum/)	dfs bfs, 自定向下

[克隆图](https://leetcode-cn.com/problems/clone-graph/)	dfs 重复判断可以在访问时判断, 模板增加重复点的处理逻辑 / dfs 的深入理解

[二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)	dfs 可以返回子树的状态, 返回值用状态码表示

[二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)	重要, dfs 序列化与 dfs 反序列化

[太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/)	flood fill 算法, 位运算表示状态

[找到最终的安全状态](https://leetcode.cn/problems/find-eventual-safe-states/)	判断有向图的每个结点是否有回路, dfs  判断环

[课程表 II](https://leetcode.cn/problems/course-schedule-ii/)	dfs 实现 拓朴排序, 还需要判断环

[全排列 II](https://leetcode.cn/problems/permutations-ii/)	不重复枚举, 枚举了某个元素后, 跳过后面所有的相同元素

[组合总和](https://leetcode.cn/problems/combination-sum/)	组合枚举, 不考虑顺序

[子集 II](https://leetcode.cn/problems/subsets-ii/)	有重复元素的幂集

[活字印刷](https://leetcode.cn/problems/letter-tile-possibilities/)	排列式枚举去重

[边界着色](https://leetcode.cn/problems/coloring-a-border/)	连通分量边界问题

> 1. 结点有回路: 从该结点出发的所有路径中 [存在回路 / 存在一条路径没有终点]
>
> 2. 结点没有回路: 从该节点出发的所有路径 [都没有回路 / 终点都是出度为 0 的点]
>
> 证: 
>
> 假定从某点出发的所有路径都没有回路, 却存在一条路径没有终点
>
> 那么选定一个点 u, 其出度不为 0, 任选一个点邻边 v, 继续走下去, 同样操作 v
>
> 设图的结点数为 n, 操作 n + 1 次后, 由抽屉原理, 一定存在两个点相等, 于是存在回路, 产生矛盾
>
> 所以结点没有回路等价于终点都是出度为 0 的点

$~$

## 算法提高课

**点的模型**

1. **具体的点**

   如迷宫中的点, 二维点, 三维点....

2. **抽象的点**

   抽象的一个状态

**恢复现场**

是否恢复现场跟问题的模型无关, 跟具体的实现手段有关

如果实现手段需要我们来维护结点的状态(通常表现形式为结点用全局变量表示), 那么就需要恢复现场

如果实现手段不需要我们来维护结点的状态(通常表现形式为结点用局部变量传参表示), 那么就不需要恢复现场

$~$

**剪枝优化**

剪枝方法:

> 优化搜索顺序 与 排除等价情况 的区别
>
> 相同点: 
>
> 减少总搜索空间的大小
>
> 都是在所有等价总搜索空间中选择最小的那个
>
> 不同点: 
>
> 优化搜索顺序是在搜到某个具体子树时, 选择等价搜索子树中最小的那个来搜索
>
> 主要是思路是**一大一小选小的**
>
> 排除等价情况是设置一个方法, 然后使得整个搜索空间中所有等价情况只搜索一次
>
> 主要思路是**二者等价只搜一次**

**1. 优化搜索顺序**

优先搜索结点少的分支

> 搜索树(子树)有多个等价搜索空间情况下, 优先选择搜索空间小的搜索树(子树)来搜索
>
> 例: 
>
> 目的: 检查是否有假钱, 对 50 块钱的两种等价情况: 
>
> 1.  一张 50 面额的纸币
> 2. 两张 20 面额的纸币, 一张 10 面额的纸币
>
> 第一种搜索树的明显更简单, 操作更少, 只需要检查一张纸币
>
> 第二种搜索树的结点更多, 操作更多, 最多需要检查三张纸币
>
> 所以优先选择第一种搜索树会减少总搜索空间的大小

**2. 排除等价情况**

等价情况要设置一个方法, 使得只会搜索一次等价情况

> 等价情况是指在总的搜索空间中, 存在某两个搜索子树是等价的, 
>
> 此时就需要把所有的等价情况归为一类, 对等价情况只搜索一次, 就能减少总的搜索空间大小

**3. 可行性剪枝**

提前发现不可行就剪枝

**4. 最优性剪枝**

提前发现不最优就剪枝

**5. 记忆化搜索(DP)**

**口诀总结**

**一大一小选小的, 二者等价只搜一次, 提前不可行不最优就止损**

$~$

**迭代加深**

每次**在划定的范围内寻找解**, 如果找到了就返回, 没找到就增大划定的范围继续找(之前找过的会再找一遍)

适用于**树的层数很深但解的层数不深**的情况

```C++
int max_depth = 1;
while(!dfs(0, max_depth)) max_depth++;
  
bool dfs(int k, int max_depth)
{
    if(k > max_depth) return false;	// 超出规定范围就返回 false
    if(k == max_depth)	// 终止情况
    {
        ...
    }
    
    ...
}
```

$~$

**双向 DFS**

并不是真正的双向嗅探, 而是单独 dfs 一半的路径, 记录好所有路径的结果, 然后用别的算法来找到最终的解

**思想**: 用空间换时间, 两次 dfs 一般的路径, 然后记录下结果, 然后只需要查表就行

**时间复杂度:**

单向 DFS:

设起点到重点的**路径长度为 N**, **分叉数为 k**

则最后一层的结点数为 $k^N$, 总的时间复杂度为 $O(\frac{k^{N + 1} - 1}{k - 1}) \approx O(k^N)$

双向 DFS:

两次单独 DFS 的路径为 $\frac{N}{2}$, 时间复杂度约为 $O(k^{\frac{N}{2}})$

用其余算法的时间复杂度再对 $O(k^{\frac{N}{2}})$ 进行计算才是最终的时间复杂度

$~$

**IDA***

在迭代加深的基础上, 预估结点是否会超出上限 `max_depth`

如果无论如何都一定超出上限 `max_depth` 就提前剪枝

**估价函数:** 当前点到终点的估计距离

要求: 估价函数 $\leq$ 真实值

> max_depth 给定
>
> 当前点 u, 终点 d
>
> u 到起点的距离为 v
>
> u 到 d 的真实距离为 $k$, $k'$ 为 u 到 d 的估计距离
>
> 任意情况下, $k' \leq k$
>
> 若 $v + k' \geq {max\_depth}$, 则可以提前剪枝了
