# 前缀和与差分

## 前缀和

### 模板

```C++
int a[N], s[N];		// a 的下标从 1 开始
s[0] = 0;

for(int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];
```

### 数据结构维护前缀和相关指标

**hashmap**

**1. 前缀和的下标**

```C++
int a[N], s[N];

unordered_map<int, int> hash;
hash[0] = 0;
for(int i = 1; i <= n; i++)
    hash[s[i]] = i;		// 相同前缀和的最大下标

for(int i = 1; i <= n; i++)
    if(!hash.count(s[i])
       hash[s[i]] = i;	// 相同前缀和的最小下标
```

**2. 前缀和的次数**

```C++
int a[N], s[N];

unordered_map<int, int> hash;
hash[0]++;
for(int i = 1; i <= n; i++)
{
    ...
    hash[s[i]]++;
}
```



### 定义前缀和的含义

$s_i$ : 区间 $[1,i]$ 的某个指标

前缀和含义只要满足 

$[l, r] 的指标 = s[r] - s[l - 1]$ 等式即可

**前缀和含义整理**

**1. 区间的和**

$s_i$: $[1,i]$ 的所有数之和

> 证:
>
> $s_r$ = $a_1 + a_2 + \dots + a_i$
>
> $s_{l - 1} = a_1 + a_2 + \dots + a_{l-1}$
>
> 则 $[l, r]$ 区间内的数之和 = $a_l + a_{l + 1} + \dots + a_r = s_r - s_{l-1}$ 

**2. 区间内元素个数**

$s_i$: $[1,i]$ 满足条件的数的个数

> 注意条件是不变化的, 不因区间位置变化而变化
>
> 证:
>
> $s_r$ = $[1,r]$ 内某指标的个数
>
> $s_{l-1}$ = $[1,l-1]$ 内某指标的个数
>
> 则 $[l, r]$ 内指标个数 $ = s_r - s_{l-1}$ 

**3. 区间内的差**

$s_i$: $[1,i]$ 某两个指标的差

> 两个指标的判定条件也是各自统一的, 不因区间位置变化而变化
>
> 证:
>
> 令两个指标为 a, b, ai 表示 $[1,i]$ 内 a 的个数, bi 同理
>
> $s_r = a_r - b_r$  
>
> $s_{l-1} = a_{l-1} - b_{l-1}$ 
>
> 则 $[l, r]$ 内指标个数 = $(a_r - a_{l-1}) - (b_r - b_{l-1}) = (a_r - b_r) - (a_{l-1} - b_{l-1}) = s_r - s_{l-1}$

