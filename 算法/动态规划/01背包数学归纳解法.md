# 01背包数学归纳解法

### 问题简述

$N$ 件物品: $1, 2, \dots,N$

物品体积: $v_1,v_2, \dots,v_N$

物品价值: $w_1,w_2,\dots,w_N$

背包容量 $V$

每个物品最多使用一次

求最大价值

## 数学归纳法

一般的算法题证明都是用**循环不变式**，其本质就是**数学归纳法**

动态规划问题更加偏向数学，所以将其看待为数学问题，用数学归纳法来研究

### 示例

已知 $a_0 = 0, a_n + 1 = a_{n+1}$，求 $a_{100}$

证:

证明 $a_n = n$, $n \in [0,+\infty)$, $n$ 为整数

1.$n = 0$ 时，$a_0 = 0$, 通项式显然成立

2.假定 $n = k$ 时，$a_k = k$

则 $a_{k+1} = a_k + 1 = k + 1$, 通项式成立

所以 $a_n = n$ 成立，$a_{100} = 100$

> 思考1

$~$

### 动态规划视角下的数学归纳法

还是上面那个例子，动态规划视角:

已知 $a_n + 1 = a_{n+1}$ 

由 $a_0 = 0 \rightarrow a_1 = 1 \rightarrow a_2 = 2 \rightarrow \dots \rightarrow a_{100} = 100$

其中，

* $a_{100}$ 是总问题的解
* $a_0,a_1,\dots,a_{99}$ 是相对于 $a_{100}$ 的子问题的解
* $a_0$ 为初始化时设的值，即人为填上的解

* $a_n + 1 = a_{n+1}$ 是状态转移方程
* 计算的过程就是自底向上递推的过程
* 计算的反过程就是自顶向下递归的过程

## 01背包的数学归纳解法

### 问题分析

将物品的体积与价值看作常数

与最大价值有关的有两个量: 物品件数 $n$，背包容量 $v$

物品件数 $n$ 类似于上述示例中 $a_n$ 的下标，往往也是我们的**循环变量**

> ```
> for(int i = 0; i < n; i++)	// i 为 for 循环的循环变量
> 	...
> ```

背包容量 $v$ 是多出来的那一维, 因为其值也影响着结果的不同

$~$

### 抽象出 "$a_{100}$"

类比 $a_{100}$，抽象出 01 背包问题的解

$a_{n,v}$ 表示在物品件数为 $n$, 背包体积为 $v$ 时的最大价值

$~$

### 抽象出递推式

站在 $a_{n,v}$ 的视角，研究其与 $a_{n-1,?}$ 的关系

> 思考3

根据 $a_{n-1,?}$ 的含义，物品 $1,2,\dots,n-1$ 每一件都已经确定了是否选取

那么只剩下物品 $n$ 是否选取了:

* 不选: $a_{n-1,v}$

* 选: $a_{n-1,v-v_n} + w_n$ 

  对 $a_{n,v}$ 而言

  选择了物品 $n$ 后，占用背包体积 $v_n$，得到价值 $w_n$

  于是问题变成了物品件数 $n-1$ (暗含前 $n-1$ 个物品意义), 背包体积为 $v - v_n$ 的最大价值，即 $a_{n-1,v-v_n}$ 

  二者加到一块即为这种情况下的价值: $a_{n-1,v-v_n} + w_n$ 

于是根据 $a_{n,v}$ 的含义，$a_{n,v} = \max \{a_{n-1,v},a_{n-1,v-v_n} + w_n\}$

其中，根据实际问题的约束, $a_{n-1,v-v_n} + w_n$ 有可能无效，因为要满足 $v-v_n \geq 0$

总的来说，递推式为:
$$
a_{n,v} = 
\left\{
\begin{array}{}
a_{n-1,v}	 & & v-v_n < 0 \\
\max \{a_{n-1,v},a_{n-1,v-v_n} + w_n\} & & v-v_n \geq0
\end{array}
\right.
$$

###  抽象出 "$a_0$"

对因素 $n$ 而言，根据实际问题的含义，显然初始为 $n = 0$

对因素 $v$ 而言，根据递推式的分析，显然初始为 $v = [0,V]$

总的来说，待设置的初始量有 $a_{n = 0, v = 0 \sim V}$

根据实际问题的含义，物品件数 $n = 0$ 时，显然最大价值为 $0$，即 $a_{n = 0, v = 0 \sim V} = 0$

> 思考2

### 代码实现

```C++
#include <iostream>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];
int f[N][N];	// 初始化 a_{n=0,v=0~V} = 0

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> v[i] >> w[i];

    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
        {
            if(j < v[i]) 	// 递推式
                f[i][j] = f[i-1][j];
            else 
                f[i][j] = max(f[i-1][j], f[i-1][j-v[i]] + w[i]);
        }
        
    cout << f[n][m] << endl;	// 问题的解
    
    return 0;
}
```



## 发散性思考

01背包的数学归纳解法大体说完了，在这个过程中，是否有一些值得思考的点呢？

### 思考1

**对于数学归纳法的那个示例，计算机视角是怎样的**？

示例是数学的解法，但计算机往往不是这么解的，因为：

1. 在复杂问题中，通项式往往难以得到

   > 如果能在算法题中证出通项式，那么时间复杂度就是 $O(1)$，如斐波那契数列

2. 在得到 $a_n$ 与 $a_{n+1}$ 的递推式时，就已经可以直接算出来了

   > 这就是所谓的动态规划了，难点就在于从问题中抽象出 $a_n$ 与 $a_{n+1}$ 的递推式
   >
   > 在动态规划里貌似叫做**状态转移方程**，但其本质就是数学归纳法的递推式
   >
   > 时间复杂度往往跟递推的维数有关，一维递推 $O(n)$ 二维递推 $O(n^2)$ ....

### 思考2

**动态规划初始化**

$a_0$ 的值是人为规定的问题在具体情况下的解

初始化的设置很重要，即使递推式一样，多米诺骨牌效应也会将初始化的不同一步步积累到最后，这是动态规划的一个坑

事实上，还可以对初始值设置特殊值来达到一些目的

我们对多米诺骨牌最开始的那个骨牌做一些手脚，随着递推的推进，然后就能看到完全不同的牌型

### 思考3

>  **站在 $a_{n,v}$ 的视角，我们研究其与 $a_{n-1,?}$ 的关系**

**这里的视角是什么含义？**

>  废话: 视角就是以 XXX 为研究对象，研究与其他 XXX 的关系，

具体来说，不仅可以站在 $a_{n,v}$ 的视角研究其与 $a_{n-1,?}$ 的关系

也可以站在 $a_{n,v}$ 的视角研究其与 $a_{n+1,?}$ 的关系

甚至你可以换个影响因素来研究，不研究 $a_{n,v}$ 了，研究 $a_{n,m}$，$a_{q,p}$ ....

这就是为什么有些动态规划题换个视角后也能解题的原因，如谷歌经典扔鸡蛋问题

$~$

总结, **动态规划里的视角**分为:

按**递推方向**分:

* 研究 $a_n$ 与 $a_{n+1}$ 的关系
* 研究 $a_n$ 与 $a_{n-1}$ 的关系

一般我们都是研究 $a_n$ 与 $a_{n-1}$ 的关系，但有些题研究 $a_n$ 与 $a_{n+1}$ 的关系确实很容易解，例子我模糊地想到了，但好久没刷题了，找不到

> 继续发散后也是个坑，详细拓展开的话，可以扯到完全背包的空间优化，还能扯到我预想中的: 某些题会不会专门出一道需要从 $a_{n+1,v+1}$ 递推到 $a_{n,v}$ 的题 ，打破定势思维: 从低到高从小到大递推
>
> 具体参考这个[帖子](https://www.acwing.com/solution/content/56714/)遍历顺序一小节，回顾了下发现，原来之前埋的一个坑没填完，遍历顺序一小节还有些内容没写



$~$

按**影响因素**分:

> 乱写的几个字母，没有实际含义，代表某种分类情况

* 研究 $a_{n,v}$
* 研究 $a_{n,m}$
* 研究 $a_{q,p}$

> 可以参考这篇帖子[站在不同角度, 整数划分的四种解法](https://www.acwing.com/solution/content/133506/)
>
> 也可以研究下谷歌经典面试题扔鸡蛋

需要注意的是，每一种划分方式下的**影响因素**应具有**完备性**

如上述 01 背包数学归纳解法中的 $a_{n,v}$

影响因素 $n,v$ 应能够完备地决定问题的解，即物品件数 $n$ 和背包体积 $v$ 应该能够完备地决定最大价值是多少

$~$

继续发散，我想起了某些动规问题: 正常做是三维动态规划，但是通过某种方式可以转换为二维动态规划

现在，我可以用**影响因素完备性**的观点来说明: 三维动态规划解法中三个影响因素对问题的解是**完备**的，但有**冗余**，于是可以将其转化为二维动态规划，对应的两个影响因素也是**完备**的，因而能够解决问题

### 思考4

**动态规划与最优化？**

事实上，动态规划有其数学描述，属于最优化这门数学课，但感觉暂时也用不到

### 思考5

**空间复杂度优化**

### 思考6

**输出最优路径**