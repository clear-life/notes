# 做题思想

## 补集思想

有点类似**反向思维**, 细节略有不同: 反向思维侧重**反向**, 补集思想侧重**补集**

**补集思想**

已知 $A + B = n$, $n$ 为常数

通过题目条件直接求 $A$ 不好求, 但 $B$ 好求, 于是通过 $A = n - B$ 求 $A$

## 逆向思维

有时**正向突破比较难**的话, 可以考虑**逆向思维**

[地下城游戏](https://leetcode.cn/problems/dungeon-game/)

**一般思路**:

$f_{ij}$ 表示从起点 $(1,1)$ 到点 $(i, j)$ 的**最小初值**

> 此初值是 $f(1, 1)$ 的值, 此处已出现不和谐 "$f_{ij}$ 表示的是 $f_{11}$ 的值"

但此时的 $f_{ij}$ 的值只是**初值**, **不能用来进行状态转移**, 因为状态转移涉及**起点到当前点的路径和**

所以在状态转移时非常困难, 思绪繁杂不知从何入手

**逆向思维**:

考虑逆向思维, 用 $f_{ij}$ 表示从 $(i,j)$ 到终点的**最小初值**, 此时 **$f_{ij}$ 的值刚好就意味着在 $(i,j)$ 处的最小初值**

**状态值**与**状态所处的位置**对应上了, 因此能够进行状态转移

$A_{ij}$: 从 $(i,j)$ 到终点的所有路径

划分: 第一步

> 两种思路
>
> $A_{ij}$: 从起点到 $(i,j)$ 的所有路径, 划分: 最后一步
>
> $A_{ij}$: 从 $(i,j)$ 到终点的所有路径, 划分: 第一步
>
> 关键是**状态值的含义**要与**状态所处的位置**对应上



$~$

[环形子数组的最大和](https://leetcode.cn/problems/maximum-sum-circular-subarray/)	

环状连续子数组的最大和 = sum - 连续子数组的最小和

$n$  :数组的和

$A$ :环状连续子数组的最大和 

$B$ :连续子数组的最小和

[可获得的最大点数](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/)	

环状连续子数组的最大和 = sum - 连续子数组的最小和

$n$  :数组的和

$A$ :环状连续子数组的最大和

> 环状连续子数组的个数限制为 k 

$B$ :连续子数组的最小和

> 连续子数组的个数限制为 n - k

$~$

## 逆向思维

### 1. 从结果反推

有时正向做题不容易的情况下, 我们可以**假定结果已经确定**, 然后**分析存在的性质**

[两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/)	

假定结果已经确定, 通过**对 s 和 t 的组成成分进行分析**, 发现结果是 s 和 t 的**最长公共子序列**

于是, 问题就转化成了求出 s 和 t 的最长公共子序列

## 多个影响因素

如果跟结果有关的值, 其有**多个影响因素**的话, 要尽可能**挨个去除**每个**影响因素对值的影响**

直到**最后剩下的影响因素**是**已知的模型**

$~$

已知 $A, B, C, D$ 等 $n$ 个结果的影响因素, 通过不同手段**尽可能减少影响因素的个数**, 

使之减少为 $A', B',C'$ 等 $m$ 个影响因素, $m < n$, 且这 $m$ 个影响因素结合为**已知的问题模型**

### 去除影响因素的手段

#### 1. 枚举影响因素的值

对影响因素 $A$, 其值在 $[l, r]$ 内

`for(int A = l; A <= r; A++)` 即可固定 $A$ 的值, 然后考虑其余的影响因素

[最大子数组和](https://leetcode.cn/problems/maximum-subarray/)	

**影响因素**: 子数组的左边界 $l$, 右边界 $r$ 

**手段**: 枚举右边界的值 $r$

**最后的问题模型**: 以 $a_i$ 结尾的连续子数组最大和

[最大子矩阵](https://leetcode.cn/problems/max-submatrix-lcci/)	

**影响因素**: 子矩阵的**左上和右下坐标** $(x_1, y_1, x_2, y_2)$

**手段**: 枚举子矩阵的行坐标 $x_1$ 和 $x_2$

**最后的问题模型**: 连续子数组的最大和, 子数组左边界为 $y_1$, 右边界为 $y_2$

[矩形区域不超过 K 的最大数值和](https://leetcode.cn/problems/max-sum-of-rectangle-no-larger-than-k/)	

**影响因素**: 子矩阵的**左上和右下坐标** $(x_1, y_1, x_2, y_2)$

**手段**: 枚举子矩阵的行坐标 $x_1$ 和 $x_2$

**最后的问题模型**: 给定数组, 求和不超过 k 的连续子数组最大和

[打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

**影响因素**: 第 1 个房屋与第 n 个房屋是否被偷会互相影响

**手段**: 枚举第 1 个房屋是否被偷

**最后的问题模型**: 两次普通的状态机 dp, 但初值不同

#### 2. 排序

对某影响因素 $A$, 如果涉及到**前后元素的大小关系**, 通过**排序**可以减少去除该影响因素

具体的**排序方法**需要根据题目分析**自行制定**

[俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/)	

**影响因素**: 信封的宽 $w_i$ 和高 $h_i$ 都要求严格递增

**手段**: 优先对 $w$ 从小到大排序, 其次对 $h$ 从大到小排序

**最后的问题模型**: 最长上升子序列模型, 只需考虑信封宽 $h$ 是严格递增的

[删除并获得点数](https://leetcode.cn/problems/delete-and-earn/)

**影响因素**: 对 $a[i]$ 操作需要考虑对 $a[i] - 1$ 和 $a[i] + 1$ 的影响, 且原数组乱序

**手段**: 对原数组**排序**, 且**相同元素只在数组中存储一个**

**最后的问题模型**: 简单状态机模型

[最大整除子集](https://leetcode.cn/problems/largest-divisible-subset/)	

**影响因素**: 原数组乱序, 又要求 `arr[i] % arr[j] == 0` 和 `arr[j] % arr[i] == 0` 必须满足一个

**手段**: 对原数组**排序**, 于是只需判断新加入元素是否是上一元素的倍数就满足要求

**最后的问题模型**: 简单子序列模型

#### 3. 固定影响方向

某一影响因素与多个不同方向有关, 可以**固定遍历顺序来固定影响方向**

例: 

如对于 $f_i$ 的值, $[1, i-1]$ 和 $[i+1, n]$ 上的值均对其有影响

那么可以**从前往后遍历**, 从而对于 $f_i$ 来说, 只需要考虑 $[1, i-1]$ 的影响

[打家劫舍](https://leetcode.cn/problems/house-robber/)	

**影响因素**: 第 $i-1$ 和 $i+1$ 个房屋是否被偷都会影响第 $i$ 个房间的决策

**手段**: 从前往后遍历

**最后的问题模型**: $f_i$ 只需考虑 $f_{i-1}$ 是否被偷

$~$

## 问题等价变形

对原问题进行**分析证明**后, 将其转换为**等价的问题模型**

原问题为 $A$, 等价问题为 $B$, 即 $A \iff B$

于是可以采用等价问题 $B$ 的做法求出原问题 $A$ 的解

[3n 块披萨](https://leetcode.cn/problems/pizza-with-3n-slices/)

**原问题**: 在 3n 大小的数组中选数, 每次选中一个数后, 左右相邻(环形数组)的数就被删去, 选择 n 个数后, 返回最大的n 数之和 

**等价问题**: 在 3n 大小的数组中选 n 个数, 任意两个数不能相邻(环形数组), 求最大的 n 数之和 

[最低加油次数](https://leetcode.cn/problems/minimum-number-of-refueling-stops/)	

**原问题**: 求最低加油次数

**等价问题**: 转化为: 在能到达的前提下, 给定加油次数后, 所能到达的最远距离

直接改变了 dp 中状态定义方式, 不根据要的结果定义状态, 而是根据结果等价问题定义状态

$~$

## 分块处理

通过**把问题分解为一个个小的独立子问题**, 然后分别处理每个子问题, 最后把结果合并起来

### 前后缀分离

问题由**前后两部分 $A$ 和 $B$** 组成时, 通常可以**枚举分界点**, 然后**分别处理两个独立的子问题**

```C++
for(int k = 0; k < n; k++) 	// k 是分界点
{
    // 处理 A
    ...
        
    // 处理 B
    ...
        
    // 合并 A 和 B 的结果
    ...
}
```

[买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)	

**前后两部分**: 两次交易

**分界点**: 用第二次交易的买入日作为分界点

**分别处理子问题**: 

1.  第一次交易

   提前预处理出结果数组, 可以直接得到前 i 天的最大收益

2. 第二次交易

   逆序枚举**买入日**, 把每个数后面的最大价格作为卖出日的价格 

## 预处理

当算法的某一步能够抽离出来的话, 可以**提前预处理出结果**

防止在循环中影响时间复杂度, **导致时间复杂度变大**

**预处理这一步要当作单独的算法题看待**

```C++
int f[N];		// 预处理数组
for(int i = 0; i < n; i++)
    f[i] = fun(i);

for(int i = 0; i < n; i++)
{
 	...   
        res = g(f[i]);	// 直接调用预处理数组的结果, 不用浪费时间在 fun(i) 上
}
```

## 写表达式

遇到困难时, 先试着**把表达式写出来**, 然后试着**将表达式做等价变形**, 看能否有转机

[矩形区域不超过 K 的最大数值和](https://leetcode.cn/problems/max-sum-of-rectangle-no-larger-than-k/)	

通过枚举矩形区域上下界, 将问题转化为了

> 给定整数数组和整数 k，计算数组的最大区间和，要求区间和不超过 k。

区间和公式 $sum[l, r] = s_l - s_r$

限制: 区间和不超过 k, 则 $s_l - s_r \leq k \Rightarrow s_r \geq s_l - k$

所以, 只需找到 $\geq s_l - k$ 的最小数就 ok 了, 问题转化为了**二分**

**没有条件, 也要创造条件**

二分算法要求有序, 而**从前往后的前缀和不一定有序**, 因此需要用一个 `set` 来维护一个**前缀和有序数组**

同时, 注意到边界情况可能存在 $s_r$ 为 0 的情况, 所以要加入**哨兵**

```C++
// 前缀和数组 s

set<int> S;
S.insert(0);
for(int j = 1; j <= n; j++)
{
    auto it = S.lower_bound(s[j] - k);
    if(it != S.end()) res = max(res, s[j] - *it);
    S.insert(s[j]);
}
```

