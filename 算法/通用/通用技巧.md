# 通用技巧

### 多维数据一维化展开

**三维数据**

(i, j, k) 展开为 (i * j 的维度 + j) * k 的维度 + k

```C++
m * n * l 三维数组
(i, j, k) 展开为 (i * n + j) * l + k
 
// 三维转一维
(i, j, k) m * n * l
(i * n + j) * l + k		// 先把 (i, j, k) 看成 (i, j) 和 k 的二维数据, 再展开二维数据 (i, j)

// 一维转三维
x
(x / l / n, x / l % n, x % l)
```

**一位数据还原为多维数据**

**一维与二维转换**

```C++
// 二维转一维
(i, j)  m 行 n 列
i * n + j
    
// 一维转二维
k
(k / n, k % n)
```



### 离散化

哈希函数可以利用 STL 中的 `unordered_map` 帮我们实现

但具体的转换需要我们来做

为什么呢?

因为哈希函数只认一维数据, 如果我们想把一个多维数据离散化到 0~n 的话, 就需要将其一维化

```C++
unordered_map<type, int> hash;
type get(data)	// 将多维数据转化为可以哈希的一维数据
{
    ...
}

for(int i = 0; i < n; i++)
{
    hash[get(data[i])] = i;
}
```

### 离线与在线

在线操作: 边读入操作边执行

离线操作: 读入完所有操作后再执行, 可以以任意顺序执行, 然后返回结果不变

**常用质数**

取余时尽可能用质数做模

```C++
1e5 + 3
2e5 + 3
3e5 + 7
```

### 随机数

```C++
#include <ctime>

srand(time(nullptr));	// 用时间设置随机种子
rand()					// 生成一个随机数

a + rand() % n			// 生成一个 [a, a + n) 的整数
rand() / (double) RAND_MAX	// 生成一个 [0, 1] 之间的浮点数
```

### 预定义

```C++
#define x first
#defint y second

typedef pair<int, int> PII;
```

### goto

```C++
for(int i = 0; i < n; i++)
    for(int j = 0; j < n; j++)
    {
        if(...)
            goto label;
    }
label:
	...
```

### 括号匹配

合法的括号序列充要条件

1. 任意的前缀满足 `'('` 个数大于等于 `')'` 个数
2. 总的左右括号个数相等

