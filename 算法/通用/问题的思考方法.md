# 问题的思考方法

## 正向

### 递进法

有点像数学归纳法

**算法程序常常是个循环, 重复执行一套逻辑**

**步**: 定义为算法的一次循环

对于第 n 步, 假定前 n - 1 步已经执行完

考虑在前 n - 1 步执行完的基础上, **应该怎样执行第 n 步**

## 反向

### 答案假设法

假设答案对应的方案已经找到, **寻找其性质 / 规律**, **然后再正向考虑**

> 性质的确立必须要有严谨的证明



## 练习

[拦截导弹](https://www.acwing.com/problem/content/1012/)

考虑第 i 个元素, 假定前 i - 1 个元素已经确定了其在最终方案里的位置

用 `f[N]` 来记录每个系统的末尾元素, 不妨设此时已有 cnt 个系统

**1. 考虑 a[i] 与 f[1.. cnt] 的关系**

**若 a[i] <= f[j]**

显然, a[i] 可以接在 f[j] 的后面

**若 a[i] > f[j]**

显然, a[i] 不可能接在 f[j] 的后面

**2. 考虑将 a[i] 接在谁的后面**

对于能接的情况, 即 a[i] <= f[j]

> 极端情况: 所有的 f[j] 都小于 a[i], 则需要创建一个新的子序列

考虑到 f[j] 越大, 后面能接的越多

$\therefore$ a[i] 接到 f[j] 后面要尽可能减少这种影响, 使得 f[j] 能尽可能多接

$\therefore$ a[i] 最好接到**满足条件(a[i] <= f[j])的最小 f[j]** 后面

$\therefore$ a[i] 要贪心地接到满足条件的最接近的 f[j] 后面

当然, 这是贪心的猜测, 下面还需要证明

**3. 证明贪心选择的正确性**

**调整法**

设贪心选择得到的答案为 A, 最优解为 B

显然, $A \geq B$

下面证明 $A \leq B$

设 A 和 B 方案第一个不同点在于元素 x

即, 再 A 和 B 的方案中,  x 放到了不同的子序列里

$~$

设 A 中 x 的上一个元素为 a, B 中 x 的上一个元素为 b

根据贪心选择: x 一定放到最接近的 f[j] 后面, 则 $a \leq b$

则最优解中 **b 之后的子序列**可以与 **a 之后的子序列**

$\because$  $x \leq a$ 

$\therefore$ **b 之后的子序列**首元素由于是 x, 所以能够交换到 a 后面

$\because$ $a \leq b$

$\therefore$ **a 之后的子序列**能够交换到 b 后面

交换后, A 和 B 的第一个不同点消除了

由于该操作并未增大 B 的值, 且最终转化为 A

$\therefore$ $A \leq B$

$~$

**结论:** 最终抽象出了一个 LIS 模型, **最长非上升子序列**覆盖整个序列的最少个数是**最长上升子序列**的长度