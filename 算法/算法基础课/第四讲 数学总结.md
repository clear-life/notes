# 第四讲 数学总结

## 1. 数论

### 质数

---

**质数判定$O(\sqrt{n})$**

**要点:**

`for i = 2 to x / i`

遍历 a * b = x 中较小的那个 a

```C++
// 思路模板
for i = 2 to x / i
    if i | x        // i | x 表示 i 能整除 x
        x 是合数

// 完整模板
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0) return false;
    return true;
}
```

---

**质因数分解**

**要点:**

`for i = 2 to x / i`

每遇到 x 的质因子 i , 就将其除尽

---

循环结束后, x 若未被除尽, 则此时的 x 是最大的质因子, 次数为 1

```C++
// 思路模板
for i = 2 to x / i
    while(i | x)
        x /= i
if x > 1
    x 是最大的质因子, 次数为 1
        

// 完整模板
void divide(int x)
{
    for(int i = 2; i <= x / i; i++)
    {
        if(x % i == 0)
        {
            int cnt = 0;
            while(x % i == 0) x /= i, cnt++;
            cout << i << " " << cnt << endl;
        }
    }
    if(x > 1) cout << x << " " << 1 << endl;
}
```

---

**筛质数**

朴素筛法$O(n^2)$

**要点:**

`for i = 2 to n`

筛掉所有素数的多倍数

```C++
for(int i = 2; i <= n; i++)
{
    if(!st[i])
        for(int j = i + i; j <= n; j += i) st[j] = true;
}
```

**线性筛法$O(n)$**

**要点:**

`for i = 2 to n`

> 只有筛质数是 2 to n, 其余**基本**都是 2 to n / i

---

筛掉 `primes[j] * i = x`, `primes[j]` 是 x 的最小质因子

---

`primes[j] <= n / i` 不需要加上 j 是否出界的判断条件

```C++
// 思路模板
for i = 2 to n
    if i 未被筛掉
        i 是素数
    筛掉所有 primes[j] * i 的数
    	if primes[j] | i
        break


// 完整模板
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
    for(int i = 2; i <= n; i++)
    {
        if(!st[i]) primes[cnt++] = i;
        for(int j = 0; primes[j] <= n / i; j++)
        {
            st[primes[j] * i] = true;
            if(i % primes[j] == 0) break;
        }
    }
}
```

