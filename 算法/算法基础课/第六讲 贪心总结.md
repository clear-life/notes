# 第六讲 贪心总结

## 区间问题

**[区间合并](https://www.acwing.com/problem/content/805/) $O(n)$**

**要点:**

1. 排序左端点
2. 从左往右尽可能合并区间
3. 遍历结束后记得把最后一个 {st, ed} 加上

```C++
// 思路模板
sort(q)
for i = 区间1 to 区间n
	l 为左端点, r 为右端点
    if l > ed
    	{st, ed} 为合并后的局部最优解区间
        更新 st, ed
    else
        更新 ed
{st, ed} 为最后一个合并区间
        
// 完整模板
// 排序左端点, 从左向右遍历
sort(q.begin(), q.end());
    
int st = -2e9, ed = -2e9;

for(auto i : q)
{
    int l = i.first, r = i.second;
    if(ed < l) 
    {
        if(st != -2e9) res.push_back({st, ed});
        st = l, ed = r;
    }
    else 
        ed = max(ed, r);
}

if(st != -2e9)
    res.push_back({st, ed});
```

对称的实现方式: 排序右端点, 从右向左遍历

```C++
// 排序右端点, 从右向左遍历
// 思路
sort(q)
for i = 区间n to 区间1
	l 为左端点, r 为右端点
    if r < st
    	{st, ed} 为合并后的局部最优解区间
        更新 st, ed
    else
        更新 st
{st, ed} 为最后一个合并区间

        
// 完整代码
struct Range
{
    int l, r;
    bool operator<(const Range &ne) const
    {
        return r < ne.r;
    }
}ranges[N];

sort(ranges, ranges + n);

int st = 2e9, ed = 2e9;
for(int i = n - 1; i >= 0; i--)
{
    int l = ranges[i].l, r = ranges[i].r;
    if(ranges[i].r < st)
    {
        if(st != 2e9) res.push_back({st, ed});
        st = l;
        ed = r;
    }
    else
        st = min(st, l);
}
if(st != 2e9) res.push_back({st, ed});
```



$~$