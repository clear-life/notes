# 第六讲 贪心总结

## 区间问题

**[区间合并](https://www.acwing.com/problem/content/805/) $O(n)$**

**要点:**

1. 排序左端点
2. 从左往右尽可能合并区间
3. 遍历结束后记得把最后一个 {st, ed} 加上

```C++
// 思路模板
sort(q)
for i = 区间1 to 区间n
	l 为左端点, r 为右端点
    if l > ed
    	{st, ed} 为合并后的局部最优解区间
        更新 st, ed
    else
        更新 ed
{st, ed} 为最后一个合并区间
        
// 完整模板
// 排序左端点, 从左向右遍历
sort(q.begin(), q.end());
    
int st = -2e9, ed = -2e9;

for(auto i : q)
{
    int l = i.first, r = i.second;
    if(ed < l) 
    {
        if(st != -2e9) res.push_back({st, ed});
        st = l, ed = r;
    }
    else 
        ed = max(ed, r);
}

if(st != -2e9)
    res.push_back({st, ed});
```

对称的实现方式: 排序右端点, 从右向左遍历

```C++
// 排序右端点, 从右向左遍历
// 思路
sort(q)
for i = 区间n to 区间1
	l 为左端点, r 为右端点
    if r < st
    	{st, ed} 为合并后的局部最优解区间
        更新 st, ed
    else
        更新 st
{st, ed} 为最后一个合并区间

        
// 完整代码
struct Range
{
    int l, r;
    bool operator<(const Range &ne) const
    {
        return r < ne.r;
    }
}ranges[N];

sort(ranges, ranges + n);

int st = 2e9, ed = 2e9;
for(int i = n - 1; i >= 0; i--)
{
    int l = ranges[i].l, r = ranges[i].r;
    if(ranges[i].r < st)
    {
        if(st != 2e9) res.push_back({st, ed});
        st = l;
        ed = r;
    }
    else
        st = min(st, l);
}
if(st != 2e9) res.push_back({st, ed});
```

$~$

**[区间选点](https://www.acwing.com/problem/content/907/) $O(n)$**

**要点:**

1. 排序右端点
2. 从左往右遍历区间, 若已被覆盖就 pass, 未被覆盖就选其右端点

```C++
// 思路模板
sort(q)
for i = 区间1 to 区间n
	l 为左端点, r 为右端点
    if l > ed
    	选 r 点
        更新 ed
        
// 完整模板
// 排序右端点, 从左向右遍历
struct Range
{
    int l, r;
    bool operator< (const Range &ne) const
    {
        return r < ne.r;
    }
}ranges[N];

sort(ranges, ranges + n);

int res = 0, ed = -2e9;
for(int i = 0; i < n; i++)
{
    if(ranges[i].l > ed)
    {
        ed = ranges[i].r;
        res++;
    }
}

// 排序左端点, 从左向右遍历的思路
sort(q)
for i = 区间1 to 区间n
	l 为左端点, r 为右端点
    if l > ed
        确定选 ed
        暂时选 r 点, 用 r 更新 ed
    else
        更新 ed
```

$~$

**[最大不相交区间数量](https://www.acwing.com/problem/content/910/) $O(n)$**

**要点:**

1. 排序右端点
2. 从左往右遍历区间, 若能选就选, 不能选就跳过

```C++
// 思路模板
sort(q)
for i = 区间1 to 区间n
	l 为左端点, r 为右端点
    if l > ed
        更新 ed
        
// 完整模板
// 排序右端点, 从左向右遍历
struct Range
{
    int l, r;
    bool operator<(const Range &ne) const
    {
        return r < ne.r;
    }
}ranges[N];

sort(ranges, ranges + n);

int res = 0, ed = -2e9;
for(int i = 0; i < n; i++)
{
    if(ranges[i].l > ed)
    {
        res ++;
        ed = ranges[i].r;
    }
}
```

$~$

**[区间分组](https://www.acwing.com/problem/content/908/) $O(n)$**

**要点:**

1. 排序左端点
2. 从左往右遍历区间, 若能插入已有组就插入, 不能插入就新建一个组
3. 小顶堆, 记录最小右端点

```C++
// 思路模板
sort(q)
for i = 区间1 to 区间n
	l 为左端点, r 为右端点
    if 没有组 or 组的最小右端点 >= l
        新建组, 右端点为 r
    else
        更新右端点为 r
        
// 完整模板
// 排序右端点, 从左向右遍历
sort(ranges, ranges + n);

priority_queue<int, vector<int>, greater<int>> heap;
for(int i = 0; i < n;i++)
{
    if(heap.empty() || heap.top() >= ranges[i].l) heap.push(ranges[i].r);
    else
    {
        heap.pop();
        heap.push(ranges[i].r);
    }
}
```

$~$

