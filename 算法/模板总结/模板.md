# 输入输出

**getline**

```C++
int n;
cin >> n; cin.get();

string t;
for(int i = 0; i < n; i++)
    getline(cin, t);
```

# 数据结构

### 队列

```C++
int q[N], hh = 0, tt = -1;

q[hh]; 		// q.front()

q[++tt] = x;// q.push(x)

hh++;		// q.pop()

if(hh <= tt)// q.empty()
```

### 位运算

**第 k 位**

```C++
x >> k & 1;
```

**第 k 位取反**

```C++
x ^= 1 << k;
```

**最后一位 1**

```C++
lowbit(n) = n & -n;
```

**最低位 1 的位次**

```C++
int k = 0;
while(!(x >> k & 1)) k++;
```

**异或性质**

$a \oplus b = c$

$b \oplus c = a$

$a \oplus c = b$ 

三者但凡成立一个, 则另外两个也一定成立

### 前缀和与差分

**前缀和**

一维

$s[i] = s[i - 1] + a[i]$

```C++
for(int i = 1; i <= n; i++)
    s[i] = s[i - 1] + a[i];

sum[l, r] = s[r] - s[l - 1];
```

二维

```C++
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= m; j++)
        s[i][j] = s[i][j - 1] + s[i - 1][j] - s[i - 1][j - 1] + a[i][j];
int get(int x1, int y1, int x2, int y2)
{
    return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1];
}
```

**差分**

一维

$d[i] = a[i] - a[i - 1]$

```C++
void insert(int l, int r, int c)
{
    d[l] += c, d[r + 1] -= c;
}
```

二维

```C++
void insert(int x1, int y1, int x2, int y2, int c)
{
    d[x1][y1] += c, d[x1][y2 + 1] -= c, d[x2 + 1][y1] -= c, d[x2 + 1][y2 + 1] += c;
}
```



# 算法

## 基础算法

### 快速排序

```C++
void quick_sort(int q[], int l, int r)
{
    if(l >= r) return;
    
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while(i < j)
    {
        do i++; while(q[i] < x);
        do j--; while(q[j] > x);
        if(i < j) swap(q[i], q[j]);
	}
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```

### 归并排序

```C++
void merge_sort(int q[], int l, int r)
{
    if(l >= r) return;
    
    int mid = l + r >> 1;
    
    merge_sort(q, l, mid), merge_sort(q, mid + 1, r);
    
    int i = l, j = mid + 1;
    int tmp[r - l + 1], k = 0;
    
    while(i <= mid && j <= r)
        if(q[i] <= q[j]) tmp[k++] = q[i++];
    	else tmp[k++] = q[j++];
   	while(i <= mid) tmp[k++] = q[i++];
    while(j <= r) tmp[k++] = q[j++];
    
    for(i = l, k = 0; i <= r;) q[i++] = tmp[k++];
}
```

### 二分

**前提:** 数据结构满足二段性

> 二段性: 一分为二, 一段满足某一性质, 一段不满足该性质

**左分界点**

左半边为 true, 右半边为 false

```C++
int fun(int l, int r)
{
    while(l < r)
    {
        int mid = l + r + 1 >> 1;
        if(check(mid)) l = mid;
        else r = mid - 1;
    }
    if(check2(l)) l;
    return -1;
}
```

**右分界点**

右半边为 true, 左半边为 false

```C++
int fun(int l, int r)
{
    while(l < r)
    {
        int mid = l + r >> 1;
        if(check(mid)) r = mid;
        else l = mid + 1;
    }
    if(check2(l)) return l;
    return -1;
}
```

**STL**

`>= 和 >` 失败返回 `S.end()`

`<= 和 <` 失败返回 `S.begin()`

```C++
set<int> S;

// >= 和 >
auto it = S.lower_bound(x) / S.upper_bound(x);
if(it != S.end()) return it;
else return -1;

// <= 和 < 
auto it = S.upper_bound(x) / S.lower_bound;
if(it != S.begin())
{
    it--;
    return it;
}
else return -1;
```

### 双指针

**同向双指针**

**前提:**

1. 区间 $[j, i]$ 满足**某种性质**
2. $j$ 和 $i$ 具有**同向性**

**模板**

```C++
for(int i = 0, j = 0; i < n; i++)
{
    while(j < i && check(j, i)) j++;
    ...
}
```

