# 输入输出

**getline**

```C++
int n;
cin >> n; cin.get();

string t;
for(int i = 0; i < n; i++)
    getline(cin, t);
```

# 数据结构

### 队列

```C++
int q[N], hh = 0, tt = -1;

q[hh]; 		// q.front()

q[++tt] = x;// q.push(x)

hh++;		// q.pop()

if(hh <= tt)// q.empty()
```

### 单调栈

**用法:** 从左往右找到每个数**左边第一个比自己小**的数

```C++
for(int i = 1; i <= n; i++)
{
    while(stk.size() && arr[stk.top()] >= arr[i]) stk.pop();
    ...
    stk.push(i);
}
```



### 位运算

**第 k 位**

```C++
x >> k & 1;
```

**第 k 位取反**

```C++
x ^= 1 << k;
```

**最后一位 1**

```C++
lowbit(n) = n & -n;
```

**最低位 1 的位次**

```C++
int k = 0;
while(!(x >> k & 1)) k++;
```

**异或性质**

$a \oplus b = c$

$b \oplus c = a$

$a \oplus c = b$ 

三者但凡成立一个, 则另外两个也一定成立

### 前缀和与差分

**前缀和**

一维

$s[i] = s[i - 1] + a[i]$

```C++
for(int i = 1; i <= n; i++)
    s[i] = s[i - 1] + a[i];

sum[l, r] = s[r] - s[l - 1];
```

二维

```C++
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= m; j++)
        s[i][j] = s[i][j - 1] + s[i - 1][j] - s[i - 1][j - 1] + a[i][j];
int get(int x1, int y1, int x2, int y2)
{
    return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1];
}
```

**差分**

一维

$d[i] = a[i] - a[i - 1]$

```C++
void insert(int l, int r, int c)
{
    d[l] += c, d[r + 1] -= c;
}
```

二维

```C++
void insert(int x1, int y1, int x2, int y2, int c)
{
    d[x1][y1] += c, d[x1][y2 + 1] -= c, d[x2 + 1][y1] -= c, d[x2 + 1][y2 + 1] += c;
}
```

**广义前缀和**

**前提:**

定义**二元运算符** **$+$** 及其**逆运算符 $-$**

> **逆运算符 $-$ **: 若 $a + b = c$, 则 $b = c - a$

有一区间 $[l, r]$, 一分为二为 $[l, k]$ 和 $[k + 1, r]$

设 $[l, k]$ 上 $+$ 运算符的结果为 $a$, $[k + 1, r]$ 上 $+$ 运算符的结果为 $b$, $[l, r]$ 上 $+$ 运算符的结果为 $c$

**二元运算符 $+$ 应满足 $a + b = c$**

**模板:**

$s_i = a_1 + a_2 + \dots + a_i$

```C++
for(int i = 1; i <= n; i++)
    s[i] = s[i - 1] + a[i];
int get(int l, int r)
{
    return s[r] - s[l - 1];
}
```

**应用:**

**1. 模 k 和**

$+$ : 模 k 和

$-$ : 模 k 差

```C++
for(int i = 1; i <= n; i++)
    s[i] = (s[i - 1] + a[i] % k + k) % k;
int get(int l, int r)
{
    return ((s[r] - s[l - 1]) + k) % k;
}
```

**2. 元素个数**

$+$ : 符合条件的元素的个数的和

$-$ : 符合条件的元素的个数的差

```C++
for(int i = 1; i <= n; i++)
    s[i] = s[i - 1] + (check(a[i]) ? 1 : 0);
int get(int l, int r)
{
    return s[r] - s[l - 1];
}
```

**3. 乘积**

$+$ : 乘法

$-$ : 除法

```C++
for(int i = 1; i <= n; i++)
    s[i] = s[i - 1] * a[i];
int get(int l, int r)
{
    return s[r] / s[l - 1];
}
```

**4. 异或**

$+$ : 异或

$-$ : 异或

```C++
for(int i = 1; i <= n; i++)
    s[i] = s[i - 1] ^ a[i];
int get(int l, int r)
{
    return s[r] ^ s[l - 1];
}
```

**5. 两个前缀和的差**

 $+$ : 加法

$-$ : 减法

```C++
// 已给定前缀和数组 a[N] 和 b[N]
for(int i = 1; i <= n; i++)
    s[i] = a[i] - b[i];
int get(int l, int r)
{
    return s[r] - s[l - 1];
}
```

> $s_i$ 指标: $[1,i]$ 指标一与指标二的差
>
> 证:
>
> 前缀和数组 $a[N]$ 和 $b[N]$, $a_i$ 表示 $[1,i]$ 内指标一的值, $b_i$ 表示 $[1,i]$ 内指标二的值
>
> $s_r = a_r - b_r$  
>
> $s_{l-1} = a_{l-1} - b_{l-1}$ 
>
> 则 $[l, r]$ 内指标个数 = $(a_r - a_{l-1}) - (b_r - b_{l-1}) = (a_r - b_r) - (a_{l-1} - b_{l-1}) = s_r - s_{l-1}$

**数据结构维护前缀和的相关属性**

**1. 前缀和下标**

```C++
unordered_map<int, int> hash;

// 前缀和最新下标
for(int i = 0; i <= n; i++)
    hash[s[i]] = i;

// 前缀和最旧下标
for(int i = 0; i <= n; i++)
    if(!hash.count(s[i]))
        hash[s[i]] = i;
```

**2. 前缀和出现次数**

```C++
unordered_map<int, int> hash;
for(int i = 0; i <= n; i++)
    hash[s[i]]++;
```



# 算法

## 基础算法

### 快速排序

```C++
void quick_sort(int q[], int l, int r)
{
    if(l >= r) return;
    
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while(i < j)
    {
        do i++; while(q[i] < x);
        do j--; while(q[j] > x);
        if(i < j) swap(q[i], q[j]);
	}
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```

### 归并排序

```C++
void merge_sort(int q[], int l, int r)
{
    if(l >= r) return;
    
    int mid = l + r >> 1;
    
    merge_sort(q, l, mid), merge_sort(q, mid + 1, r);
    
    int i = l, j = mid + 1;
    int tmp[r - l + 1], k = 0;
    
    while(i <= mid && j <= r)
        if(q[i] <= q[j]) tmp[k++] = q[i++];
    	else tmp[k++] = q[j++];
   	while(i <= mid) tmp[k++] = q[i++];
    while(j <= r) tmp[k++] = q[j++];
    
    for(i = l, k = 0; i <= r;) q[i++] = tmp[k++];
}
```

### 二分

**前提:** 数据结构满足二段性

> 二段性: 一分为二, 一段满足某一性质, 一段不满足该性质

**左分界点**

左半边为 true, 右半边为 false

```C++
int fun(int l, int r)
{
    while(l < r)
    {
        int mid = l + r + 1 >> 1;
        if(check(mid)) l = mid;
        else r = mid - 1;
    }
    if(check2(l)) l;
    return -1;
}
```

**右分界点**

右半边为 true, 左半边为 false

```C++
int fun(int l, int r)
{
    while(l < r)
    {
        int mid = l + r >> 1;
        if(check(mid)) r = mid;
        else l = mid + 1;
    }
    if(check2(l)) return l;
    return -1;
}
```

**STL**

`set<int> S;`

**$\geq$ 和 $>$**

失败返回 `S.end()`

```C++
auto it = S.lower_bound(x) / S.upper_bound(x);
if(it != S.end()) return it;
else return -1;
```

**$\leq$ 和 $<$**

失败返回 `S.begin()`

```C++
auto it = S.upper_bound(x) / S.lower_bound;
if(it != S.begin())
{
    it--;
    return it;
}
else return -1;
```

### 双指针

**同向双指针**

**前提:**

1. 区间 $[j, i]$ 满足**某种性质**
2. $j$ 和 $i$ 具有**同向性**

**模板**

```C++
for(int i = 0, j = 0; i < n; i++)
{
    while(j < i && check(j, i)) j++;
    ...
}
```

