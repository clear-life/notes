# 输入输出

**getline**

```C++
int n;
cin >> n; cin.get();

string t;
for(int i = 0; i < n; i++)
    getline(cin, t);
```

# 数据结构

### 队列

```C++
int q[N], hh = 0, tt = -1;

q[hh]; 		// q.front()

q[++tt] = x;// q.push(x)

hh++;		// q.pop()

if(hh <= tt)// q.empty()
```

### 单调栈

**用法:** 从左往右找到每个数**左边第一个比自己小**的数

```C++
for(int i = 1; i <= n; i++)
{
    while(stk.size() && arr[stk.top()] >= arr[i]) stk.pop();
    
    if(stk.size()) stk.top();	// 查找成功
    else -1;					// 查找失败
    
    stk.push(i);
}
```

### 单调队列

**用法:**找到**滑动窗口的最小值**

```C++
for(int i = 1; i <= n; i++)
{
    while(q.size() && arr[q.back()] >= arr[i]) q.pop_back();	// 删除非法元素
    q.push_back(i);												// 插入元素
    while(q.size() && q.front() < i - k + 1) q.pop_front();		// 删除非窗口元素
}
```

### 并查集

**基础**

```C++
int p[N];
for(int i = 1; i <= n; i++) p[i] = i;

// 查询
int find(int x)
{
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}

// 合并
p[find(a)] = find(b);
```

**维护集合大小**

```C++
int p[N], size[N];
for(int i = 1; i <= n; i++)
    p[i] = i, size[i] = 1;

int find(int x)
{
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```

**维护到父亲结点的距离**

```C++
int p[N], d[N];		// d[x] 为 x 到 p[x] 的距离 
for(int i = 1; i <= n; i++)
    p[i] = i, d[i] = 0;

int find(int x)
{
    if(p[x] != x)
    {
        int u = find(p[x]);
        d[x] += d[p[x]];
        p[x] = u;
	}
    return p[x];
}

auto u = find(a), v = find(b);
d[u] = u 到 v 的距离
p[u] = v;
```



### 字典树

**用法:** 高效**存储**和**查找**字符串

```C++
int son[N][26], cnt[N], idx = 1;

// 插入字符串 s
void insert(string &s)
{
    int p = 0;
    for(auto c : s)
    {
        int k = c - 'a';
        
        if(!son[p][k]) son[p][k] = idx++;
        
        p = son[p][k];
    }
    cnt[p]++;
}

// 返回字符串 s 的次数
int query(string &s)
{
    int p = 0;
    for(auto c : s)
    {
        int k = c - 'a';
        
        if(!son[p][k]) return 0;
        
        p = son[p][k];
    }
    return cnt[p];
}
```

### 哈希表

**拉链法**

```C++
int h[N], e[N], ne[N], idx;

int fun(int x)
{
    return (x % N + N) % N;
}

void insert(int x)
{
    int y = fun(x);
    e[idx] = x, ne[idx] = h[y], h[y] = idx++;	// y -> x 的有向边
}

bool find(int x)
{
    int y = fun(x);
    for(int i = h[y]; ~i; i = ne[i])
        if(e[i] == x)
            return true;
   	return false;
}
```

**开放寻址法**

```C++
int h[N];

// 若 x 在哈希表中, 返回其下标, 若不再, 返回应该插入的位置
int find(int x)
{
    int y = fun(x);
    while(h[y] != null && h[y] != x)
    {
        y++;
        if(y == N) y = 0;
    }
    return y;
}
```

### 字符串哈希

**核心思想: 将字符串看成 P 进制数**

> 字符串的 P 进制数符合人类习惯:
>
> 从右往左, 位数依次增大

```C++
const int P = 131 或 13331;

typedef unsigned long long ULL;
ULL h[N], p[N];

// 初始化
p[0] = 1;
for(int i = 1; i <= n; i++)
{
    h[i] = h[i - 1] * P + s[i];
    p[i] = p[i - 1] * P;
}

// 获取指定范围字符串的哈希值
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}
```



### 位运算

**第 k 位**

```C++
x >> k & 1;
```

**第 k 位取反**

```C++
x ^= 1 << k;
```

**最后一位 1**

```C++
lowbit(n) = n & -n;
```

**最低位 1 的位次**

```C++
int k = 0;
while(!(x >> k & 1)) k++;
```

**异或性质**

$a \oplus b = c$

$b \oplus c = a$

$a \oplus c = b$ 

三者但凡成立一个, 则另外两个也一定成立

### 前缀和与差分

**前缀和**

一维

$s[i] = s[i - 1] + a[i]$

```C++
for(int i = 1; i <= n; i++)
    s[i] = s[i - 1] + a[i];

sum[l, r] = s[r] - s[l - 1];
```

二维

```C++
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= m; j++)
        s[i][j] = s[i][j - 1] + s[i - 1][j] - s[i - 1][j - 1] + a[i][j];
int get(int x1, int y1, int x2, int y2)
{
    return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1];
}
```

**差分**

一维

$d[i] = a[i] - a[i - 1]$

```C++
void insert(int l, int r, int c)
{
    d[l] += c, d[r + 1] -= c;
}
```

二维

```C++
void insert(int x1, int y1, int x2, int y2, int c)
{
    d[x1][y1] += c, d[x1][y2 + 1] -= c, d[x2 + 1][y1] -= c, d[x2 + 1][y2 + 1] += c;
}
```

**广义前缀和**

**前提:**

定义**二元运算符** **$+$** 及其**逆运算符 $-$**

> **逆运算符 $-$ **: 若 $a + b = c$, 则 $b = c - a$

有一区间 $[l, r]$, 一分为二为 $[l, k]$ 和 $[k + 1, r]$

设 $[l, k]$ 上 $+$ 运算符的结果为 $a$, $[k + 1, r]$ 上 $+$ 运算符的结果为 $b$, $[l, r]$ 上 $+$ 运算符的结果为 $c$

**二元运算符 $+$ 应满足 $a + b = c$**

**模板:**

$s_i = a_1 + a_2 + \dots + a_i$

```C++
for(int i = 1; i <= n; i++)
    s[i] = s[i - 1] + a[i];
int get(int l, int r)
{
    return s[r] - s[l - 1];
}
```

**应用:**

**1. 模 k 和**

$+$ : 模 k 和

$-$ : 模 k 差

```C++
for(int i = 1; i <= n; i++)
    s[i] = (s[i - 1] + a[i] % k + k) % k;
int get(int l, int r)
{
    return ((s[r] - s[l - 1]) + k) % k;
}
```

**2. 元素个数**

$+$ : 符合条件的元素的个数的和

$-$ : 符合条件的元素的个数的差

```C++
for(int i = 1; i <= n; i++)
    s[i] = s[i - 1] + (check(a[i]) ? 1 : 0);
int get(int l, int r)
{
    return s[r] - s[l - 1];
}
```

**3. 乘积**

$+$ : 乘法

$-$ : 除法

```C++
for(int i = 1; i <= n; i++)
    s[i] = s[i - 1] * a[i];
int get(int l, int r)
{
    return s[r] / s[l - 1];
}
```

**4. 异或**

$+$ : 异或

$-$ : 异或

```C++
for(int i = 1; i <= n; i++)
    s[i] = s[i - 1] ^ a[i];
int get(int l, int r)
{
    return s[r] ^ s[l - 1];
}
```

**5. 两个前缀和的差**

 $+$ : 加法

$-$ : 减法

```C++
// 已给定前缀和数组 a[N] 和 b[N]
for(int i = 1; i <= n; i++)
    s[i] = a[i] - b[i];
int get(int l, int r)
{
    return s[r] - s[l - 1];
}
```

> $s_i$ 指标: $[1,i]$ 指标一与指标二的差
>
> 证:
>
> 前缀和数组 $a[N]$ 和 $b[N]$, $a_i$ 表示 $[1,i]$ 内指标一的值, $b_i$ 表示 $[1,i]$ 内指标二的值
>
> $s_r = a_r - b_r$  
>
> $s_{l-1} = a_{l-1} - b_{l-1}$ 
>
> 则 $[l, r]$ 内指标个数 = $(a_r - a_{l-1}) - (b_r - b_{l-1}) = (a_r - b_r) - (a_{l-1} - b_{l-1}) = s_r - s_{l-1}$

**数据结构维护前缀和的相关属性**

**1. 前缀和下标**

```C++
unordered_map<int, int> hash;

// 前缀和最新下标
for(int i = 0; i <= n; i++)
    hash[s[i]] = i;

// 前缀和最旧下标
for(int i = 0; i <= n; i++)
    if(!hash.count(s[i]))
        hash[s[i]] = i;
```

**2. 前缀和出现次数**

```C++
unordered_map<int, int> hash;
for(int i = 0; i <= n; i++)
    hash[s[i]]++;
```



# 算法

## 基础算法

### 快速排序

```C++
void quick_sort(int q[], int l, int r)
{
    if(l >= r) return;
    
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while(i < j)
    {
        do i++; while(q[i] < x);
        do j--; while(q[j] > x);
        if(i < j) swap(q[i], q[j]);
	}
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```

### 归并排序

```C++
void merge_sort(int q[], int l, int r)
{
    if(l >= r) return;
    
    int mid = l + r >> 1;
    
    merge_sort(q, l, mid), merge_sort(q, mid + 1, r);
    
    int i = l, j = mid + 1;
    int tmp[r - l + 1], k = 0;
    
    while(i <= mid && j <= r)
        if(q[i] <= q[j]) tmp[k++] = q[i++];
    	else tmp[k++] = q[j++];
   	while(i <= mid) tmp[k++] = q[i++];
    while(j <= r) tmp[k++] = q[j++];
    
    for(i = l, k = 0; i <= r;) q[i++] = tmp[k++];
}
```

### 二分

**前提:** 数据结构满足二段性

> 二段性: 一分为二, 一段满足某一性质, 一段不满足该性质

**左分界点**

左半边为 true, 右半边为 false

```C++
int fun(int l, int r)
{
    while(l < r)
    {
        int mid = l + r + 1 >> 1;
        if(check(mid)) l = mid;
        else r = mid - 1;
    }
    if(check2(l)) l;
    return -1;
}
```

**右分界点**

右半边为 true, 左半边为 false

```C++
int fun(int l, int r)
{
    while(l < r)
    {
        int mid = l + r >> 1;
        if(check(mid)) r = mid;
        else l = mid + 1;
    }
    if(check2(l)) return l;
    return -1;
}
```

**STL**

`set<int> S;`

**$\geq$ 和 $>$**

失败返回 `S.end()`

```C++
auto it = S.lower_bound(x) / S.upper_bound(x);
if(it != S.end()) return it;
else return -1;
```

**$\leq$ 和 $<$**

失败返回 `S.begin()`

```C++
auto it = S.upper_bound(x) / S.lower_bound;
if(it != S.begin())
{
    it--;
    return it;
}
else return -1;
```

### 双指针

**同向双指针**

**前提:**

1. 区间 $[j, i]$ 满足**某种性质**
2. $j$ 和 $i$ 具有**同向性**

**模板**

```C++
for(int i = 0, j = 0; i < n; i++)
{
    while(j < i && check(j, i)) j++;
    ...
}
```

