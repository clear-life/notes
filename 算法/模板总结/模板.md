# 输入输出

**getline**

```C++
int n;
cin >> n; cin.get();

string t;
for(int i = 0; i < n; i++)
    getline(cin, t);
```

# 数据结构

**栈**

```C++
stack<int> stk;

stk.top();

stk.push(x);

stk.pop();

stk.empty();
```



**队列**

```C++
int q[N], hh = 0, tt = -1;

q[hh]; 		// q.front()

q[++tt] = x;// q.push(x)

hh++;		// q.pop()

if(hh <= tt)// q.empty()
```



# 算法

## 基础算法

### 位运算

**最低位 1 的位次**

```C++
int k = 0;
while(!(x >> k & 1)) k++;
```



### 二分

**前提:** 数据结构满足二段性

> 二段性: 一分为二, 一段满足某一性质, 一段不满足该性质

**左分界点**

左半边为 true, 右半边为 false

```C++
int fun(int l, int r)
{
    while(l < r)
    {
        int mid = l + r + 1 >> 1;
        if(check(mid)) l = mid;
        else r = mid - 1;
    }
    if(check2(l)) l;
    return -1;
}
```

**右分界点**

右半边为 true, 左半边为 false

```C++
int fun(int l, int r)
{
    while(l < r)
    {
        int mid = l + r >> 1;
        if(check(mid)) r = mid;
        else l = mid + 1;
    }
    if(check2(l)) return l;
    return -1;
}
```

**STL**

`>= 和 >` 失败返回 `S.end()`

`<= 和 <` 失败返回 `S.begin()`

```C++
set<int> S;

// >= 和 >
auto it = S.lower_bound(x) / S.upper_bound(x);
if(it != S.end()) return it;
else return -1;

// <= 和 < 
auto it = S.upper_bound(x) / S.lower_bound;
if(it != S.begin())
{
    it--;
    return it;
}
else return -1;
```

### 双指针

**同向双指针**

**前提:**

1. 区间 $[j, i]$ 满足**某种性质**
2. $j$ 和 $i$ 具有**同向性**

**模板**

```C++
for(int i = 0, j = 0; i < n; i++)
{
    while(j < i && check(j, i)) j++;
    ...
}
```

