# 输入输出

**cin**

过程: 忽略并清除空白符, 读取成功后, 分隔符留在缓冲区

```C++
int n;
cin >> n;

输入: 
  3		// 两个空格 + 数字 3
结果:
n = 3, 并且缓冲区剩下一个换行符
```

**getline**

过程: 

1. string s 记录遇到分隔符前的字符串, 初始化为空
2. 遇到分隔符后, 将 s 记录的字符出赋值给目标字符串
3. 然后跳过分隔符, 返回流对象

```C++
int n;
cin >> n; cin.get();

string t;
for(int i = 0; i < n; i++)
    getline(cin, t);
```





# 数据结构

**栈**

```C++
stack<int> stk;

stk.top();

stk.push(x);

stk.pop();

stk.empty();
```



**队列**

```C++
int q[N], hh = 0, tt = -1;

q[hh]; 		// q.front()

q[++tt] = x;// q.push(x)

hh++;		// q.pop()

if(hh <= tt)// q.empty()
```



# 算法

## 基础算法

### 二分

**条件:** 数据结构满足二段性

> 二段性: 一分为二, 一段满足某一性质, 一段不满足该性质

**左分界点**

左半边为 true, 右半边为 false

```C++
int fun(int l, int r)
{
    while(l < r)
    {
        int mid = l + r + 1 >> 1;
        if(check(mid)) l = mid;
        else r = mid - 1;
    }
    if(check2(l)) l;
    return -1;
}
```

**右分界点**

右半边为 true, 左半边为 false

```C++
int fun(int l, int r)
{
    while(l < r)
    {
        int mid = l + r >> 1;
        if(check(mid)) r = mid;
        else l = mid + 1;
    }
    if(check2(l)) return l;
    return -1;
}
```

**STL**

`>= 和 >` 失败返回 `S.end()`

`<= 和 <` 失败返回 `S.begin()`

```C++
unordered_set<int> S;

// >= 和 >
auto it = S.lower_bound(x) / S.upper_bound(x);
if(it != S.end()) return it;
else return -1;

// <= 和 < 
auto it = S.upper_bound(x) / S.lower_bound;
if(it != S.begin())
{
    it--;
    return it;
}
else return -1;
```

### 双指针

