# 最短路

## 单源最短路径

### 正权图

#### dijkstra 

> $O(n^2)$
>
> 所有的正权有向图都适用, 可以有环与重边

**定义**

V: 图的点集

S: 已算出最短距离的点集

dist[i]: 点 i 距起点的最短距离

**算法**

1. 初始化: dist[st] = 0, dist[其余] = $+\infty$
2.  n 次循环:
   1.  u $\leftarrow$ V - S 中 dist 最小的点
   2. u 加入 S 中, 并用 u 更新其邻接点的 dist 

**代码实现**

```C++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 510, INF = 0x3f3f3f3f;

int g[N][N];    // 图的存储用邻接矩阵
bool st[N];     // 区分点集 S 和 V - S: true 表示 S, false 表示 V - S
int dist[N];    // 计算每个点到起点的最短距离

int n, m;


int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    
    for(int i = 0; i < n; i++)
    {
        // 1. 找到 V - S 中 dist 最小的点 u
        int u = -1;
        for(int j = 1; j <= n; j++)
            if(!st[j] && (u == -1 || dist[j] < dist[u]))
                u = j;
        
        // if(u == n) break; 简单优化
        // 2. 将 u 加入 S 中
        st[u] = true;   
        
        // 3. 更新 u 在 V - S 中的邻接点的 dist
        for(int v = 1; v <= n; v++)
            if(!st[v] && g[u][v] != INF)
                dist[v] = min(dist[v], g[u][v] + dist[u]);
    }
    return dist[n];
}

int main()
{
    cin >> n >> m;
    memset(g, 0x3f, sizeof g);
    for(int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        g[a][b] = min(g[a][b], c);
    }
    
    int t = dijkstra();
    
    if(t == INF) cout << -1 << endl;
    else cout << t << endl;
    
    return 0;
}
```



$~$

#### 堆优化 dijkstra 

> $O(m \log n)$

$~$

### 负权图

#### Bellman-Ford 

> $O(nm)$

#### SPFA 

> $一般 O(m), 最坏 O(nm)$

$~$

## 多源最短路径

#### Floyd

> $O(n^3)$