# 数据分析

## 架构

### 前端, 后端, 数据库

前端发请求给后端, 后端对数据库操作并处理数据, 后端返回前端数据

### 框架

`tornado`



## 关键概念

### 路由

由 `URL` 到函数的**映射**

```
/users        ->  getAllUsers()
/users/count  ->  getUsersCount()
```

#### router 与 route

**router**

1. **映射函数**, 负责把一个 URL 映射为一个函数

2. 管理所有的 `route`, 即接收到一个 URL 后, 从**路由映射表**中查找对应的函数

**route**

**一个具体的映射**, URL 和 函数都是确定的

```
/users        ->  getAllUsers()		// 一条路由
```

**服务器端路由**

1. 服务器接收到客户端的 **HTTP 请求**
2. 根据请求里的 URL, 找到**对应的函数**
3. **执行**该函数
4. 将函数的**返回值发送给客户端**



### 前后端处理流程

**关键概念**

**路由: 由 URL 到函数的映射**

```python
class GetKGPVNeW(ReguestHandler, ABC):
    #对应该路由下的get请求
    def post(self):
    table = self.get_query_argument("table")				# 根据 key 得到 value
    tf_property = self.get_query_argument("tf_property")	
    
    page_num = int(seLf.get_body_argument("page"))			# 获取前端发送的信息
    page_size = int(self.get_body_argument("rows"))			# 根据 key 得到 value
    
    # 调试信息
    # print("get获取的参数: page_num", page_ num,";page_size: "，page_size)
    
    # 数据库操作, 根据前面得到的信息和请求的功能, 对数据库进行操作, 并得到返回值
    data_total,data_fileds = pgsql.load_pv_new(table, tf_property, page_num, page_size)
    
    # 组织发送给前端的数据的结构
    value_json = {"total": data total, "rows": data_fileds}
    
    #解决跨域问题
    seLf.set_header("Access-Control-Allow-0rigin", "*") # 允许所有源访问
    seLf.set_header("Cache-ControL", "no-cache”)
    seLf.set_header("Access-Control-Allow-Method", "GET") # 允许访问的方式
                    
   	# 将数据发送给前端
	seLf.write(json.dumps(value_json))		
```
